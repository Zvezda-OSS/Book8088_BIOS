     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.11.08, might work with other versions
    11                                  ;
    12                                  ;=========================================================================
    13                                  
    14                                  ;-------------------------------------------------------------------------
    15                                  ; Fixed BIOS Entry Points 固定BIOS入口点
    16                                  ; Source:
    17                                  ; Intel(R) Platform Innovation Framework for EFI Compatibility Support Module Specification Section 5.2
    18                                  ; 针对EFI兼容性支持模块规范的Intel（R）平台创新框架第5.2节
    19                                  ;
    20                                  ;	Location		Description
    21                                  ;	位置		描述
    22                                  ;	--------		-----------
    23                                  ;	F000:E05B		POST Entry Point
    24                                  ;	F000:E2C3		NMI Entry Point
    25                                  ;	F000:E401		HDD Parameter Table
    26                                  ;	F000:E6F2		INT 19 Entry Point
    27                                  ;	F000:E6F5		Configuration Data Table
    28                                  ;	F000:E729		Baut Rate Generator Table
    29                                  ;	F000:E739		INT 14 Entry Point
    30                                  ;	F000:E82E		INT 16 Entry Point
    31                                  ;	F000:E987		INT 09 Entry Point
    32                                  ;	F000:EC59		INT 13 (Floppy) Entry Point
    33                                  ;	F000:EF57		INT 0E Entry Point
    34                                  ;	F000:EFC7		Floppy Disk Controller Parameter Table
    35                                  ;	F000:EFD2		INT 17
    36                                  ;	F000:F065		INT 10 (Video) Entry Point
    37                                  ;	F000:F0A4		INT 1D MDA and CGA Video Parameter Table
    38                                  ;	F000:F841		INT 12 Entry Point
    39                                  ;	F000:F84D		INT 11 Entry Point
    40                                  ;	F000:F859		INT 15 Entry Point
    41                                  ;	F000:FA6E		Low 128 Characters of Graphic Video Font
    42                                  ;	F000:FE6E		INT 1A Entry Point
    43                                  ;	F000:FEA5		INT 08 Entry Point
    44                                  ;	F000:FF53		Dummy Interrupt Handler (IRET)
    45                                  ;	F000:FF54		INT 05 (Print Screen) Entry Point
    46                                  ;	F000:FFF0		Power-On Entry Point
    47                                  ;	F000:FFF5		ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    48                                  ;	F000:FFFE		System Model (0xFC - AT, 0xFE - XT)
    49                                  
    50                                  	cpu		8086
    51                                  
    52                                  %include "macro.inc"
    53                              <1> ;=========================================================================
    54                              <1> ; macro.inc - Defines macros
    55                              <1> ;       setloc
    56                              <1> ;-------------------------------------------------------------------------
    57                              <1> ;
    58                              <1> ;=========================================================================
    59                              <1> 
    60                              <1> ;=========================================================================
    61                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    62                              <1> ;-------------------------------------------------------------------------
    63                              <1> %imacro setloc  1.nolist
    64                              <1> %assign pad_bytes (%1-($-$$)-START)
    65                              <1> %if pad_bytes < 0
    66                              <1> %assign over_bytes -pad_bytes
    67                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
    68                              <1> %endif
    69                              <1> %if pad_bytes > 0
    70                              <1> %warning Inserting pad_bytes bytes
    71                              <1>  times  pad_bytes db 0FFh
    72                              <1> %endif
    73                              <1> %endm
    53                                  %include "config.inc"
    54                              <1> ;=========================================================================
    55                              <1> ; config.inc - Compilation time settings and settings
    56                              <1> ;-------------------------------------------------------------------------
    57                              <1> ;
    58                              <1> ; Compiles with NASM 2.11.08, might work with other versions
    59                              <1> ;
    60                              <1> ;
    61                              <1> ;=========================================================================
    62                              <1> 
    63                              <1> %define DATE		'12/20/22'	; BIOS release date MM/DD/YY
    64                              <1> %define VERSION		'1.0.2'		; BIOS version
    65                              <1> 
    66                              <1> ; Machine type is defined in the Makefile
    67                              <1> ;%define MACHINE_XI8088			; Xi 8088
    68                              <1> ;%define MACHINE_FE2010A 			; Faraday FE2010A
    69                              <1> ;%define MACHINE_XT			; IBM PC/XT or highly compatible board
    70                              <1> 					; FIXME: not implemented yet
    71                              <1> ; Settings for Xi 8088
    72                              <1> %ifdef MACHINE_XI8088
    73                              <1> %define	START		8000h		; BIOS starts at offset 8000h
    74                              <1> %define MODEL_BYTE	0FCh		; Pretend it is an IBM PC/AT 假装它是IBM PC/AT
    75                              <1> ;%define AT_KEYBOARD
    76                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
    77                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
    78                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
    79                              <1> 
    80                              <1> %endif ; MACHINE_XI8088
    81                              <1> 
    82                              <1> ; Settings for IBM PC/XT
    83                              <1> %ifdef MACHINE_XT
    84                              <1> ;%define	START		0E000h		; BIOS starts at offset 0E000h
    85                              <1> %define	START		0C000h		; FIXME: more ROM for development
    86                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
    87                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
    88                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
    89                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
    90                              <1> %endif ; MACHINE_XT
    91                              <1> 
    54                                  %include "errno.inc"
    55                              <1> ;=========================================================================
    56                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
    57                              <1> ; 错误编号： POST检查点代码（POST期间发送到端口80h）
    58                              <1> ;-------------------------------------------------------------------------
    59                              <1> ;
    60                              <1> ; Compiles with NASM 2.11.08, might work with other versions
    61                              <1> ;
    62                              <1> ;=========================================================================
    63                              <1> 
    64                              <1> e_boot		equ	00h		; Boot the OS
    65                              <1> e_cpu_test	equ	01h		; Start of BIOS POST, CPU test
    66                              <1> e_init_cfg	equ	02h		; Initial chipset configuration:
    67                              <1> 					; initialize PPI, disable NMI
    68                              <1> 					; disable turbo mode, disable display
    69                              <1> e_init_dmac	equ	03h		; Initialize DMAC initialized
    70                              <1> e_low_ram_test	equ	04h		; Test low 32 KiB of RAM
    71                              <1> e_int_table	equ	05h		; Initialize interrupt table
    72                              <1> e_pit_init	equ	06h		; Initialize PIT (timer)
    73                              <1> 					; play power on melody
    74                              <1> e_pic_init	equ	07h		; Initialize PIC
    75                              <1> e_kbd_init	equ	08h		; Initialize KBC and keyboard
    76                              <1> e_int_ena	equ	09h		; Enable interrupts
    77                              <1> e_vid_bios_scan	equ	10h		; Locate video BIOS
    78                              <1> e_vid_bios_init	equ	11h		; Initialize video BIOS
    79                              <1> e_vid_no_bios	equ	12h		; No video BIOS, using MDA/CGA
    80                              <1> e_rtc_init	equ	20h		; Initialize RTC
    81                              <1> e_cpu_detect	equ	21h		; Detect CPU type
    82                              <1> e_fpu_detect	equ	22h		; Detect FPU
    83                              <1> e_serial_scan	equ	24h		; Detect serial ports
    84                              <1> e_parallel_scan	equ	25h		; Detect parallel ports
    85                              <1> e_ram_start	equ	30h		; Start RAM test
    86                              <1> e_ram_complete	equ	31h		; RAM test completed
    87                              <1> e_ram_esc	equ	32h		; RAM test canceled
    88                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
    89                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found, initizalize
    90                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
    91                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
    92                              <1> e_cpu_fail	equ	52h		; CPU test failed
    93                              <1> e_low_ram_fail	equ	54h		; Low 32 KiB RAM test failed
    94                              <1> e_ram_fail	equ	55h		; RAM test failed
    95                              <1> e_kbc_flsh_fail	equ	60h		; Unable to flush KBC output buffer
    96                              <1> e_kbc_cmd_fail	equ	61h		; Unable to send command to KBC
    97                              <1> e_kbc_test_fail	equ	62h		; Keyboard controller self test failed
    98                              <1> e_kbc_int_fail	equ	63h		; Keyboard interface test failed
    99                              <1> e_kbd_bat_fail	equ	70h		; Keyboard BAT test failed
   100                              <1> e_kbd_dis_fail	equ	71h		; Keyboard disable command failed
   101                              <1> e_kbd_ena_fail	equ	72h		; Keyboard enable command failed
   102                              <1> ;-------------------------------------------------------------------------
   103                              <1> ; Minor numbers for keyboard errors 键盘错误的次要数字
   104                              <1> e_kbd_tout_fail	equ	01h		; Keyboard timeout sending command
   105                              <1> e_kbd_resp_fail	equ	02h		; Keyboard no response 键盘无响应
   106                              <1> e_kbd_nack_fail	equ	03h		; Acknowledge response was expected
   107                              <1> 					; but keyboard have sent something else
   108                              <1> e_kbd_rsp2_fail	equ	04h		; Keyboard no response byte 2 for BAT
   109                              <1> e_kbd_nbat_fail	equ	05h		; BAT OK response was expected
   110                              <1> 					; but keyboard have sent something else
   111                              <1> e_kbd_test_fail	equ	06h		; Keyboard controller test failed
   112                              <1> e_kbd_int_fail	equ	07h		; Keyboard interface test failed
    55                                  
    56                                  bioscseg		equ	0F000h
    57                                  biosdseg		equ	0040h
    58                                  
    59                                  pic1_reg0		equ	20h
    60                                  pic1_reg1		equ	21h
    61                                  pit_ch0_reg	equ	40h
    62                                  pit_ch1_reg	equ	41h
    63                                  pit_ch2_reg	equ	42h
    64                                  pit_ctl_reg		equ	43h
    65                                  
    66                                  ; 8255 PPI port A I/O register - Read - keyboard data
    67                                  ppi_pa_reg	equ	60h	; 8255 PPI port A I/O register XT机中60h是键盘数据端口
    68                                  
    69                                  ; Port 61h - 8255 PPI Port B - Write only
    70                                  ppi_pb_reg	equ	61h	; 8255 PPI port B I/O register
    71                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
    72                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
    73                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
    74                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
    75                                  
    76                                  post_reg		equ	80h	; POST status output port
    77                                  nmi_mask_reg	equ	0A0h
    78                                  
    79                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
    80                                  cga_mode_reg	equ	3D8h
    81                                  mda_mode_reg	equ	3B8h
    82                                  
    83                                  ; NMI mask (written to 0A0h)
    84                                  nmi_disable	equ	00h	; disable NMI
    85                                  nmi_disa_mask	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
    86                                  nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
    87                                  
    88                                  pic_freq		equ	1193182	; PIC input frequency - 14318180 MHz / 12
    89                                  
    90                                  ;========================================================================
    91                                  ; BIOS data area variables
    92                                  ;------------------------------------------------------------------------
    93                                  equip_serial	equ	00h		; word[4] - addresses of serial ports
    94                                  					; or 0 if port doesn't exist
    95                                  equip_parallel	equ	08h		; word[3] - addresses of parallel ports
    96                                  					; or 0 if port doesn't exist
    97                                  ebda_segment	equ	0Eh		; word - address of EBDA segment
    98                                  equipment_list	equ	10h		; word - equpment list
    99                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   100                                  equip_fpu		equ	0000000000000010b	; FPU installed
   101                                  equip_mouse	equ	0000000000000100b
   102                                  equip_video	equ	0000000000110000b	; video type bit mask
   103                                  equip_color_40	equ	0000000000010000b	; color 40x24 (mode 1)
   104                                  equip_color_80	equ	0000000000100000b	; color 80x25 (mode 3)
   105                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   106                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   107                                  ;			|||||||||||||||`-- floppy drives installed
   108                                  ;			||||||||||||||`-- FPU installed
   109                                  ;			|||||||||||||`-- PS/2 mouse installed
   110                                  ;			||||||||||||`-- reserved
   111                                  ;			||||||||||`--- initial video mode
   112                                  ;			||||||||`---- number of floppy drives - 1
   113                                  ;			|||||||`---- O = DMA installed
   114                                  ;			||||`------ number of serial ports
   115                                  ;			|||`------ game adapter installed
   116                                  ;			||`------ internal modem?!
   117                                  ;			`------- number of parallel ports
   118                                  
   119                                  post_flags		equ	12h	; byte - post flags
   120                                  post_setup	equ	01h	; run NVRAM setup
   121                                  memory_size	equ	13h	; word - memory size in KiB
   122                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   123                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   124                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   125                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   126                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   127                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   128                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   129                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   130                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   131                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   132                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   133                                  video_mode	equ	49h	; byte - active video mode number
   134                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   135                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   136                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   137                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   138                                  video_cur_shape	equ	60h	; word - cursor shape
   139                                  video_page	equ	62h	; byte - active video page
   140                                  video_port	equ	63h	; word - I/O port for the display adapter
   141                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   142                                  video_palet_reg	equ	66h	; byte - color palette
   143                                  last_irq		equ	6Bh	; byte - Last spurious IRQ number
   144                                  ticks_lo		equ	6Ch	; word - timer ticks - low word
   145                                  ticks_hi		equ	6Eh	; word - timer ticks - high word
   146                                  new_day		equ	70h	; byte - 1 = new day flag
   147                                  break_flag		equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   148                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   149                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   150                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   151                                  kbd_buffer_start 	equ	80h	; word - keyboard buffer start offset
   152                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   153                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   154                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   155                                  fdc_info		equ	8Fh	; byte - floppy dist drive information
   156                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   157                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   158                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   159                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   160                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   161                                  prt_scrn_ready	equ	00h	; print screen is not in progress
   162                                  prt_scrn_run	equ	01h	; print screen is in progress
   163                                  prt_scrn_fail	equ	0FFh	; last print screen attempt has failed
   164                                  
   165                                  ;=========================================================================
   166                                  ; Extended BIOS data area variables
   167                                  ;-------------------------------------------------------------------------
   168                                  ebda_size		equ	0h
   169                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   170                                  mouse_flags_1	equ	26h
   171                                  mouse_flags_2	equ	27h
   172                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   173                                  
   174                                  	org	START		; Use only upper 32 KiB of ROM
   175                                  
   176                                  ;=========================================================================
   177                                  ; Includes
   178                                  ;-------------------------------------------------------------------------
   179                                  %include	"messages.inc"		; POST messages
   180                              <1> ;=========================================================================
   181                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   182                              <1> ;-------------------------------------------------------------------------
   183                              <1> ;
   184                              <1> ;=========================================================================
   185                              <1> 
   186 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   187 00000002 4359434C4520436F6D- <1> 		db	"CYCLE Computer BIOS"
   187 0000000B 70757465722042494F- <1>
   187 00000014 53                  <1>
   188 00000015 205620              <1> 		db	" V "
   189 00000018 312E302E32          <1> 		db	VERSION
   190 0000001D 2E20                <1> 		db	". "
   191 0000001F 436F70797269676874- <1> 		db	"Copyright (C) 2022 CYCLE Logic", 0Dh, 0Ah
   191 00000028 202843292032303232- <1>
   191 00000031 204359434C45204C6F- <1>
   191 0000003A 6769630D0A          <1>
   192 0000003F 5757572E            <1> 		db	"WWW."
   193 00000043 383038364350552E43- <1> 		db	"8086CPU.COM", 0Dh, 0Ah
   193 0000004C 4F4D0D0A            <1>
   194                              <1> 
   195 00000050 0D0A00              <1> msg_crlf		db     	0Dh, 0Ah, 00h
   196 00000053 6E6F6E6500          <1> msg_none		db	'none', 00h
   197 00000058 3A2000              <1> msg_colon	db	': ', 00h
   198 0000005B 3B2000              <1> msg_semicolon	db	'; ', 00h
   199                              <1> 
   200                              <1> %ifdef TURBO_MODE
   201                              <1> msg_cpu_clk	db	'CPU clock frequency:        ', 00h
   202                              <1> msg_at		db	' @ ', 00h
   203                              <1> msg_clk_4_77mhz	db	'4.77 MHz ', 00h
   204                              <1> %endif ; TURBO_MODE
   205                              <1> 
   206 0000005E 4350553A2020202020- <1> msg_cpu		db      'CPU:                        ', 00h	;28个字符
   206 00000067 202020202020202020- <1>
   206 00000070 202020202020202020- <1>
   206 00000079 2000                <1>
   207 0000007B 4650553A2020202020- <1> msg_fpu		db      'FPU:                        ', 00h
   207 00000084 202020202020202020- <1>
   207 0000008D 202020202020202020- <1>
   207 00000096 2000                <1>
   208 00000098 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 00h
   208 000000A1 382027373800        <1>
   209 000000A7 5741524E494E473A20- <1> msg_cpu_bug	db      'WARNING: This CPU does not disable interrupts '
   209 000000B0 546869732043505520- <1>
   209 000000B9 646F6573206E6F7420- <1>
   209 000000C2 64697361626C652069- <1>
   209 000000CB 6E7465727275707473- <1>
   209 000000D4 20                  <1>
   210 000000D5 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
   210 000000DE 64696E67207365676D- <1>
   210 000000E7 656E74207265676973- <1>
   210 000000F0 74657273210D0A00    <1>
   211 000000F8 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 "
   211 00000101 382027383120        <1>
   212 00000107 2F204F4B4920383043- <1> 		db      '/ OKI 80C88', 00h
   212 00000110 383800              <1>
   213 00000113 486172726973203830- <1> msg_cpu_harris  	db      'Harris 80C88', 00h
   213 0000011C 43383800            <1>
   214 00000120 4E4543203830383828- <1> msg_cpu_nec_v20 	db      'NEC 8088(V20)', 00h
   214 00000129 5632302900          <1>
   215 0000012E 496E74656C20383038- <1> msg_fpu_present 	db      'Intel 8087', 0Dh, 0Ah, 00h
   215 00000137 370D0A00            <1>
   216 0000013B 446973706C61792054- <1> msg_disp		db	'Display Type:               ', 00h
   216 00000144 7970653A2020202020- <1>
   216 0000014D 202020202020202020- <1>
   216 00000156 2000                <1>
   217 00000158 4547412F5647412028- <1> msg_disp_ega	db	'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   217 00000161 566964656F2042494F- <1>
   217 0000016A 532050726573656E74- <1>
   217 00000173 290D0A00            <1>
   218 00000177 434741202838307832- <1> msg_disp_cga_80	db	'CGA (80x25)', 0Dh, 0Ah, 00h
   218 00000180 35290D0A00          <1>
   219 00000185 434741202834307832- <1> msg_disp_cga_40	db	'CGA (40x25)', 0Dh, 0Ah, 00h
   219 0000018E 35290D0A00          <1>
   220 00000193 4D4441206F72204865- <1> msg_disp_mda	db     	'MDA or Hercules', 0Dh, 0Ah, 00h
   220 0000019C 7263756C65730D0A00  <1>
   221 000001A5 52544320285265616C- <1> msg_rtc		db	'RTC (Real Time Clock):      ', 00h
   221 000001AE 2054696D6520436C6F- <1>
   221 000001B7 636B293A2020202020- <1>
   221 000001C0 2000                <1>
   222 000001C2 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
   222 000001CB 736B20647269766573- <1>
   222 000001D4 3A2020202020202020- <1>
   222 000001DD 20447269766520303A- <1>
   222 000001E6 2000                <1>
   223 000001E8 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   223 000001F1 3A2000              <1>
   224 000001F4 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   224 000001FD 2E32352200          <1>
   225 00000202 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   225 0000020B 2E32352200          <1>
   226 00000210 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   226 00000219 2E352200            <1>
   227 0000021D 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   227 00000226 332E352200          <1>
   228 0000022B 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   228 00000234 332E352200          <1>
   229 00000239 50726573656E740D0A- <1> msg_present	db     	'Present', 0Dh, 0Ah, 00h
   229 00000242 00                  <1>
   230 00000243 416273656E740D0A00  <1> msg_absent	db     	'Absent', 0Dh, 0Ah, 00h
   231 0000024C 53657269616C20506F- <1> msg_serial		db	'Serial Ports:               ', 00h
   231 00000255 7274733A2020202020- <1>
   231 0000025E 202020202020202020- <1>
   231 00000267 2000                <1>
   232 00000269 434F4D00            <1> msg_serial_com	db	'COM', 00h
   233 0000026D 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   233 00000276 506F7274733A202020- <1>
   233 0000027F 202020202020202020- <1>
   233 00000288 2000                <1>
   234 0000028A 4C505400            <1> msg_parallel_lpt 	db	'LPT', 00h
   235 0000028E 446574656374696E67- <1> msg_ram_testing	db	'Detecting RAM (ESC to exit):  ', 00h
   235 00000297 2052414D2028455343- <1>
   235 000002A0 20746F206578697429- <1>
   235 000002A9 3A202000            <1>
   236 000002AD 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   236 000002B6 4661756C7479206D65- <1>
   236 000002BF 6D6F72792064657465- <1>
   236 000002C8 637465642061742000  <1>
   237 000002D1 0D52414D3A20202020- <1> msg_ram_total	db      0Dh, 'RAM:                        ', 00h
   237 000002DA 202020202020202020- <1>
   237 000002E3 202020202020202020- <1>
   237 000002EC 202000              <1>
   238 000002EF 204B420D0A00        <1> msg_kib		db      ' KB', 0Dh, 0Ah, 00h
   239 000002F5 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   239 000002FE 65642C207072657373- <1>
   239 00000307 20616E79206B657920- <1>
   239 00000310 746F20747279206167- <1>
   239 00000319 61696E2E2E2E0D0A00  <1>
   240 00000322 4E6F20524F4D204241- <1> msg_no_basic    	db      'No ROM BASIC', 0Dh, 0Ah, 0
   240 0000032B 5349430D0A00        <1>
   241 00000331 466F756E642042494F- <1> msg_rom_found   	db      'Found BIOS extension ROM at ', 0
   241 0000033A 5320657874656E7369- <1>
   241 00000343 6F6E20524F4D206174- <1>
   241 0000034C 2000                <1>
   242 0000034E 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   242 00000357 6C697A696E672E2E2E- <1>
   242 00000360 0D0A00              <1>
   243 00000363 426F6F74696E67204F- <1> msg_boot		db      'Booting OS...', 0Dh, 0Ah, 0
   243 0000036C 532E2E2E0D0A00      <1>
   244                              <1> 
   245 00000373 [5300]              <1> tbl_floppy	dw	msg_none
   246 00000375 [F401]              <1> 		dw	msg_floppy_360
   247 00000377 [0202]              <1> 		dw	msg_floppy_1200
   248 00000379 [1002]              <1> 		dw	msg_floppy_720
   249 0000037B [1D02]              <1> 		dw	msg_floppy_1440
   250 0000037D [5300]              <1> 		dw	msg_none
   251 0000037F [2B02]              <1> 		dw	msg_floppy_2880
   252 00000381 [5300]              <1> 		dw	msg_none
   180                                  
   181                                  %ifndef MACHINE_XT		; No space in XT ROM for font
   182                                  %include	"fnt80-FF.inc"		; font for graphics modes
   183                              <1> ;=========================================================================
   184                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   185                              <1> ;       Characters from 80h to 0FFh
   186                              <1> ;-------------------------------------------------------------------------
   187                              <1> ;
   188                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   189                              <1> ;
   190                              <1> ; This font is borrowed from kbd package (alt-8x8)
   191                              <1> ;
   192                              <1> ; This program is free software: you can redistribute it and/or modify
   193                              <1> ; it under the terms of the GNU General Public License as published by
   194                              <1> ; the Free Software Foundation, either version 3 of the License, or
   195                              <1> ; (at your option) any later version.
   196                              <1> ;
   197                              <1> ; This program is distributed in the hope that it will be useful,
   198                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   199                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   200                              <1> ; GNU General Public License for more details.
   201                              <1> ;
   202                              <1> ; You should have received a copy of the GNU General Public License
   203                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   204                              <1> ;
   205                              <1> ;=========================================================================
   206                              <1> int_1F:
   207 00000383 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   208 0000038B 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   209 00000393 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   210 0000039B 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   211 000003A3 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   212 000003AB 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   213 000003B3 DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   214 000003BB 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   215 000003C3 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   216 000003CB 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   217 000003D3 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   218 000003DB 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   219 000003E3 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   220 000003EB 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   221 000003F3 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   222 000003FB 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   223 00000403 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   224 0000040B 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   225 00000413 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   226 0000041B 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   227 00000423 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   228 0000042B 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   229 00000433 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   230 0000043B 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   231 00000443 DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   232 0000044B DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   233 00000453 E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   234 0000045B C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   235 00000463 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   236 0000046B 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   237 00000473 CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   238 0000047B 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   239 00000483 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   240 0000048B 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   241 00000493 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   242 0000049B 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   243 000004A3 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   244 000004AB 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   245 000004B3 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   246 000004BB 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   247 000004C3 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   248 000004CB 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   249 000004D3 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   250 000004DB 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   251 000004E3 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   252 000004EB 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   253 000004F3 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   254 000004FB 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   255 00000503 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   256 0000050B 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   257 00000513 DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   258 0000051B 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   259 00000523 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   260 0000052B 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   261 00000533 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   262 0000053B 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   263 00000543 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   264 0000054B 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   265 00000553 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   266 0000055B 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   267 00000563 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   268 0000056B 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   269 00000573 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   270 0000057B 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   271 00000583 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   272 0000058B 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   273 00000593 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   274 0000059B 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   275 000005A3 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   276 000005AB 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   277 000005B3 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   278 000005BB 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   279 000005C3 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   280 000005CB 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   281 000005D3 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   282 000005DB 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   283 000005E3 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   284 000005EB 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   285 000005F3 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   286 000005FB 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   287 00000603 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   288 0000060B 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   289 00000613 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   290 0000061B 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   291 00000623 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   292 0000062B 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   293 00000633 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   294 0000063B 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   295 00000643 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   296 0000064B 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   297 00000653 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   298 0000065B FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   299 00000663 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   300 0000066B F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   301 00000673 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   302 0000067B FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   303 00000683 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   304 0000068B 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   305 00000693 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   306 0000069B 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   307 000006A3 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   308 000006AB 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   309 000006B3 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   310 000006BB 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   311 000006C3 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   312 000006CB 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   313 000006D3 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   314 000006DB 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   315 000006E3 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   316 000006EB 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   317 000006F3 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   318 000006FB 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   319 00000703 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   320 0000070B 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   321 00000713 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   322 0000071B 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   323 00000723 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   324 0000072B 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   325 00000733 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   326 0000073B 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   327 00000743 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   328 0000074B 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   329 00000753 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   330 0000075B 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   331 00000763 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   332 0000076B 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   333 00000773 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   334 0000077B 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   183                                  %endif ; MACHINE_XT
   184                                  
   185                                  %ifdef AT_KEYBOARD
   186                                  %include	"at_kbc.inc"	
   187                                  %endif  ; AT_KEYBOARD
   188                                  
   189                                  %include	"delay.inc"		; delay function
   190                              <1> ;=========================================================================
   191                              <1> ; delay.inc - Delay functions
   192                              <1> ;-------------------------------------------------------------------------
   193                              <1> ;
   194                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   195                              <1> ;
   196                              <1> ;=========================================================================
   197                              <1> ; SHAN修改备注:
   198                              <1> ; 1，AT_DELAY编译条件在config.inc文件中设置，目前已屏蔽，则由cpu时钟提供非精确延时
   199                              <1> ;=========================================================================
   200                              <1> 
   201                              <1> %ifdef PIT_DELAY
   202                              <1> 
   203                              <1> ;=========================================================================
   204                              <1> ; delay_15us - delay for multiplies of 15 microseconds 15微秒倍数的延迟
   205                              <1> ; Input:
   206                              <1> ;	CX = time to delay (in 15 microsecond units)
   207                              <1> ; Notes:
   208                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us 实际延迟介于（CX-1）*15us和CX*15us之间
   209                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
   210                              <1> ;	    timer channel 1. Will not function properly if timer gets
   211                              <1> ;	    reprogrammed by an application or if it was not initialized yet
   212                              <1> ;	这依赖于端口61h的“刷新”位，因此依赖于计时器通道1。如果计时器被应用程序重新编程或尚未初始化，将无法正常工作
   213                              <1> ;  注意！！！！硬件已经取消此通道，仅仅保留程序做参考，不要开启此宏定义！！！！！！！
   214                              <1> ;-------------------------------------------------------------------------
   215                              <1> delay_15us:
   216                              <1> 	push	ax
   217                              <1> 	push	cx
   218                              <1> .zero:
   219                              <1> 	in	al,ppi_pb_reg
   220                              <1> 	test	al,refresh_flag
   221                              <1> 	jz	.zero
   222                              <1> 	dec	cx
   223                              <1> 	jz	.exit
   224                              <1> .one:
   225                              <1> 	in	al,ppi_pb_reg
   226                              <1> 	test	al,refresh_flag
   227                              <1> 	jnz	.one
   228                              <1> 	dec	cx
   229                              <1> 	jnz	.zero
   230                              <1> .exit:
   231                              <1> 	pop	cx
   232                              <1> 	pop	ax
   233                              <1> 	ret
   234                              <1> 
   235                              <1> %else ; PIT_DELAY
   236                              <1> 
   237                              <1> ;=========================================================================
   238                              <1> ; delay_15us - delay for multiplies of approximately 15 microseconds 大约15微秒的倍数延迟
   239                              <1> ; Input:
   240                              <1> ;	CX = time to delay (in 15 microsecond units)
   241                              <1> ; Notes:
   242                              <1> ;	This implementation does not provide precise timing
   243                              <1> ;	The actual delay depends on the CPU clock frequency
   244                              <1> ;	此实现不提供精确定时实际延迟取决于CPU时钟频率
   245                              <1> ;-------------------------------------------------------------------------
   246                              <1> delay_15us:
   247 00000783 50                  <1> 	push	ax
   248 00000784 51                  <1> 	push	cx
   249                              <1> .1:
   250 00000785 B004                <1> 	mov	al,4
   251                              <1> .2:
   252 00000787 FEC8                <1> 	dec	al
   253 00000789 75FC                <1> 	jnz	.2
   254 0000078B E2F8                <1> 	loop	.1
   255 0000078D 59                  <1> 	pop	cx
   256 0000078E 58                  <1> 	pop	ax
   257 0000078F C3                  <1> 	ret
   258                              <1> 
   259                              <1> %endif ; AT_DELAY
   260                              <1> 
   261                              <1> 
   262                              <1> %if 0
   263                              <1> ;=========================================================================
   264                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result 将64位参数除以32位，返回64位结果
   265                              <1> ; Input:
   266                              <1> ;	DX:AX	- dividend		被除数
   267                              <1> ;	CX	- divisor		除数
   268                              <1> ; Output:
   269                              <1> ;	DX:AX	- quotient		商，结果
   270                              <1> ;-------------------------------------------------------------------------
   271                              <1> divide_32:
   272                              <1> 	or	dx,dx
   273                              <1> 	jnz	.1
   274                              <1> 	div	cx
   275                              <1> 	xor	dx,dx
   276                              <1> 	ret
   277                              <1> .1:
   278                              <1> 	push	bx
   279                              <1> 	mov	bx,ax
   280                              <1> 	mov	ax,dx
   281                              <1> 	xor	dx,dx
   282                              <1> 	div	cx
   283                              <1> 	xchg	bx,ax
   284                              <1> 	div	cx
   285                              <1> 	mov	dx,bx
   286                              <1> 	pop	bx
   287                              <1> 	ret
   288                              <1> %endif ; 0
   190                                  %include	"time1.inc"		; time services
   191                              <1> ;=========================================================================
   192                              <1> ; time1.inc - BIOS Time Services
   193                              <1> ;       INT 1Ah - BIOS Time Services
   194                              <1> ;		functions AH=00h to AH=07h
   195                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
   196                              <1> ;-------------------------------------------------------------------------
   197                              <1> ;
   198                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   199                              <1> ;
   200                              <1> ; Copyright (C) 2010 - 2020 Sergey Kiselev.
   201                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   202                              <1> ;
   203                              <1> ; This program is free software: you can redistribute it and/or modify
   204                              <1> ; it under the terms of the GNU General Public License as published by
   205                              <1> ; the Free Software Foundation, either version 3 of the License, or
   206                              <1> ; (at your option) any later version.
   207                              <1> ;
   208                              <1> ; This program is distributed in the hope that it will be useful,
   209                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   210                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   211                              <1> ; GNU General Public License for more details.
   212                              <1> ;
   213                              <1> ; You should have received a copy of the GNU General Public License
   214                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   215                              <1> ;
   216                              <1> ;=========================================================================
   217                              <1> 
   218                              <1> ;=========================================================================
   219                              <1> ; int_1A_fn00 - Read current time
   220                              <1> ; Input:
   221                              <1> ;	AH = 0 - read current time
   222                              <1> ; Output:
   223                              <1> ;	CX = high word of tick count
   224                              <1> ;	DX = low word of tick count
   225                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
   226                              <1> ;-------------------------------------------------------------------------
   227                              <1> int_1A_fn00:
   228 00000790 8B166C00            <1> 	mov	dx,word [ticks_lo]
   229 00000794 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
   230 00000798 A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
   231 0000079B 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
   232 0000079F E9E776              <1> 	jmp	int_1A_exit
   233                              <1> 
   234                              <1> ;=========================================================================
   235                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
   236                              <1> ; Input:
   237                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
   238                              <1> ;	CX = high word of tick count
   239                              <1> ;	DX = low word of tick count
   240                              <1> ; Output:
   241                              <1> ;	None
   242                              <1> ;-------------------------------------------------------------------------
   243                              <1> int_1A_fn01:
   244 000007A2 89166C00            <1> 	mov	word [ticks_lo],dx
   245 000007A6 890E6E00            <1> 	mov	word [ticks_hi],cx
   246 000007AA C606700000          <1> 	mov	byte [new_day],00h
   247 000007AF E9D776              <1> 	jmp	int_1A_exit
   248                              <1> 
   249                              <1> %ifdef AT_RTC
   250                              <1> 
   251                              <1> ;=========================================================================
   252                              <1> ; int_1A_fn02 - Read real time clock (RTC)
   253                              <1> ; Input:
   254                              <1> ;	AH = 02h - function 02h - read RTC time
   255                              <1> ; Output:
   256                              <1> ;	CF set if RTC update is in progress and operation was not performed
   257                              <1> ;	CH = BCD hours
   258                              <1> ;	CL = BCD minutes
   259                              <1> ;	DH = BCD seconds
   260                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
   261                              <1> ;-------------------------------------------------------------------------
   262                              <1> int_1A_fn02:
   263                              <1> %ifdef AT_RTC_AUTODETECT
   264                              <1> 	call	rtc_detect		; check that RTC is present
   265                              <1> 	jc	int_1A_exitf		; error - no RTC
   266                              <1> %endif ; AT_RTC_AUTODETECT
   267                              <1> 	push	ax
   268                              <1> 	mov	al,cmos_control_a
   269                              <1> 	call	rtc_read		; read control A register
   270                              <1> 	test	al,cmos_uip
   271                              <1> 	jz	.1			; no update in progess
   272                              <1> 	stc
   273                              <1> 	pop	ax
   274                              <1> 	jmp	int_1A_exitf
   275                              <1> .1:
   276                              <1> 	mov	al,cmos_control_b
   277                              <1> 	call	rtc_read		; read control B register
   278                              <1> 	and	al,cmos_dse		; mask the daylight savings bit
   279                              <1> 	mov	dl,al
   280                              <1> 	mov	al,cmos_seconds
   281                              <1> 	call	rtc_read		; read seconds
   282                              <1> 	mov	dh,al
   283                              <1> 	mov	al,cmos_minutes
   284                              <1> 	call	rtc_read		; read minutes
   285                              <1> 	mov	cl,al
   286                              <1> 	mov	al,cmos_hours
   287                              <1> 	call	rtc_read		; read hours
   288                              <1> 	mov	ch,al
   289                              <1> 	clc
   290                              <1> 	pop	ax
   291                              <1> 	jmp	int_1A_exitf
   292                              <1> 
   293                              <1> ;=========================================================================
   294                              <1> ; int_1A_fn03 - Set real time clock
   295                              <1> ; Input:
   296                              <1> ;	AH = 03h - function 03h - set RTC time
   297                              <1> ;	CH = BCD hours
   298                              <1> ;	CL = BCD minutes
   299                              <1> ;	DH = BCD seconds
   300                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
   301                              <1> ; Output:
   302                              <1> ;	None
   303                              <1> ;-------------------------------------------------------------------------
   304                              <1> int_1A_fn03:
   305                              <1> %ifdef AT_RTC_AUTODETECT
   306                              <1> 	call	rtc_detect		; check that RTC is present
   307                              <1> 	jc	int_1A_exitf		; error - no RTC
   308                              <1> %endif ; AT_RTC_AUTODETECT
   309                              <1> 	push	ax
   310                              <1> 	mov	al,cmos_control_b
   311                              <1> 	call	rtc_read		; read control B register
   312                              <1> 	mov	ah,al
   313                              <1> 	or	ah,cmos_set		; set the RTC set bit
   314                              <1> 	mov	al,cmos_control_b
   315                              <1> 	call	rtc_write		; write control B register
   316                              <1> 
   317                              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
   318                              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
   319                              <1> 	or	ah,dl			; add it from the input
   320                              <1> 	mov	al,cmos_control_b
   321                              <1> 	call	rtc_write		; write control B register
   322                              <1> 
   323                              <1> 	mov	al,cmos_seconds
   324                              <1> 	mov	ah,dh
   325                              <1> 	call	rtc_write		; write seconds
   326                              <1> 	mov	al,cmos_minutes
   327                              <1> 	mov	ah,cl
   328                              <1> 	call	rtc_write		; write minutes
   329                              <1> 	mov	al,cmos_hours
   330                              <1> 	mov	ah,ch
   331                              <1> 	call	rtc_write		; write hours
   332                              <1> 
   333                              <1> 	mov	al,cmos_control_b
   334                              <1> 	call	rtc_read		; read control B register
   335                              <1> 	mov	ah,al
   336                              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   337                              <1> 	mov	al,cmos_control_b
   338                              <1> 	call	rtc_write		; write control B register
   339                              <1> 	pop	ax
   340                              <1> 	jmp	int_1A_exit
   341                              <1> 
   342                              <1> ;=========================================================================
   343                              <1> ; int_1A_fn04 - Read date from real time clock
   344                              <1> ; Input:
   345                              <1> ;	AH = 04h - function 04h - read RTC date
   346                              <1> ; Output:
   347                              <1> ;	CF set if RTC update is in progress and operation was not performed
   348                              <1> ;	CH = BCD century
   349                              <1> ;	CL = BCD year
   350                              <1> ;	DH = BCD month
   351                              <1> ;	DL = BCD date
   352                              <1> ;-------------------------------------------------------------------------
   353                              <1> int_1A_fn04:
   354                              <1> %ifdef AT_RTC_AUTODETECT
   355                              <1> 	call	rtc_detect		; check that RTC is present
   356                              <1> 	jc	int_1A_exitf		; error - no RTC
   357                              <1> %endif ; AT_RTC_AUTODETECT
   358                              <1> 	push	ax
   359                              <1> 	mov	al,cmos_control_a
   360                              <1> 	call	rtc_read		; read control A register
   361                              <1> 	test	al,cmos_uip
   362                              <1> 	jz	.1			; no update in progess
   363                              <1> 	stc
   364                              <1> 	pop	ax
   365                              <1> 	jmp	int_1A_exitf
   366                              <1> .1:
   367                              <1> 	mov	al,cmos_date
   368                              <1> 	call	rtc_read		; read date
   369                              <1> 	mov	dl,al
   370                              <1> 	mov	al,cmos_month
   371                              <1> 	call	rtc_read		; read month
   372                              <1> 	mov	dh,al
   373                              <1> 	mov	al,cmos_year
   374                              <1> 	call	rtc_read		; read year
   375                              <1> 	mov	cl,al
   376                              <1> 	mov	al,cmos_century
   377                              <1> 	call	rtc_read		; read century
   378                              <1> 	mov	ch,al
   379                              <1> 	clc
   380                              <1> 	pop	ax
   381                              <1> 	jmp	int_1A_exitf
   382                              <1> 
   383                              <1> ;=========================================================================
   384                              <1> ; int_1A_fn05 - Set date in real time clock
   385                              <1> ; Input:
   386                              <1> ;	AH = 05h - function 05h - set RTC date
   387                              <1> ;	CH = BCD century
   388                              <1> ;	CL = BCD year
   389                              <1> ;	DH = BCD month
   390                              <1> ;	DL = BCD date
   391                              <1> ; Output:
   392                              <1> ;	None
   393                              <1> ;-------------------------------------------------------------------------
   394                              <1> int_1A_fn05:
   395                              <1> %ifdef AT_RTC_AUTODETECT
   396                              <1> 	call	rtc_detect		; check that RTC is present
   397                              <1> 	jc	int_1A_exitf		; error - no RTC
   398                              <1> %endif ; AT_RTC_AUTODETECT
   399                              <1> 	push	ax
   400                              <1> 	mov	al,cmos_control_b
   401                              <1> 	call	rtc_read		; read control B register
   402                              <1> 	mov	ah,al
   403                              <1> 	or	ah,cmos_set		; set the RTC set bit
   404                              <1> 	mov	al,cmos_control_b
   405                              <1> 	call	rtc_write		; write control B register
   406                              <1> 
   407                              <1> 	mov	al,cmos_date
   408                              <1> 	mov	ah,dl
   409                              <1> 	call	rtc_write		; write date
   410                              <1> 
   411                              <1> 	mov	al,cmos_month
   412                              <1> 	mov	ah,dh
   413                              <1> 	call	rtc_write		; write month
   414                              <1> 	mov	al,cmos_year
   415                              <1> 	mov	ah,cl
   416                              <1> 	call	rtc_write		; write year
   417                              <1> 	mov	al,cmos_century
   418                              <1> 	mov	ah,ch
   419                              <1> 	call	rtc_write		; write centry
   420                              <1> 
   421                              <1> 	mov	al,cmos_control_b
   422                              <1> 	call	rtc_read		; read control B register
   423                              <1> 	mov	ah,al
   424                              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   425                              <1> 	mov	al,cmos_control_b
   426                              <1> 	call	rtc_write		; write control B register
   427                              <1> 	pop	ax
   428                              <1> 	jmp	int_1A_exit
   429                              <1> 
   430                              <1> ;=========================================================================
   431                              <1> ; int_1A_fn06 - Set real time clock alarm
   432                              <1> ; Input:
   433                              <1> ;	AH = 06h - function 06h - set RTC alarm time
   434                              <1> ;	CH = BCD hours
   435                              <1> ;	CL = BCD minutes
   436                              <1> ;	DH = BCD seconds
   437                              <1> ; Output:
   438                              <1> ;	CF = 1 - alarm already set
   439                              <1> ;-------------------------------------------------------------------------
   440                              <1> int_1A_fn06:
   441                              <1> %ifdef AT_RTC_AUTODETECT
   442                              <1> 	call	rtc_detect		; check that RTC is present
   443                              <1> 	jc	int_1A_exitf		; error - no RTC
   444                              <1> %endif ; AT_RTC_AUTODETECT
   445                              <1> 	push	ax
   446                              <1> 	mov	al,cmos_control_b
   447                              <1> 	call	rtc_read		; read control B register
   448                              <1> 	test	al,cmos_aie
   449                              <1> 	jz	.1			; RTC alarm interrupt is not enabled
   450                              <1> 	stc
   451                              <1> 	pop	ax
   452                              <1> 	jmp	int_1A_exitf
   453                              <1> .1:
   454                              <1> 	mov	ah,al
   455                              <1> 	or	ah,cmos_set		; set the RTC set bit
   456                              <1> 	mov	al,cmos_control_b
   457                              <1> 	call	rtc_write		; write control B register
   458                              <1> 
   459                              <1> 	mov	al,cmos_alarm_secs
   460                              <1> 	mov	ah,dh
   461                              <1> 	call	rtc_write		; write alarm seconds
   462                              <1> 	mov	al,cmos_alarm_mins
   463                              <1> 	mov	ah,cl
   464                              <1> 	call	rtc_write		; write alarm minutes
   465                              <1> 	mov	al,cmos_alarm_hrs
   466                              <1> 	mov	ah,ch
   467                              <1> 	call	rtc_write		; write alarm hours
   468                              <1> 
   469                              <1> 	mov	al,cmos_control_b
   470                              <1> 	call	rtc_read		; read control B register
   471                              <1> 	mov	ah,al
   472                              <1> 	and	ah,~cmos_set		; set the RTC set bit
   473                              <1> 	mov	al,cmos_control_b
   474                              <1> 	call	rtc_write		; write control B register
   475                              <1> 
   476                              <1> 	mov	al,cmos_control_b
   477                              <1> 	call	rtc_read		; read control B register
   478                              <1> 	mov	ah,al
   479                              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
   480                              <1> 	mov	al,cmos_control_b
   481                              <1> 	call	rtc_write		; write control B register with AIE set
   482                              <1> 
   483                              <1> 	pop	ax
   484                              <1> 	clc
   485                              <1> 	jmp	int_1A_exitf
   486                              <1> 
   487                              <1> ;=========================================================================
   488                              <1> ; int_1A_fn07 - Reset real time clock alarm
   489                              <1> ; Input:
   490                              <1> ;	AH = 07h - function 07h - set RTC time
   491                              <1> ; Output:
   492                              <1> ;	None
   493                              <1> ;-------------------------------------------------------------------------
   494                              <1> int_1A_fn07:
   495                              <1> %ifdef AT_RTC_AUTODETECT
   496                              <1> 	call	rtc_detect		; check that RTC is present
   497                              <1> 	jc	int_1A_exitf		; error - no RTC
   498                              <1> %endif ; AT_RTC_AUTODETECT
   499                              <1> 	push	ax
   500                              <1> 
   501                              <1> 	mov	al,cmos_control_b
   502                              <1> 	call	rtc_read		; read control B register
   503                              <1> 	mov	ah,al
   504                              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
   505                              <1> 	mov	al,cmos_control_b
   506                              <1> 	call	rtc_write		; write control B reg. with AIE cleared
   507                              <1> 
   508                              <1> 	pop	ax
   509                              <1> 	jmp	int_1A_exit
   510                              <1> 	
   511                              <1> %ifdef SECOND_PIC
   512                              <1> ;=========================================================================
   513                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
   514                              <1> ; Notes:
   515                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
   516                              <1> ;-------------------------------------------------------------------------
   517                              <1> int_70:
   518                              <1> 	push	ax
   519                              <1> 	mov	al,20h
   520                              <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
   521                              <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
   522                              <1> 	mov	al,cmos_control_c
   523                              <1> 	call	rtc_read		; read control C register
   524                              <1> 	test	al,cmos_af		; check for alarm flag
   525                              <1> 	jz	.1
   526                              <1> 	int	4Ah			; call INT 4Ah
   527                              <1> .1:
   528                              <1> 	pop	ax
   529                              <1> 	iret
   530                              <1> %endif ; SECOND_PIC
   531                              <1> 
   532                              <1> %endif ; AT_RTC
   191                                  %include	"floppy1.inc"		; floppy services
   192                              <1> ;=========================================================================
   193                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
   194                              <1> ;       INT 13h, function AH=01h
   195                              <1> ;       INT 13h, function AH=08h
   196                              <1> ;       INT 13h, function AH=15h
   197                              <1> ;       INT 13h, function AH=16h
   198                              <1> ;       INT 13h, function AH=17h
   199                              <1> ;       INT 13h, function AH=18h
   200                              <1> ;       INT 13h, function AH=08h
   201                              <1> ;	- see floppy2.inc for other INT 13h functions
   202                              <1> ;-------------------------------------------------------------------------
   203                              <1> ;
   204                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   205                              <1> ;
   206                              <1> ; Copyright (C) 2010 - 2020 Sergey Kiselev.
   207                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   208                              <1> ;
   209                              <1> ; This program is free software: you can redistribute it and/or modify
   210                              <1> ; it under the terms of the GNU General Public License as published by
   211                              <1> ; the Free Software Foundation, either version 3 of the License, or
   212                              <1> ; (at your option) any later version.
   213                              <1> ;
   214                              <1> ; This program is distributed in the hope that it will be useful,
   215                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   216                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   217                              <1> ; GNU General Public License for more details.
   218                              <1> ;
   219                              <1> ; You should have received a copy of the GNU General Public License
   220                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   221                              <1> ;
   222                              <1> ;=========================================================================
   223                              <1> 
   224                              <1> ;-------------------------------------------------------------------------
   225                              <1> ; FDC registers
   226                              <1> 
   227                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
   228                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
   229                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
   230                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
   231                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
   232                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
   233                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
   234                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
   235                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
   236                              <1> 
   237                              <1> ;-------------------------------------------------------------------------
   238                              <1> ; DMAC registers
   239                              <1> 
   240                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
   241                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
   242                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
   243                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
   244                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
   245                              <1> 					; first / last flip-flop
   246                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
   247                              <1> 
   248                              <1> ;-------------------------------------------------------------------------
   249                              <1> ; Floppy disk services - error codes
   250                              <1> 
   251                              <1> fdc_e_success	equ	00h		; successful completion
   252                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
   253                              <1> fdc_e_address	equ	02h		; address mark not found
   254                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
   255                              <1> fdc_e_notfound	equ	04h		; sector not found
   256                              <1> fdc_e_changed	equ	06h		; disk changed
   257                              <1> fdc_e_dma	equ	08h		; DMA overrun
   258                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
   259                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
   260                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
   261                              <1> fdc_e_failure	equ	20h		; controller failure
   262                              <1> fdc_e_seek	equ	40h		; seek failed
   263                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
   264                              <1> 
   265                              <1> ;-------------------------------------------------------------------------
   266                              <1> ; Drive media state for fdc_media_state
   267                              <1> 
   268                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
   269                              <1> 					; 00b = 500 Kbit/sec
   270                              <1> 					; 01b = 300 Kbit/sec
   271                              <1> 					; 10b = 250 Kbit/sec
   272                              <1> 					; 11b = 1 Mbit/sec
   273                              <1> fdc_m_double_step	equ	20h	; bit 5:    1 = double stepping required
   274                              <1> fdc_m_established	equ	10h	; bit 4:    1 = media/drive established
   275                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
   276                              <1> 					; 000b = trying 360K in 360K drive
   277                              <1> 					; 001b = trying 360K in 1.2M drive
   278                              <1> 					; 010b = trying 1.2M in 1.2M drive
   279                              <1> 					; 011b = known 360K in 360K drive
   280                              <1> 					; 100b = known 360K in 1.2M drive
   281                              <1> 					; 101b = known 1.2M in 1.2M drive
   282                              <1> 					; 110b = not used
   283                              <1> 					; 111b = 720K in 720K or 1.44M in 1.44M
   284                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
   285                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
   286                              <1> fdc_m_try_360in1200	equ	61h	; 300 Kbps, not established, 360K in 1.2
   287                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
   288                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
   289                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
   290                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
   291                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
   292                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
   293                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
   294                              <1> 
   295                              <1> ;-------------------------------------------------------------------------
   296                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
   297                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
   298                              <1> 
   299                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
   300                              <1> 
   301                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
   302                              <1> ;	       unset for read or verify
   303                              <1> 
   304                              <1> fdc_write_flag	equ	80h		; write or format operation
   305                              <1> 
   306                              <1> ;-------------------------------------------------------------------------
   307                              <1> ; floppy drive type definitions for floppy type byte - cmos_floppy
   308                              <1> 
   309                              <1> cmos_no_floppy	equ	00h
   310                              <1> cmos_360	equ	01h
   311                              <1> cmos_1200	equ	02h
   312                              <1> cmos_720	equ	03h
   313                              <1> cmos_1440	equ	04h
   314                              <1> cmos_2880	equ	06h
   315                              <1> 
   316                              <1> ;=========================================================================
   317                              <1> ; int_13_fn01 - Get status of last operation
   318                              <1> ; Input:
   319                              <1> ;	AH = 01h
   320                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
   321                              <1> ; Output:
   322                              <1> ;	CF clear if last operation was successful
   323                              <1> ;		AH = 00h - successful completion
   324                              <1> ;	CF set on error
   325                              <1> ;		AH - error code of the last operation
   326                              <1> ; Note:
   327                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
   328                              <1> ;	normally will call this functions if bit 7 of DL is not set
   329                              <1> ;-------------------------------------------------------------------------
   330                              <1> int_13_fn01:
   331 000007B2 8A264100            <1> 	mov	ah,byte [fdc_last_error]
   332 000007B6 08E4                <1> 	or	ah,ah
   333 000007B8 7401                <1> 	jz	.no_error
   334 000007BA F9                  <1> 	stc
   335                              <1> .no_error:
   336 000007BB E91865              <1> 	jmp	int_13_exit
   337                              <1> 
   338                              <1> ;=========================================================================
   339                              <1> ; int_13_fn08: Get drive parameters
   340                              <1> ; Input:
   341                              <1> ;	AH = 08h
   342                              <1> ;	DL = drive number (0 - 7Fh)
   343                              <1> ; Output:
   344                              <1> ;	CF clear if successful
   345                              <1> ;		AX = 0000h
   346                              <1> ;		BH = 00h
   347                              <1> ;		BL = CMOS drive type
   348                              <1> ;		CH = maximal cylinder number - 1
   349                              <1> ;		CL = maximal sector number
   350                              <1> ;		DH = maximal head number
   351                              <1> ;		DL = number of drives
   352                              <1> ;		ES:DI -> diskette parameter table
   353                              <1> ;	CF set on error
   354                              <1> ;		AH = 01h - drive number is greater than 7Fh
   355                              <1> ; Notes:
   356                              <1> ;	- If non-existent drive number is specified, function returns zeros in
   357                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
   358                              <1> ;	- If media type is not established function sets media parameters 
   359                              <1> ;	based on CMOS drive type
   360                              <1> ;-------------------------------------------------------------------------
   361                              <1> int_13_fn08:
   362 000007BE 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
   363 000007C1 7603E99F00          <1> 	ja	.invalid_drive		; hard drive number specified
   364 000007C6 A01000              <1> 	mov	al,byte [equipment_list]
   365 000007C9 2441                <1> 	and	al,equip_floppies|equip_floppy2
   366 000007CB B402                <1> 	mov	ah,2			; assume two floppy drives
   367 000007CD 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
   368 000007CF 7406                <1> 	je	.check_drive_number
   369 000007D1 FECC                <1> 	dec	ah			; assume one floppy drive
   370 000007D3 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
   371 000007D5 757C                <1> 	jne	.no_drives
   372                              <1> 
   373                              <1> .check_drive_number:
   374 000007D7 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
   375 000007DA 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
   376                              <1> 					; than number of disks?
   377 000007DC 7379                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
   378 000007DE E8B805              <1> 	call	read_cmos_type		; returns drive type in AL
   379 000007E1 7274                <1> 	jc	.non_existent_drive	; return no drive if CMOS error
   380                              <1> 
   381 000007E3 C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
   382 000007E7 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass CMOS data type to caller
   383 000007EA 8CC9                <1> 	mov	cx,cs
   384 000007EC 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
   385                              <1> 
   386 000007EE 3C01                <1> 	cmp	al,cmos_360
   387 000007F0 7417                <1> 	je	.set_360
   388 000007F2 3C03                <1> 	cmp	al,cmos_720
   389 000007F4 741E                <1> 	je	.set_720
   390 000007F6 3C02                <1> 	cmp	al,cmos_1200
   391 000007F8 7425                <1> 	je	.set_1200
   392 000007FA 3C04                <1> 	cmp	al,cmos_1440
   393 000007FC 742C                <1> 	je	.set_1440
   394                              <1> 
   395                              <1> .set_2880:
   396 000007FE B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
   397 00000800 8D3E[B06F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
   398 00000804 B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
   399 00000807 EB2A                <1> 	jmp	.set_media_type
   400                              <1> 
   401                              <1> .set_360:
   402 00000809 B093                <1> 	mov	al,fdc_m_360in360
   403 0000080B 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
   404 0000080F B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
   405 00000812 EB1F                <1> 	jmp	.set_media_type
   406                              <1> 
   407                              <1> .set_720:
   408 00000814 B097                <1> 	mov	al,fdc_m_720
   409 00000816 8D3E[896F]          <1> 	lea	di,[media_720]
   410 0000081A B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
   411 0000081D EB14                <1> 	jmp	.set_media_type
   412                              <1> 
   413                              <1> .set_1200:
   414 0000081F B002                <1> 	mov	al,fdc_m_try_1200in1200
   415 00000821 8D3E[7C6F]          <1> 	lea	di,[media_1200]
   416 00000825 B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
   417 00000828 EB09                <1> 	jmp	.set_media_type
   418                              <1> 
   419                              <1> .set_1440:
   420 0000082A B007                <1> 	mov	al,fdc_m_try_1440
   421 0000082C 8D3E[966F]          <1> 	lea	di,[media_1440]
   422 00000830 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
   423                              <1> 
   424                              <1> .set_media_type:
   425 00000833 BB9000              <1> 	mov	bx,fdc_media_state
   426 00000836 00D3                <1> 	add	bl,dl			; BX -> drive media state
   427 00000838 F60710              <1> 	test	byte [bx],fdc_m_established ; media type established?
   428 0000083B 7502                <1> 	jnz	.set_parameters		; no need to update if established
   429 0000083D 8807                <1> 	mov	[bx],al
   430                              <1> 
   431                              <1> .set_parameters:
   432 0000083F 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
   433 00000841 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
   434 00000844 A24100              <1> 	mov	byte [fdc_last_error],al
   435 00000847 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
   436 0000084A 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
   437 0000084D 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
   438 00000850 E98364              <1> 	jmp	int_13_exit
   439                              <1> 
   440                              <1> .no_drives:
   441 00000853 C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
   442                              <1> 
   443                              <1> .non_existent_drive:
   444 00000857 31C9                <1> 	xor	cx,cx
   445 00000859 31FF                <1> 	xor	di,di
   446 0000085B 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; CMOS drive type is zero
   447 0000085E 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
   448 00000861 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
   449 00000863 EBDA                <1> 	jmp	.set_parameters
   450                              <1> 
   451                              <1> .invalid_drive:
   452 00000865 B401                <1> 	mov	ah,fdc_e_invalid
   453 00000867 F9                  <1> 	stc
   454 00000868 E96B64              <1> 	jmp	int_13_exit
   455                              <1> 
   456                              <1> ;=========================================================================
   457                              <1> ; int_13_fn15: Get disk type
   458                              <1> ; Input:
   459                              <1> ;	AH = 15h
   460                              <1> ;	DL = drive number (0 or 1)
   461                              <1> ; Output:
   462                              <1> ;	AH = type code:
   463                              <1> ;		00h - no such drive (invalid drive specified)
   464                              <1> ;		01h - floppy without change-line support
   465                              <1> ;		02h - floppy with change-line support
   466                              <1> ;-------------------------------------------------------------------------
   467                              <1> int_13_fn15:
   468 0000086B B400                <1> 	mov	ah,00h			; assume no drive
   469 0000086D 80FA01              <1> 	cmp	dl,1
   470 00000870 7711                <1> 	ja	.exit			; jump if invalid drive number
   471 00000872 E82405              <1> 	call	read_cmos_type		; returns drive type in AL
   472 00000875 720C                <1> 	jc	.exit			; jump if CMOS disk type is invalid
   473 00000877 B401                <1> 	mov	ah,01h			; assume no change-line support
   474 00000879 3C01                <1> 	cmp	al,cmos_360
   475 0000087B 7406                <1> 	je	.exit
   476 0000087D 3C03                <1> 	cmp	al,cmos_720		; no change-line support on 720K drives?
   477 0000087F 7402                <1> 	je	.exit
   478 00000881 B402                <1> 	mov	ah,02h			; otherwise it supports change-line
   479                              <1> 
   480                              <1> .exit:
   481 00000883 F8                  <1> 	clc
   482 00000884 C606410000          <1> 	mov	byte [fdc_last_error],0
   483 00000889 E94A64              <1> 	jmp	int_13_exit
   484                              <1> 
   485                              <1> ;=========================================================================
   486                              <1> ; int_13_fn16 - Detect disk change
   487                              <1> ; Input:
   488                              <1> ;	AH = 16h
   489                              <1> ;	DL = drive number (0 or 1)
   490                              <1> ; Output:
   491                              <1> ;	CF clear if change line inactive
   492                              <1> ;		AH = 00h - disk not changed
   493                              <1> ;	CF set if change line active or error
   494                              <1> ;		AH = 01h - invalid drive number
   495                              <1> ;		AH = 06h - disk changed or change line not supported
   496                              <1> ;		AH = 80h - timeout / device not ready
   497                              <1> ;-------------------------------------------------------------------------
   498                              <1> int_13_fn16:
   499 0000088C 80FA01              <1> 	cmp	dl,1
   500 0000088F 7741                <1> 	ja	.invalid_drive
   501 00000891 E80505              <1> 	call	read_cmos_type		; returns drive type in AL
   502 00000894 723C                <1> 	jc	.invalid_drive
   503                              <1> 
   504 00000896 3C01                <1> 	cmp	al,cmos_360
   505 00000898 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
   506 0000089A 3C03                <1> 	cmp	al,cmos_720
   507 0000089C 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
   508                              <1> 
   509 0000089E E86302              <1> 	call	fdc_motor_on		; turn motor on
   510 000008A1 30E4                <1> 	xor	ah,ah			; assume disk not changed
   511 000008A3 BAF703              <1> 	mov	dx,fdc_dir_reg
   512 000008A6 EC                  <1> 	in	al,dx			; read disk change line
   513 000008A7 D0E0                <1> 	shl	al,1			; bit 7 to CF
   514 000008A9 7303                <1> 	jnc	.exit
   515 000008AB B406                <1> 	mov	ah,fdc_e_changed
   516 000008AD F9                  <1> 	stc
   517                              <1> 
   518                              <1> .exit:
   519 000008AE 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
   520 000008B2 9C                  <1> 	pushf
   521 000008B3 1E                  <1> 	push	ds
   522 000008B4 31F6                <1> 	xor	si,si
   523 000008B6 8EDE                <1> 	mov	ds,si
   524 000008B8 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   525 000008BC 8A4C02              <1> 	mov	cl,byte [si+2]
   526 000008BF 1F                  <1> 	pop	ds
   527 000008C0 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
   528 000008C4 9D                  <1> 	popf
   529 000008C5 E90E64              <1> 	jmp	int_13_exit
   530                              <1> 
   531                              <1> 
   532                              <1> .no_change_line:
   533 000008C8 B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
   534 000008CA F9                  <1> 	stc
   535 000008CB 88264100            <1> 	mov	byte [fdc_last_error],ah
   536 000008CF E90464              <1> 	jmp	int_13_exit
   537                              <1> 
   538                              <1> .invalid_drive:
   539 000008D2 B401                <1> 	mov	ah,fdc_e_invalid
   540 000008D4 F9                  <1> 	stc
   541 000008D5 E9FE63              <1> 	jmp	int_13_exit
   542                              <1> 
   543                              <1> ;=========================================================================
   544                              <1> ; int_13_fn17 - Set disk type for format
   545                              <1> ; Input:
   546                              <1> ;	AH = 17h
   547                              <1> ;	AL = format type
   548                              <1> ;		01h - 320K / 360K disk in 360K drive
   549                              <1> ;		02h - 320K / 360K disk in 1.2M drive
   550                              <1> ;		03h - 1.2M disk in 1.2M drive
   551                              <1> ;		04h - 720K disk in 720K or 1.2M drive
   552                              <1> ;	DL = drive number (0 or 1)
   553                              <1> ; Output:
   554                              <1> ;	CF clear if successful
   555                              <1> ;		AH = 00h - successful completion
   556                              <1> ;	CF set on error
   557                              <1> ;		AH = 01h - invalid drive number
   558                              <1> ;		AH = 06h - disk changed
   559                              <1> ;		AH = 80h - timeout / device not ready
   560                              <1> ;-------------------------------------------------------------------------
   561                              <1> int_13_fn17:
   562 000008D8 80FA01              <1> 	cmp	dl,1
   563 000008DB 7762                <1> 	ja	.invalid_parameters
   564 000008DD E8B904              <1> 	call	read_cmos_type		; get drive type in AL
   565 000008E0 725D                <1> 	jc	.invalid_parameters
   566 000008E2 8A4E0E              <1> 	mov	cl,[bp+int_13_al]	; get original AL value to CL
   567 000008E5 80F900              <1> 	cmp	cl,0			; validate parameters
   568 000008E8 7455                <1> 	je	.invalid_parameters
   569 000008EA 80F904              <1> 	cmp	cl,4
   570 000008ED 7750                <1> 	ja	.invalid_parameters
   571 000008EF BB9000              <1> 	mov	bx,fdc_media_state
   572 000008F2 00D3                <1> 	add	bl,dl			; BX -> drive media state
   573 000008F4 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
   574 000008F7 7507                <1> 	jne	.not_360in360
   575 000008F9 C60793              <1> 	mov	byte [bx],fdc_m_360in360
   576 000008FC B400                <1> 	mov	ah,0			; no error
   577 000008FE EB33                <1> 	jmp	.exit_check_error
   578                              <1> 
   579                              <1> .not_360in360:
   580 00000900 E80102              <1> 	call	fdc_motor_on
   581 00000903 89DE                <1> 	mov	si,bx
   582 00000905 E8B602              <1> 	call	fdc_disk_change		; check if disk (SI) changed
   583 00000908 80FC06              <1> 	cmp	ah,fdc_e_changed
   584 0000090B 760F                <1> 	jbe	.set_type		; no errors other than "disk changed"
   585 0000090D 80FC80              <1> 	cmp	ah,fdc_e_timeout
   586 00000910 750A                <1> 	jne	.set_type		; floppy disk is installed
   587 00000912 803F97              <1> 	cmp	byte [bx],fdc_m_720	; 250 Kbps and not 5.25?
   588 00000915 741C                <1> 	je	.exit_check_error
   589 00000917 C60761              <1> 	mov	byte [bx],fdc_m_try_360in1200 ; 300 Kpbs, try 360 in 1.2M
   590 0000091A EB17                <1> 	jmp	.exit_check_error
   591                              <1> 
   592                              <1> .set_type:
   593 0000091C 80F904              <1> 	cmp	cl,4			; 720K in 720K?
   594 0000091F 7505                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
   595 00000921 C60797              <1> 	mov	byte [bx],fdc_m_720
   596 00000924 EB0D                <1> 	jmp	.exit_check_error
   597                              <1> 
   598                              <1> .check_360in1200:
   599 00000926 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
   600 00000929 7505                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
   601 0000092B C60774              <1> 	mov	byte [bx],fdc_m_360in1200
   602 0000092E EB03                <1> 	jmp	.exit_check_error
   603                              <1> 
   604                              <1> .set_1200in1200:
   605 00000930 C60715              <1> 	mov	byte [bx],fdc_m_1200in1200 ; 1.2M in 1.2M
   606                              <1> 
   607                              <1> .exit_check_error:
   608 00000933 88264100            <1> 	mov	byte [fdc_last_error],ah
   609 00000937 08E4                <1> 	or	ah,ah
   610 00000939 7401                <1> 	jz	.exit			; jump if no error
   611 0000093B F9                  <1> 	stc				; indicate error
   612                              <1> 
   613                              <1> .exit:
   614 0000093C E97663              <1> 	jmp	int_13_upd_exit
   615                              <1> 
   616                              <1> .invalid_parameters:
   617 0000093F B401                <1> 	mov	ah,fdc_e_invalid
   618 00000941 EBF9                <1> 	jmp	.exit
   619                              <1> 
   620                              <1> ;=========================================================================
   621                              <1> ; int_13_fn18 - Set media type for format
   622                              <1> ; Input:
   623                              <1> ;	AH = 18h
   624                              <1> ;	DL = drive number (0 or 1)
   625                              <1> ;	CH = number of cylinders - 1
   626                              <1> ;	CL = sectors per track
   627                              <1> ; Output:
   628                              <1> ;	CF = clear if successful
   629                              <1> ;		AH = 00h - requested format is supported
   630                              <1> ;		ES:DI -> diskette parameter table
   631                              <1> ;	CF = set on error
   632                              <1> ;		AH = 01h - invalid drive number specified
   633                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
   634                              <1> ;-------------------------------------------------------------------------
   635                              <1> int_13_fn18:
   636 00000943 80FA01              <1> 	cmp	dl,1
   637 00000946 7603E99900          <1> 	ja	.invalid_drive
   638 0000094B E84B04              <1> 	call	read_cmos_type		; get drive type in AL
   639 0000094E 7303E99500          <1> 	jc	.unsupported_format	; jump if CMOS drive type invalid
   640                              <1> 
   641 00000953 BB9000              <1> 	mov	bx,fdc_media_state
   642 00000956 00D3                <1> 	add	bl,dl			; BX -> drive media state
   643                              <1> 
   644 00000958 3C01                <1> 	cmp	al,cmos_360		; 360K drive?
   645 0000095A 7511                <1> 	jne	.try_drive_1200
   646 0000095C 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
   647 00000960 7403E98300          <1> 	jnz	.unsupported_format
   648 00000965 B093                <1> 	mov	al,fdc_m_360in360	; 360K in 360K established, 250 Kbps
   649 00000967 8D3E[6F6F]          <1> 	lea	di,[media_360_in_360]
   650 0000096B EB54                <1> 	jmp	.set_media
   651                              <1> 
   652                              <1> .try_drive_1200:
   653 0000096D 3C02                <1> 	cmp	al,cmos_1200		; 1.2M drive?
   654 0000096F 751C                <1> 	jne	.try_drive_2880
   655 00000971 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
   656 00000975 7508                <1> 	jne	.try_media_360_in_1200
   657 00000977 B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M established, 500Kbps
   658 00000979 8D3E[7C6F]          <1> 	lea	di,[media_1200]		; 1.2M
   659 0000097D EB42                <1> 	jmp	.set_media
   660                              <1> 
   661                              <1> .try_media_360_in_1200:
   662 0000097F 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
   663 00000983 7563                <1> 	jne	.unsupported_format
   664 00000985 B074                <1> 	mov	al,fdc_m_360in1200	; 360K in 1.2M established, 300Kbps
   665 00000987 8D3E[A36F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
   666 0000098B EB34                <1> 	jmp	.set_media
   667                              <1> 
   668                              <1> .try_drive_2880:
   669 0000098D 3C06                <1> 	cmp	al,cmos_2880		; 2.88M drive?
   670 0000098F 750E                <1> 	jne	.try_drive_1440
   671 00000991 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
   672 00000995 750C                <1> 	jne	.try_media_1440
   673 00000997 B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
   674 00000999 8D3E[B06F]          <1> 	lea	di,[media_2880]
   675 0000099D EB22                <1> 	jmp	.set_media
   676                              <1> 
   677                              <1> .try_drive_1440:
   678 0000099F 3C04                <1> 	cmp	al,cmos_1440		; 1.44M drive?
   679 000009A1 750E                <1> 	jne	.try_drive_720
   680                              <1> 
   681                              <1> .try_media_1440:
   682 000009A3 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
   683 000009A7 750C                <1> 	jne	.try_media_720
   684 000009A9 B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
   685 000009AB 8D3E[966F]          <1> 	lea	di,[media_1440]
   686 000009AF EB10                <1> 	jmp	.set_media
   687                              <1> 
   688                              <1> .try_drive_720:
   689 000009B1 3C03                <1> 	cmp	al,cmos_720		; 720K drive?
   690 000009B3 7533                <1> 	jne	.unsupported_format	; should never happen...
   691                              <1> 
   692                              <1> .try_media_720:	
   693 000009B5 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
   694 000009B9 752D                <1> 	jne	.unsupported_format
   695 000009BB B097                <1> 	mov	al,fdc_m_720		; other established, 250Kbps
   696 000009BD 8D3E[896F]          <1> 	lea	di,[media_720]		; 720K
   697                              <1> 
   698                              <1> .set_media:
   699 000009C1 8807                <1> 	mov	byte [bx],al		; set physical media
   700 000009C3 E8CC04              <1> 	call	fdc_set_rate		; transfer rate in AL
   701 000009C6 D0C8                <1> 	ror	al,1			; move rate from bits 1,0 to 7,6
   702 000009C8 D0C8                <1> 	ror	al,1
   703 000009CA 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear rate bits
   704 000009CF 08068B00            <1> 	or	byte [fdc_last_rate],al	; store new rate
   705 000009D3 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
   706 000009D6 8CC9                <1> 	mov	cx,cs
   707 000009D8 8EC1                <1> 	mov	es,cx			; return parameters table - segment
   708 000009DA C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
   709 000009DF 30E4                <1> 	xor	ah,ah
   710 000009E1 E9D162              <1> 	jmp	int_13_upd_exit
   711                              <1> 
   712                              <1> .invalid_drive:
   713 000009E4 B401                <1> 	mov	ah,fdc_e_invalid	; invalid function or parameter
   714 000009E6 EB02                <1> 	jmp	.error
   715                              <1> 
   716                              <1> .unsupported_format:
   717 000009E8 B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
   718                              <1> 
   719                              <1> .error:
   720 000009EA F9                  <1> 	stc
   721 000009EB E9C762              <1> 	jmp	int_13_upd_exit
   722                              <1> 
   723                              <1> ;=========================================================================
   724                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
   725                              <1> ; Input:
   726                              <1> ;	DL = drive number (0 or 1)
   727                              <1> ; Output:
   728                              <1> ;	CF clear if successful
   729                              <1> ;		AH = 00h - successful completion
   730                              <1> ;	CF set on error
   731                              <1> ;		AH = 20h - controller failure
   732                              <1> ;		AH = 20h - timeout
   733                              <1> ;	AH trashed
   734                              <1> ;-------------------------------------------------------------------------
   735                              <1> fdc_recalibrate:
   736 000009EE 56                  <1> 	push	si
   737 000009EF 51                  <1> 	push	cx
   738 000009F0 52                  <1> 	push	dx
   739 000009F1 B007                <1> 	mov	al,07h			; FDC Recalibrate command
   740 000009F3 88D4                <1> 	mov	ah,dl			; drive number
   741 000009F5 B102                <1> 	mov	cl,2			; 2 bytes command
   742 000009F7 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
   743 000009FC E86B02              <1> 	call	fdc_send_cmd
   744 000009FF 7244                <1> 	jc	recal_end		; failure
   745 00000A01 E89904              <1> 	call	fdc_wait_irq		; wait for IRQ6
   746 00000A04 723F                <1> 	jc	recal_end		; timeout waiting for interrupt
   747 00000A06 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   748 00000A08 B101                <1> 	mov	cl,1			; 1 byte command
   749 00000A0A E85D02              <1> 	call	fdc_send_cmd
   750 00000A0D 7236                <1> 	jc	recal_end		; failure
   751 00000A0F B90200              <1> 	mov	cx,2			; 2 bytes result
   752 00000A12 E8BA02              <1> 	call	fdc_get_result		; store result
   753 00000A15 722E                <1> 	jc	recal_end		; failure
   754 00000A17 BB4200              <1> 	mov	bx,fdc_ctrl_status
   755 00000A1A B440                <1> 	mov	ah,fdc_e_seek
   756 00000A1C 8A17                <1> 	mov	dl,[bx]			; ST0
   757 00000A1E 80E260              <1> 	and	dl,60h
   758 00000A21 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
   759 00000A24 F9                  <1> 	stc				; indicate error
   760 00000A25 741E                <1> 	je	recal_end		; failure
   761 00000A27 5A                  <1> 	pop	dx
   762 00000A28 52                  <1> 	push	dx
   763 00000A29 30F6                <1> 	xor	dh,dh				 
   764 00000A2B BB9400              <1> 	mov	bx,fdc_cylinder
   765 00000A2E 01D3                <1> 	add	bx,dx
   766 00000A30 C60700              <1> 	mov	byte [bx],0		; current cylinder = 0
   767 00000A33 88D1                <1> 	mov	cl,dl
   768 00000A35 B201                <1> 	mov	dl,1
   769 00000A37 D2E2                <1> 	shl	dl,cl
   770 00000A39 08163E00            <1> 	or	byte [fdc_calib_state],dl ; drive recalibrated
   771 00000A3D B94300              <1> 	mov	cx,43h
   772 00000A40 E840FD              <1> 	call	delay_15us		; 1 ms delay
   773 00000A43 30E4                <1> 	xor	ah,ah
   774                              <1> 
   775                              <1> recal_end:
   776 00000A45 88264100            <1> 	mov	byte [fdc_last_error],ah
   777 00000A49 5A                  <1> 	pop	dx
   778 00000A4A 59                  <1> 	pop	cx
   779 00000A4B 5E                  <1> 	pop	si
   780 00000A4C C3                  <1> 	ret
   781                              <1> 
   782                              <1> ;=========================================================================
   783                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
   784                              <1> ; Input:
   785                              <1> ;	DL = drive number
   786                              <1> ;	DH = head number
   787                              <1> ;	CH = cylinder
   788                              <1> ; Output:
   789                              <1> ;	CF clear if successful
   790                              <1> ;		AH = 00h - successful completion
   791                              <1> ;	CF set on error
   792                              <1> ;		AH = 20h - controller failure
   793                              <1> ;		AH = 40h - seek failed
   794                              <1> ;		AH = 80h - timeout / device not ready
   795                              <1> ;-------------------------------------------------------------------------
   796                              <1> fdc_seek:
   797 00000A4D 53                  <1> 	push	bx
   798 00000A4E 51                  <1> 	push	cx
   799 00000A4F 8A263E00            <1> 	mov	ah,byte [fdc_calib_state]
   800 00000A53 88D1                <1> 	mov	cl,dl
   801 00000A55 FEC1                <1> 	inc	cl
   802 00000A57 D2EC                <1> 	shr	ah,cl
   803 00000A59 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
   804 00000A5B E890FF              <1> 	call	fdc_recalibrate
   805 00000A5E 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
   806 00000A60 E88BFF              <1> 	call	fdc_recalibrate		; try recalibrating again
   807 00000A63 727F                <1> 	jc	.exit			; no luck...
   808                              <1> 
   809                              <1> .skip_recalibrate:
   810 00000A65 B700                <1> 	mov	bh,00h
   811 00000A67 88D3                <1> 	mov	bl,dl			; BX = drive number
   812 00000A69 F687900020          <1> 	test	byte [fdc_media_state+bx],fdc_m_double_step ; check double
   813                              <1> 					; steppig bit
   814 00000A6E 7402                <1> 	jz	.no_double_stepping
   815 00000A70 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
   816                              <1> 
   817                              <1> .no_double_stepping:
   818 00000A72 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch	; already at right cylinder?
   819 00000A76 750B                <1> 	jne	.do_seek		; jump if seek is required
   820 00000A78 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
   821 00000A7D 7404                <1> 	je	.do_seek		; jump if it was a seek error
   822 00000A7F 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
   823 00000A81 EB61                <1> 	jmp	.exit
   824                              <1> 
   825                              <1> .do_seek:
   826 00000A83 88E8                <1> 	mov	al,ch			; cylinder
   827 00000A85 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
   828 00000A87 B00F                <1> 	mov	al,0Fh			; FDC Seek command
   829 00000A89 88F4                <1> 	mov	ah,dh			; head
   830 00000A8B D0E4                <1> 	shl	ah,1
   831 00000A8D D0E4                <1> 	shl	ah,1
   832 00000A8F 08D4                <1> 	or	ah,dl			; seek - byte 1 (head / drive)
   833 00000A91 B103                <1> 	mov	cl,3			; 3 bytes command
   834 00000A93 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
   835 00000A98 E8CF01              <1> 	call	fdc_send_cmd
   836 00000A9B 7243                <1> 	jc	.set_result		; seek error
   837 00000A9D E8FD03              <1> 	call	fdc_wait_irq		; wait for IRQ6
   838 00000AA0 723E                <1> 	jc	.set_result		; timeout waiting for interrupt
   839                              <1> 
   840 00000AA2 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   841 00000AA4 B101                <1> 	mov	cl,1			; 1 byte command
   842 00000AA6 E8C101              <1> 	call	fdc_send_cmd
   843 00000AA9 7235                <1> 	jc	.set_result		; failure
   844 00000AAB B102                <1> 	mov	cl,2
   845 00000AAD 53                  <1> 	push	bx
   846 00000AAE E81E02              <1> 	call	fdc_get_result		; read result bytes
   847 00000AB1 5B                  <1> 	pop	bx
   848 00000AB2 722C                <1> 	jc	.set_result		; error
   849 00000AB4 B440                <1> 	mov	ah,fdc_e_seek
   850 00000AB6 A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
   851 00000AB9 2460                <1> 	and	al,60h
   852 00000ABB 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
   853 00000ABD F9                  <1> 	stc
   854 00000ABE 7420                <1> 	je	.set_result		; seek error
   855 00000AC0 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch	; save new cylinder number
   856                              <1> 
   857 00000AC4 1E                  <1> 	push	ds
   858 00000AC5 31F6                <1> 	xor	si,si
   859 00000AC7 8EDE                <1> 	mov	ds,si
   860 00000AC9 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   861 00000ACD 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
   862 00000AD0 1F                  <1> 	pop	ds
   863                              <1> 
   864 00000AD1 08C0                <1> 	or	al,al			; head settle time is zero?!
   865 00000AD3 7412                <1> 	jz	.get_settle_time
   866                              <1> 
   867 00000AD5 B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
   868 00000AD7 F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
   869 00000AD9 89C1                <1> 	mov	cx,ax
   870                              <1> 
   871                              <1> .wait:
   872 00000ADB E8A5FC              <1> 	call	delay_15us
   873                              <1> 
   874                              <1> .wait_end:
   875 00000ADE 30E4                <1> 	xor	ah,ah
   876                              <1> 
   877                              <1> .set_result:
   878 00000AE0 88264100            <1> 	mov	byte [fdc_last_error],ah
   879                              <1> 
   880                              <1> .exit:
   881 00000AE4 59                  <1> 	pop	cx
   882 00000AE5 5B                  <1> 	pop	bx
   883 00000AE6 C3                  <1> 	ret
   884                              <1> 
   885                              <1> .get_settle_time:
   886 00000AE7 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; check operation type
   887 00000AEC 74F0                <1> 	jz	.wait_end		; jump if read / verify - no wait
   888                              <1> 	
   889 00000AEE 8AA79000            <1> 	mov	ah,byte [fdc_media_state+bx]	; AH = media state
   890 00000AF2 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
   891 00000AF5 B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
   892 00000AF8 74E1                <1> 	jz	.wait			; jump if 360K, media not established
   893 00000AFA 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
   894 00000AFD 74DC                <1> 	je	.wait			; jump if 360K, media established
   895 00000AFF B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
   896 00000B02 EBD7                <1> 	jmp	.wait
   897                              <1> 
   898                              <1> ;=========================================================================
   899                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
   900                              <1> ; Input:
   901                              <1> ;	DL = drive number (0 or 1)
   902                              <1> ; Output:
   903                              <1> ;	none
   904                              <1> ;-------------------------------------------------------------------------
   905                              <1> fdc_motor_on:
   906 00000B04 50                  <1> 	push	ax
   907 00000B05 51                  <1> 	push	cx
   908 00000B06 52                  <1> 	push	dx
   909 00000B07 FA                  <1> 	cli				; entering critical section
   910 00000B08 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
   911 00000B0D 80263F00CF          <1> 	and	byte [fdc_motor_state],0CFh ; zero drive select bits (5-4)
   912 00000B12 88D1                <1> 	mov	cl,dl			; CL = drive number
   913 00000B14 D0E2                <1> 	shl	dl,1
   914 00000B16 D0E2                <1> 	shl	dl,1
   915 00000B18 D0E2                <1> 	shl	dl,1
   916 00000B1A D0E2                <1> 	shl	dl,1
   917 00000B1C 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; select new drive
   918 00000B20 FEC1                <1> 	inc	cl
   919 00000B22 8A163F00            <1> 	mov	dl,byte [fdc_motor_state]
   920 00000B26 D2EA                <1> 	shr	dl,cl
   921 00000B28 7255                <1> 	jc	.already_on
   922 00000B2A B201                <1> 	mov	dl,1
   923 00000B2C FEC9                <1> 	dec	cl
   924 00000B2E D2E2                <1> 	shl	dl,cl
   925 00000B30 08163F00            <1> 	or	byte [fdc_motor_state],dl   ; indicate that motor is on
   926 00000B34 FB                  <1> 	sti				; end of critical section
   927 00000B35 A03F00              <1>     	mov	al,byte [fdc_motor_state]
   928 00000B38 D0C8                <1> 	ror	al,1
   929 00000B3A D0C8                <1> 	ror	al,1
   930 00000B3C D0C8                <1> 	ror	al,1
   931 00000B3E D0C8                <1> 	ror	al,1
   932 00000B40 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
   933 00000B42 BAF203              <1> 	mov	dx,fdc_dor_reg
   934 00000B45 EE                  <1> 	out	dx,al			; send it to FDC - start motor
   935 00000B46 B8FD90              <1> 	mov	ax,90FDh
   936 00000B49 CD15                <1> 	int	15h			; call OS hook
   937 00000B4B 722E                <1> 	jc	.exit
   938 00000B4D 1E                  <1> 	push	ds
   939 00000B4E 56                  <1> 	push	si
   940 00000B4F 31F6                <1> 	xor	si,si
   941 00000B51 8EDE                <1> 	mov	ds,si
   942 00000B53 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   943 00000B57 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
   944 00000B5A 5E                  <1> 	pop	si
   945 00000B5B 1F                  <1> 	pop	ds
   946                              <1> 
   947 00000B5C F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag
   948 00000B61 7408                <1> 	jz	.read_verify		; jump if not write operation
   949 00000B63 3C08                <1> 	cmp	al,8
   950 00000B65 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
   951 00000B67 B008                <1> 	mov	al,8			; wait at least 1 second for write
   952 00000B69 EB06                <1> 	jmp	.wait_loop
   953                              <1> 
   954                              <1> .read_verify:
   955 00000B6B 3C05                <1> 	cmp	al,5
   956 00000B6D 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
   957 00000B6F B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
   958                              <1> 
   959                              <1> .wait_loop:
   960 00000B71 B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
   961 00000B74 E80CFC              <1> 	call	delay_15us		; wait 125 ms
   962 00000B77 FEC8                <1> 	dec	al
   963 00000B79 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
   964                              <1> 
   965                              <1> .exit:
   966 00000B7B 59                  <1> 	pop	cx
   967 00000B7C 5A                  <1> 	pop	dx
   968 00000B7D 58                  <1> 	pop	ax
   969 00000B7E C3                  <1> 	ret
   970                              <1> 
   971                              <1> .already_on:
   972 00000B7F FB                  <1> 	sti
   973 00000B80 A03F00              <1> 	mov	al,byte [fdc_motor_state]	; start motor
   974 00000B83 D0C8                <1> 	ror	al,1
   975 00000B85 D0C8                <1> 	ror	al,1
   976 00000B87 D0C8                <1> 	ror	al,1
   977 00000B89 D0C8                <1> 	ror	al,1
   978 00000B8B 0C0C                <1> 	or	al,0Ch			; DMA and IRQ enabled, no reset
   979 00000B8D BAF203              <1> 	mov	dx,fdc_dor_reg
   980 00000B90 EE                  <1> 	out	dx,al			; send it to FDC - start motor
   981 00000B91 EBE8                <1> 	jmp	.exit
   982                              <1> 
   983                              <1> ;=========================================================================
   984                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
   985                              <1> ; Input:
   986                              <1> ;	CH = cylinder
   987                              <1> ;	DH = head
   988                              <1> ; Output:
   989                              <1> ;	BL = next sector to be transferred
   990                              <1> ;-------------------------------------------------------------------------	
   991                              <1> 
   992                              <1> fdc_end_io:
   993 00000B93 50                  <1> 	push	ax
   994 00000B94 1E                  <1> 	push	ds
   995 00000B95 31DB                <1> 	xor	bx,bx
   996 00000B97 8EDB                <1> 	mov	ds,bx
   997 00000B99 C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
   998 00000B9D 8A6702              <1> 	mov	ah,[bx+2]		; motor timeout (ticks)
   999 00000BA0 8A4704              <1> 	mov	al,[bx+4]		; sectors per track
  1000 00000BA3 FEC0                <1> 	inc	al
  1001 00000BA5 1F                  <1> 	pop	ds
  1002 00000BA6 BB4200              <1> 	mov	bx,fdc_ctrl_status
  1003 00000BA9 3A6F03              <1> 	cmp	ch,[bx+3]		; same result cylinder?
  1004 00000BAC 7508                <1> 	jne	.exit
  1005 00000BAE 3A7704              <1> 	cmp	dh,[bx+4]		; same result head?
  1006 00000BB1 7503                <1> 	jne	.exit
  1007 00000BB3 8A4705              <1> 	mov	al,[bx+5]		; result sector number
  1008                              <1> .exit:
  1009 00000BB6 88264000            <1> 	mov	byte [fdc_motor_tout],ah ; motor timeout
  1010 00000BBA 88C3                <1> 	mov	bl,al			; next sector to be transferred
  1011 00000BBC 58                  <1> 	pop	ax
  1012 00000BBD C3                  <1> 	ret
  1013                              <1> 
  1014                              <1> ;========================================================================
  1015                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  1016                              <1> ; Input:
  1017                              <1> ;	AL = CMOS drive type
  1018                              <1> ;	DS:SI = drive media type
  1019                              <1> ; Output:
  1020                              <1> ;	CF clear if disk not changed
  1021                              <1> ;		AH = 00h - disk not changed
  1022                              <1> ;	CF set if disk changed or on error
  1023                              <1> ;		AH = 06h - disk changed
  1024                              <1> ;		AH = error code
  1025                              <1> ;		AL - trashed
  1026                              <1> ; Note:
  1027                              <1> ;	Motor needs to be turned on before calling this function
  1028                              <1> ;------------------------------------------------------------------------
  1029                              <1> fdc_disk_change:
  1030 00000BBE 51                  <1> 	push	cx
  1031 00000BBF 88C4                <1> 	mov	ah,al			; save AL value in AH
  1032 00000BC1 3C01                <1> 	cmp	al,cmos_360
  1033 00000BC3 743E                <1> 	je	.not_changed		; jump if 360K drive (no change line)
  1034 00000BC5 3C03                <1> 	cmp	al,cmos_720
  1035 00000BC7 743A                <1> 	je	.not_changed		; jump if 720K drive (no change line)
  1036 00000BC9 8A04                <1> 	mov	al,[si]			; media type
  1037 00000BCB 2407                <1> 	and	al,fdc_m_state_bits
  1038 00000BCD 7434                <1> 	jz	.not_changed		; jump if 360K drive (no change line)
  1039 00000BCF 3C03                <1> 	cmp	al,3
  1040 00000BD1 7430                <1> 	je	.not_changed		; jump if 360K dirve (no change line)
  1041 00000BD3 BAF703              <1> 	mov	dx,fdc_dir_reg
  1042 00000BD6 EC                  <1> 	in	al,dx			; read disk change line
  1043 00000BD7 D0E0                <1> 	shl	al,1
  1044 00000BD9 7328                <1> 	jnc	.not_changed		; no disk change
  1045 00000BDB 8024EF              <1> 	and	byte [si],0EFH		; media not detected
  1046 00000BDE E81761              <1> 	call	fdc_init		; full initialization
  1047 00000BE1 7224                <1> 	jc	.exit
  1048 00000BE3 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  1049 00000BE6 B501                <1> 	mov	ch,1
  1050 00000BE8 E862FE              <1> 	call	fdc_seek		; seek to cylinder 1
  1051 00000BEB 721A                <1> 	jc	.exit
  1052 00000BED B500                <1> 	mov	ch,0
  1053 00000BEF E85BFE              <1> 	call	fdc_seek		; seek to cylinder 0
  1054 00000BF2 7213                <1> 	jc	.exit
  1055 00000BF4 B406                <1> 	mov	ah,fdc_e_changed
  1056 00000BF6 BAF703              <1> 	mov	dx,fdc_dir_reg
  1057 00000BF9 EC                  <1> 	in	al,dx			; read disk change line
  1058 00000BFA D0E0                <1> 	shl	al,1
  1059 00000BFC 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  1060 00000BFE B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  1061                              <1> 
  1062                              <1> .changed_or_error:
  1063 00000C00 F9                  <1> 	stc
  1064 00000C01 EB04                <1> 	jmp	.exit
  1065                              <1> 
  1066                              <1> .not_changed:
  1067 00000C03 88E0                <1> 	mov	al,ah			; restore AL
  1068 00000C05 B400                <1> 	mov	ah,0			; AH = 00h - disk not changed
  1069                              <1> 
  1070                              <1> .exit:
  1071 00000C07 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  1072 00000C0A 59                  <1> 	pop	cx
  1073 00000C0B C3                  <1> 	ret
  1074                              <1> 
  1075                              <1> ;=========================================================================
  1076                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  1077                              <1> ; Input:
  1078                              <1> ;	AL = DMA mode byte
  1079                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  1080                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  1081                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  1082                              <1> ;	CX = byte count (minus 1)
  1083                              <1> ;	ES:BX -> buffer address for DMA operation
  1084                              <1> ; Output:
  1085                              <1> ;	CF clear on success
  1086                              <1> ;	CF set if error
  1087                              <1> ;		AH = 08h - DMA overrun
  1088                              <1> ;	AX,BX trashed
  1089                              <1> ; Note:
  1090                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  1091                              <1> ;-------------------------------------------------------------------------
  1092                              <1> fdc_configure_dma:
  1093 00000C0C 52                  <1> 	push	dx
  1094 00000C0D 8CC2                <1> 	mov	dx,es			; user's buffer segment
  1095 00000C0F D1C2                <1> 	rol	dx,1
  1096 00000C11 D1C2                <1> 	rol	dx,1
  1097 00000C13 D1C2                <1> 	rol	dx,1
  1098 00000C15 D1C2                <1> 	rol	dx,1
  1099 00000C17 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  1100 00000C19 80E40F              <1> 	and	ah,0Fh			; AL = page number: bits 19 - 16 of ES
  1101 00000C1C 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  1102 00000C1F 01DA                <1> 	add	dx,bx			; add user's buffer offset
  1103 00000C21 80D400              <1> 	adc	ah,0			; increment page number on overflow
  1104                              <1> 
  1105 00000C24 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  1106 00000C26 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  1107 00000C28 723C                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  1108                              <1> 
  1109 00000C2A FA                  <1> 	cli
  1110 00000C2B E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  1111 00000C2D EB00                <1> 	jmp	$+2
  1112 00000C2F EB00                <1> 	jmp	$+2
  1113 00000C31 E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  1114 00000C33 EB00                <1> 	jmp	$+2
  1115 00000C35 EB00                <1> 	jmp	$+2
  1116 00000C37 88C8                <1> 	mov	al,cl
  1117 00000C39 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  1118 00000C3B EB00                <1> 	jmp	$+2
  1119 00000C3D EB00                <1> 	jmp	$+2
  1120 00000C3F 88E8                <1> 	mov	al,ch
  1121 00000C41 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  1122 00000C43 EB00                <1> 	jmp	$+2
  1123 00000C45 EB00                <1> 	jmp	$+2
  1124 00000C47 88D0                <1> 	mov	al,dl
  1125 00000C49 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  1126 00000C4B EB00                <1> 	jmp	$+2
  1127 00000C4D EB00                <1> 	jmp	$+2
  1128 00000C4F 88F0                <1> 	mov	al,dh
  1129 00000C51 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  1130 00000C53 EB00                <1> 	jmp	$+2
  1131 00000C55 EB00                <1> 	jmp	$+2
  1132 00000C57 88E0                <1> 	mov	al,ah
  1133 00000C59 E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  1134 00000C5B EB00                <1> 	jmp	$+2
  1135 00000C5D EB00                <1> 	jmp	$+2
  1136 00000C5F B002                <1> 	mov	al,2
  1137 00000C61 E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  1138 00000C63 FB                  <1> 	sti
  1139                              <1> 
  1140                              <1> .exit:
  1141 00000C64 5A                  <1> 	pop	dx
  1142 00000C65 C3                  <1> 	ret
  1143                              <1> 
  1144                              <1> .dma_boundary:				; Note: CF is already set
  1145 00000C66 B409                <1> 	mov	ah,fdc_e_boundary
  1146 00000C68 EBFA                <1> 	jmp	.exit
  1147                              <1> 
  1148                              <1> ;=========================================================================
  1149                              <1> ; fdc_send_cmd - Send a command to FDC
  1150                              <1> ; Input:
  1151                              <1> ;	AL = 1st byte of the command
  1152                              <1> ;	AH = 2nd byte of the command
  1153                              <1> ;	SI = 3rd and 4th bytes of the command
  1154                              <1> ;	DI = 5th and 6th bytes of the command
  1155                              <1> ;	BL = 7th byte of the command
  1156                              <1> ;	BH = 8th byte of the command
  1157                              <1> ;	CH = 9th byte of the command
  1158                              <1> ;	CL = command length (number of bytes)
  1159                              <1> ; Output:
  1160                              <1> ;	CF clear if successful
  1161                              <1> ;		AH = 00h - successful completion
  1162                              <1> ;	CF set on error
  1163                              <1> ;		AH = 20h - controller failure
  1164                              <1> ;		AH = 80h - timeout / device not ready
  1165                              <1> ;	AX trashed
  1166                              <1> ;-------------------------------------------------------------------------
  1167                              <1> fdc_send_cmd:
  1168 00000C6A E84900              <1> 	call	fdc_write		; send AL (1st byte)
  1169 00000C6D FEC9                <1> 	dec	cl
  1170 00000C6F 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1171 00000C71 88E0                <1> 	mov	al,ah
  1172 00000C73 E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  1173 00000C76 FEC9                <1> 	dec	cl
  1174 00000C78 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1175 00000C7A 89F0                <1> 	mov	ax,si
  1176 00000C7C E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  1177 00000C7F FEC9                <1> 	dec	cl
  1178 00000C81 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1179 00000C83 88E0                <1> 	mov	al,ah
  1180 00000C85 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  1181 00000C88 FEC9                <1> 	dec	cl
  1182 00000C8A 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1183 00000C8C 89F8                <1> 	mov	ax,di
  1184 00000C8E E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  1185 00000C91 FEC9                <1> 	dec	cl
  1186 00000C93 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1187 00000C95 88E0                <1> 	mov	al,ah
  1188 00000C97 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  1189 00000C9A FEC9                <1> 	dec	cl
  1190 00000C9C 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1191 00000C9E 88D8                <1> 	mov	al,bl
  1192 00000CA0 E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  1193 00000CA3 FEC9                <1> 	dec	cl
  1194 00000CA5 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1195 00000CA7 88F8                <1> 	mov	al,bh
  1196 00000CA9 E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  1197 00000CAC FEC9                <1> 	dec	cl
  1198 00000CAE 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1199 00000CB0 88E8                <1> 	mov	al,ch
  1200 00000CB2 E80100              <1> 	call	fdc_write		; send CH (9th byte)
  1201                              <1> 
  1202                              <1> .send_cmd_exit:
  1203 00000CB5 C3                  <1> 	ret
  1204                              <1> 
  1205                              <1> ;=========================================================================
  1206                              <1> ; fdc_write - Send byte to FDC
  1207                              <1> ; Input:
  1208                              <1> ;	AL = byte to send
  1209                              <1> ; Output:
  1210                              <1> ;	CF clear if successful
  1211                              <1> ;	CF set if timeout
  1212                              <1> ;		AH = 80h - timeout / device not ready
  1213                              <1> ;-------------------------------------------------------------------------
  1214                              <1> fdc_write:
  1215 00000CB6 52                  <1> 	push	dx
  1216 00000CB7 50                  <1> 	push	ax
  1217 00000CB8 E80802              <1> 	call	fdc_wait_ready
  1218 00000CBB 720D                <1> 	jc	.timeout
  1219 00000CBD 24E0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma
  1220 00000CBF 3C80                <1> 	cmp	al,fdc_stat_ready
  1221 00000CC1 7507                <1> 	jne	.timeout
  1222 00000CC3 58                  <1> 	pop	ax
  1223 00000CC4 BAF503              <1> 	mov	dx,fdc_data_reg
  1224 00000CC7 EE                  <1> 	out	dx,al			; write byte
  1225                              <1> 
  1226                              <1> .exit:
  1227 00000CC8 5A                  <1> 	pop	dx
  1228 00000CC9 C3                  <1> 	ret
  1229                              <1> 
  1230                              <1> .timeout:
  1231 00000CCA 58                  <1> 	pop	ax
  1232 00000CCB B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  1233 00000CCD EBF9                <1> 	jmp	.exit
  1234                              <1> 
  1235                              <1> ;=========================================================================
  1236                              <1> ; fdc_get_result - Read FDC result
  1237                              <1> ; Input:
  1238                              <1> ;	CL = number of result bytes
  1239                              <1> ; Output:
  1240                              <1> ;	CF clear if successful
  1241                              <1> ;		AH = 00h - operation successful
  1242                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  1243                              <1> ;	CF set on error
  1244                              <1> ;		AH = 20h - controller failure
  1245                              <1> ;		AH = 80h - timeout / device not ready
  1246                              <1> ;	AL,BX - trashed
  1247                              <1> ;-------------------------------------------------------------------------
  1248                              <1> fdc_get_result:
  1249 00000CCF 52                  <1> 	push	dx
  1250 00000CD0 BB4200              <1> 	mov	bx,fdc_ctrl_status
  1251                              <1> 
  1252                              <1> .next_byte:
  1253 00000CD3 E8ED01              <1> 	call	fdc_wait_ready
  1254 00000CD6 7222                <1> 	jc	.timeout
  1255 00000CD8 24F0                <1> 	and	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  1256 00000CDA 88C4                <1> 	mov	ah,al
  1257 00000CDC 80E4EF              <1> 	and	ah,~fdc_stat_busy
  1258 00000CDF 80FC80              <1> 	cmp	ah,fdc_stat_ready	; controller finished sending result?
  1259 00000CE2 7412                <1> 	je	.done			; jump if finished
  1260 00000CE4 3CD0                <1> 	cmp	al,fdc_stat_ready|fdc_stat_dir|fdc_stat_busy
  1261 00000CE6 7516                <1> 	jne	.failure		; jump on invalid controller status
  1262 00000CE8 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  1263 00000CEB 7311                <1> 	jnb	.failure		; controller error if so
  1264 00000CED BAF503              <1> 	mov	dx,fdc_data_reg
  1265 00000CF0 EC                  <1> 	in	al,dx
  1266 00000CF1 8807                <1> 	mov	byte [bx],al
  1267 00000CF3 43                  <1> 	inc	bx
  1268 00000CF4 EBDD                <1> 	jmp	.next_byte
  1269                              <1> 
  1270                              <1> .done:
  1271 00000CF6 30E4                <1> 	xor	ah,ah			; operation successful
  1272                              <1> 
  1273                              <1> .exit:
  1274 00000CF8 5A                  <1> 	pop	dx
  1275 00000CF9 C3                  <1> 	ret
  1276                              <1> 
  1277                              <1> .timeout:
  1278 00000CFA B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  1279 00000CFC EBFA                <1> 	jmp	.exit
  1280                              <1> 
  1281                              <1> .failure:
  1282 00000CFE B420                <1> 	mov	ah,fdc_e_failure
  1283 00000D00 F9                  <1> 	stc
  1284 00000D01 EBF5                <1> 	jmp	.exit
  1285                              <1> 
  1286                              <1> ;=========================================================================
  1287                              <1> ; fdc_read - Read byte from FDC
  1288                              <1> ; Input:
  1289                              <1> ;	none
  1290                              <1> ; Output:
  1291                              <1> ;	CF clear if successful
  1292                              <1> ;		AL = byte read from FDC
  1293                              <1> ;		AH - unchanged
  1294                              <1> ;	CF set on error
  1295                              <1> ;		AH = 20h - controller failure
  1296                              <1> ;		AH = 80h - timeout / device not ready
  1297                              <1> ;	CX trashed
  1298                              <1> ;-------------------------------------------------------------------------
  1299                              <1> fdc_read:
  1300 00000D03 52                  <1> 	push	dx
  1301 00000D04 BAF403              <1> 	mov	dx,fdc_status_reg
  1302 00000D07 E8B901              <1> 	call	fdc_wait_ready
  1303 00000D0A 720F                <1> 	jc	.timeout
  1304 00000D0C EC                  <1> 	in	al,dx
  1305 00000D0D A840                <1> 	test	al,40h			; FDC is ready to send a byte? 
  1306 00000D0F 740E                <1> 	jz	.failure		; jump if not ready
  1307 00000D11 EB00                <1> 	jmp	$+2			; I/O delay
  1308 00000D13 EB00                <1> 	jmp	$+2
  1309 00000D15 BAF503              <1> 	mov	dx,fdc_data_reg
  1310 00000D18 EC                  <1> 	in	al,dx			; read the byte
  1311                              <1> 
  1312                              <1> .exit:
  1313 00000D19 5A                  <1> 	pop	dx
  1314 00000D1A C3                  <1> 	ret
  1315                              <1> 
  1316                              <1> .timeout:
  1317 00000D1B B480                <1> 	mov	ah,fdc_e_timeout	; Note: CF is already set
  1318 00000D1D EBFA                <1> 	jmp	.exit
  1319                              <1> 
  1320                              <1> .failure:
  1321 00000D1F B420                <1> 	mov	ah,fdc_e_failure
  1322 00000D21 F9                  <1> 	stc
  1323 00000D22 EBF5                <1> 	jmp	.exit
  1324                              <1> 
  1325                              <1> ;=========================================================================
  1326                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  1327                              <1> ; Input:
  1328                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  1329                              <1> ; Output:
  1330                              <1> ;	AH = error code
  1331                              <1> ;-------------------------------------------------------------------------
  1332                              <1> 
  1333                              <1> fdc_get_error:
  1334 00000D24 BB4200              <1> 	mov	bx,fdc_ctrl_status
  1335 00000D27 8B1F                <1> 	mov	bx,[bx]
  1336 00000D29 F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  1337 00000D2C B400                <1> 	mov	ah,fdc_e_success
  1338 00000D2E 7433                <1> 	jz	.exit			; jump if successful completion
  1339 00000D30 F6C340              <1> 	test	bl,40h			; abnormal termination?
  1340 00000D33 B420                <1> 	mov	ah,fdc_e_failure
  1341 00000D35 742C                <1> 	jz	.exit
  1342 00000D37 F6C701              <1> 	test	bh,1			; address mark not found?
  1343 00000D3A B402                <1> 	mov	ah,fdc_e_address
  1344 00000D3C 7525                <1> 	jnz	.exit
  1345 00000D3E F6C702              <1> 	test	bh,2			; disk write protected?
  1346 00000D41 B403                <1> 	mov	ah,fdc_e_wprotect
  1347 00000D43 751E                <1> 	jnz	.exit
  1348 00000D45 F6C704              <1> 	test	bh,4			; sector not found?
  1349 00000D48 B404                <1> 	mov	ah,fdc_e_notfound
  1350 00000D4A 7517                <1> 	jnz	.exit
  1351 00000D4C F6C710              <1> 	test	bh,10H			; DMA overrun?
  1352 00000D4F B408                <1> 	mov	ah,fdc_e_dma
  1353 00000D51 7510                <1> 	jnz	.exit
  1354 00000D53 F6C720              <1> 	test	bh,20H			; CRC error?
  1355 00000D56 B410                <1> 	mov	ah,fdc_e_crc
  1356 00000D58 7509                <1> 	jnz	.exit
  1357 00000D5A F6C780              <1> 	test	bh,80h			; access after last sector?
  1358 00000D5D B404                <1> 	mov	ah,fdc_e_notfound
  1359 00000D5F 7502                <1> 	jnz	.exit
  1360 00000D61 B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  1361                              <1> 
  1362                              <1> .exit:
  1363 00000D63 C3                  <1> 	ret
  1364                              <1> 
  1365                              <1> ;=========================================================================
  1366                              <1> ; fdc_reset - Reset FDC
  1367                              <1> ; Input:
  1368                              <1> ;	none
  1369                              <1> ; Output:
  1370                              <1> ;	Resets FDC flags in BIOS area
  1371                              <1> ;	AX,CX,DX - trashed 
  1372                              <1> ;-------------------------------------------------------------------------
  1373                              <1> 
  1374                              <1> fdc_reset:
  1375 00000D64 FA                  <1> 	cli
  1376 00000D65 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; read/verify operation
  1377 00000D6A 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  1378 00000D6F A03F00              <1> 	mov	al,byte [fdc_motor_state]
  1379 00000D72 D0C0                <1> 	rol	al,1			; after rol:
  1380 00000D74 D0C0                <1> 	rol	al,1			; 	bits 7-4: motor state
  1381 00000D76 D0C0                <1> 	rol	al,1			; 	bit 3: operation type (R/W)
  1382 00000D78 D0C0                <1> 	rol	al,1			;	bits 1-0: drive select
  1383 00000D7A 24FB                <1> 	and	al,0FBh			; clear reserved bit
  1384 00000D7C 0C08                <1> 	or	al,08h			; DMA and IRQ enabled, reset
  1385 00000D7E BAF203              <1> 	mov	dx,fdc_dor_reg
  1386 00000D81 EE                  <1> 	out	dx,al			; send it to FDC
  1387 00000D82 B90300              <1> 	mov	cx,3
  1388 00000D85 E8FBF9              <1> 	call	delay_15us		; 30-45 us delay
  1389 00000D88 0C0C                <1> 	or	al,0Ch
  1390 00000D8A EE                  <1> 	out	dx,al			; DMA and IRQ enabled, no reset
  1391 00000D8B FB                  <1> 	sti
  1392 00000D8C E80E01              <1> 	call	fdc_wait_irq		; wait for IRQ6
  1393 00000D8F 7207                <1> 	jc	.exit
  1394 00000D91 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  1395 00000D96 30E4                <1> 	xor	ah,ah			; no errors
  1396                              <1> .exit:
  1397 00000D98 C3                  <1> 	ret
  1398                              <1> 
  1399                              <1> ;=========================================================================
  1400                              <1> ; read_cmos_type - Read drive type from CMOS
  1401                              <1> ; Input:
  1402                              <1> ;	DL = drive number (0 or 1)
  1403                              <1> ; Output:
  1404                              <1> ;	CF clear if successful
  1405                              <1> ;		AL = drive type
  1406                              <1> ;	CF set on error (invalid drive type)
  1407                              <1> ;=========================================================================
  1408                              <1> 
  1409                              <1> read_cmos_type:
  1410                              <1> %ifdef BIOS_SETUP
  1411                              <1> 	call	get_floppy
  1412                              <1> %else ; BIOS_SETUP
  1413 00000D99 B044                <1> 	mov	al,44h			; FIXME: fake two 1.44MB floppy drives
  1414                              <1> %endif ; BIOS_SETUP
  1415 00000D9B 08D2                <1> 	or	dl,dl			; drive 0?
  1416 00000D9D 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  1417 00000D9F D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  1418 00000DA1 D0E8                <1> 	shr	al,1
  1419 00000DA3 D0E8                <1> 	shr	al,1
  1420 00000DA5 D0E8                <1> 	shr	al,1
  1421                              <1> .drive_1:
  1422 00000DA7 240F                <1> 	and	al,0Fh			; mask drive bits
  1423 00000DA9 3C00                <1> 	cmp	al,cmos_no_floppy
  1424 00000DAB 740A                <1> 	je	.error
  1425 00000DAD 3C05                <1> 	cmp	al,5			; invalid value
  1426 00000DAF 7406                <1> 	je	.error
  1427 00000DB1 3C06                <1> 	cmp	al,cmos_2880
  1428 00000DB3 7702                <1> 	ja	.error
  1429 00000DB5 F8                  <1> 	clc
  1430 00000DB6 C3                  <1> 	ret
  1431                              <1> 
  1432                              <1> .error:
  1433 00000DB7 F9                  <1> 	stc
  1434 00000DB8 C3                  <1> 	ret
  1435                              <1> 
  1436                              <1> ;=========================================================================
  1437                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  1438                              <1> ; Input:
  1439                              <1> ;	AL = CMOS drive type
  1440                              <1> ;	DS:SI = drive media type
  1441                              <1> ; Output:
  1442                              <1> ;	CF clear if successful
  1443                              <1> ;		AH = 00h
  1444                              <1> ;	CF set on error
  1445                              <1> ;		AH = 20h - invalid CMOS
  1446                              <1> ;-------------------------------------------------------------------------
  1447                              <1> fdc_detect_media:
  1448 00000DB9 52                  <1> 	push	dx
  1449 00000DBA 51                  <1> 	push	cx
  1450 00000DBB B400                <1> 	mov	ah,0
  1451                              <1> 
  1452 00000DBD 3C03                <1> 	cmp	al,cmos_720
  1453 00000DBF 7410                <1> 	je	.set_720
  1454 00000DC1 3C02                <1> 	cmp	al,cmos_1200
  1455 00000DC3 7410                <1> 	je	.detect_1200
  1456 00000DC5 3C04                <1> 	cmp	al,cmos_1440
  1457 00000DC7 7422                <1> 	je	.detect_1440
  1458 00000DC9 3C06                <1> 	cmp	al,cmos_2880
  1459 00000DCB 7434                <1> 	je	.detect_2880
  1460                              <1> 	
  1461 00000DCD B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  1462 00000DCF EB4D                <1> 	jmp	.exit_set_media
  1463                              <1> 
  1464                              <1> .set_720:
  1465 00000DD1 B097                <1> 	mov	al,fdc_m_720		; set 720K disk
  1466 00000DD3 EB49                <1> 	jmp	.exit_set_media
  1467                              <1> 
  1468                              <1> .detect_1200:
  1469 00000DD5 B000                <1> 	mov	al,0			; try 500 Kbps
  1470 00000DD7 E85200              <1> 	call	fdc_read_id
  1471 00000DDA B015                <1> 	mov	al,fdc_m_1200in1200
  1472 00000DDC 7340                <1> 	jnc	.exit_set_media		; jump if successful
  1473 00000DDE B040                <1> 	mov	al,40h			; try 300 Kbps
  1474 00000DE0 E84900              <1> 	call	fdc_read_id
  1475 00000DE3 B074                <1> 	mov	al,fdc_m_360in1200
  1476 00000DE5 7337                <1> 	jnc	.exit_set_media		; jump if successful
  1477 00000DE7 B002                <1> 	mov	al,fdc_m_try_1200in1200
  1478 00000DE9 EB33                <1> 	jmp	.exit_set_media
  1479                              <1> 
  1480                              <1> .detect_1440:
  1481 00000DEB B000                <1> 	mov	al,0			; try 500 Kbps
  1482 00000DED E83C00              <1> 	call	fdc_read_id
  1483 00000DF0 B017                <1> 	mov	al,fdc_m_1440
  1484 00000DF2 732A                <1> 	jnc	.exit_set_media		; jump if successful
  1485 00000DF4 B080                <1> 	mov	al,80h			; try 250 Kbps
  1486 00000DF6 E83300              <1> 	call	fdc_read_id
  1487 00000DF9 B097                <1> 	mov	al,fdc_m_720
  1488 00000DFB 7321                <1> 	jnc	.exit_set_media		; jump if successful
  1489 00000DFD B007                <1> 	mov	al,fdc_m_try_1440
  1490 00000DFF EB1D                <1> 	jmp	.exit_set_media
  1491                              <1> 
  1492                              <1> .detect_2880:
  1493 00000E01 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  1494 00000E03 E82600              <1> 	call	fdc_read_id
  1495 00000E06 B0D7                <1> 	mov	al,fdc_m_2880
  1496 00000E08 7314                <1> 	jnc	.exit_set_media		; jump if successful
  1497 00000E0A B000                <1> 	mov	al,0			; try 500 Kbps
  1498 00000E0C E81D00              <1> 	call	fdc_read_id
  1499 00000E0F B017                <1> 	mov	al,fdc_m_1440
  1500 00000E11 730B                <1> 	jnc	.exit_set_media		; jump if successful
  1501 00000E13 B080                <1> 	mov	al,80h			; try 250 Kbps
  1502 00000E15 E81400              <1> 	call	fdc_read_id
  1503 00000E18 B097                <1> 	mov	al,fdc_m_720
  1504 00000E1A 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  1505 00000E1C B0C7                <1> 	mov	al,fdc_m_try_2880
  1506                              <1> 
  1507                              <1> .exit_set_media:
  1508 00000E1E 8804                <1> 	mov	byte [si],al		; set media type
  1509                              <1> 
  1510                              <1> .exit:
  1511 00000E20 88264100            <1> 	mov	byte [fdc_last_error],ah
  1512 00000E24 59                  <1> 	pop	cx
  1513 00000E25 5A                  <1> 	pop	dx
  1514 00000E26 C3                  <1> 	ret
  1515                              <1> 
  1516                              <1> .invalid_cmos:
  1517 00000E27 B420                <1> 	mov	ah,fdc_e_failure
  1518 00000E29 F9                  <1> 	stc
  1519 00000E2A EBF4                <1> 	jmp	.exit
  1520                              <1> 
  1521                              <1> ;=========================================================================
  1522                              <1> ; fdc_read_id - Read ID
  1523                              <1> ; Input:
  1524                              <1> ;	AL = data transfer rate (bits 7-6)
  1525                              <1> ; Output:
  1526                              <1> ;	CF clear if successful
  1527                              <1> ;		AH = 0 - successful completion
  1528                              <1> ;		AL = ID (bits 7-6)
  1529                              <1> ;	CF set on error
  1530                              <1> ;		AH = error code
  1531                              <1> ;-------------------------------------------------------------------------
  1532                              <1> fdc_read_id:
  1533 00000E2C 53                  <1> 	push	bx
  1534 00000E2D C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  1535 00000E32 E85D00              <1> 	call	fdc_set_rate		; transfer rate in AL
  1536 00000E35 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  1537 00000E38 E8B3FB              <1> 	call	fdc_recalibrate		; recalibrate
  1538 00000E3B 7305                <1> 	jnc	.do_read_id
  1539 00000E3D E8AEFB              <1> 	call	fdc_recalibrate		; second attempt
  1540 00000E40 722D                <1> 	jc	.error
  1541                              <1> 
  1542                              <1> .do_read_id:
  1543 00000E42 B90300              <1> 	mov	cx,3			; 3 attempts
  1544                              <1> 
  1545                              <1> .read_id_loop:
  1546 00000E45 51                  <1> 	push	cx
  1547 00000E46 B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  1548 00000E48 88D4                <1> 	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  1549 00000E4A B102                <1> 	mov	cl,2			; 2 byte commands
  1550 00000E4C 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  1551 00000E51 E816FE              <1> 	call	fdc_send_cmd
  1552 00000E54 7218                <1> 	jc	.error_cmd
  1553 00000E56 E84400              <1> 	call	fdc_wait_irq		; wait for IRQ6
  1554 00000E59 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  1555 00000E5B B107                <1> 	mov	cl,7
  1556 00000E5D E86FFE              <1> 	call	fdc_get_result		; read result bytes
  1557 00000E60 720C                <1> 	jc	.error_cmd
  1558 00000E62 E8BFFE              <1> 	call	fdc_get_error		; get error code
  1559 00000E65 59                  <1> 	pop	cx
  1560 00000E66 08E4                <1> 	or	ah,ah
  1561 00000E68 7406                <1> 	jz	.exit			; if no errors
  1562 00000E6A E2D9                <1> 	loop	.read_id_loop		; retry
  1563 00000E6C EB01                <1> 	jmp	.error
  1564                              <1> 
  1565                              <1> .error_cmd:
  1566 00000E6E 59                  <1> 	pop	cx
  1567                              <1> 
  1568                              <1> .error:
  1569 00000E6F F9                  <1> 	stc
  1570                              <1> 
  1571                              <1> .exit:
  1572 00000E70 5B                  <1> 	pop	bx
  1573 00000E71 C3                  <1> 	ret
  1574                              <1> 
  1575                              <1> ;=========================================================================
  1576                              <1> ; fdc_select_rate - Select FDC transfer rate
  1577                              <1> ; Input:
  1578                              <1> ;	DS:SI = drive media type
  1579                              <1> ;	DS:008B = last data rate selected
  1580                              <1> ; Output:
  1581                              <1> ;	AL = data transfer rate (bits 7-6)
  1582                              <1> ;	DS:008B = new data rate selected
  1583                              <1> ;-------------------------------------------------------------------------
  1584                              <1> fdc_select_rate:
  1585 00000E72 8A34                <1> 	mov	dh,byte [si]		; DH - media state
  1586 00000E74 8A168B00            <1> 	mov	dl,byte [fdc_last_rate]	; DL - last selected rate
  1587 00000E78 81E2C0C0            <1> 	and	dx,0C0C0h		; mask rate bits
  1588 00000E7C 38F2                <1> 	cmp	dl,dh			; new rate is the same as the last rate?
  1589 00000E7E 740E                <1> 	je	.exit			; exit if rate is already selected
  1590 00000E80 80268B003F          <1> 	and	byte [fdc_last_rate],3Fh ; clear previous rate bits
  1591 00000E85 08368B00            <1> 	or	byte [fdc_last_rate],dh	; add new bits
  1592 00000E89 88F0                <1> 	mov	al,dh
  1593 00000E8B E80400              <1> 	call	fdc_set_rate		; send new rate (in AL) to FDC
  1594                              <1> 
  1595                              <1> .exit:
  1596 00000E8E 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  1597 00000E91 C3                  <1> 	ret
  1598                              <1> 
  1599                              <1> ;=========================================================================
  1600                              <1> ; fdc_set_rate - Set transfer rate
  1601                              <1> ; Input:
  1602                              <1> ;	AL = transfer rate (bits 7 and 6)
  1603                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  1604                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  1605                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  1606                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  1607                              <1> ; Output:
  1608                              <1> ;	AL = transfer rate (bits 1 and 0)
  1609                              <1> ;		00h - 500 Kbps	01h - 300 Kbps
  1610                              <1> ;		02h - 250 Kbps	03h - 1 Mbps
  1611                              <1> ;	DX = 3F7h - FDC CCR
  1612                              <1> ;-------------------------------------------------------------------------
  1613                              <1> fdc_set_rate:
  1614 00000E92 24C0                <1> 	and	al,fdc_m_rate_bits
  1615 00000E94 D0C0                <1> 	rol	al,1
  1616 00000E96 D0C0                <1> 	rol	al,1
  1617 00000E98 BAF703              <1> 	mov	dx,fdc_ccr_reg
  1618 00000E9B EE                  <1> 	out	dx,al
  1619 00000E9C C3                  <1> 	ret
  1620                              <1> 
  1621                              <1> ;=========================================================================
  1622                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  1623                              <1> ; Input:
  1624                              <1> ;	none
  1625                              <1> ; Output:
  1626                              <1> ;	CF clear if interrupt had occurred
  1627                              <1> ;		AH = 00h - successful completion
  1628                              <1> ;	CF set if no interrupt
  1629                              <1> ;		AH = 80h - timeout
  1630                              <1> ;	BX = fdc_calib_state
  1631                              <1> ;	AL,CX - trashed
  1632                              <1> ;-------------------------------------------------------------------------
  1633                              <1> fdc_wait_irq:
  1634                              <1> 
  1635 00000E9D FB                  <1> 	sti
  1636 00000E9E F8                  <1> 	clc
  1637 00000E9F B80190              <1> 	mov	ax,9001h
  1638 00000EA2 CD15                <1> 	int	15h			; call OS hook
  1639 00000EA4 7212                <1> 	jc	.timeout
  1640 00000EA6 BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  1641 00000EA9 31C9                <1> 	xor	cx,cx
  1642                              <1> 
  1643                              <1> %ifdef AT_DELAY
  1644                              <1> 
  1645                              <1> .zero:
  1646                              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1647                              <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1648                              <1> 
  1649                              <1> .zero_loop:
  1650                              <1> 	in	al,ppi_pb_reg
  1651                              <1> 	test	al,refresh_flag
  1652                              <1> 	jz	.zero_loop		; wait 15.09 us
  1653                              <1> 	loop	.one			; DEC CX; JNZ .one
  1654                              <1> 	jmp	.timeout
  1655                              <1> 
  1656                              <1> .one:
  1657                              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1658                              <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1659                              <1> 
  1660                              <1> .one_loop:
  1661                              <1> 	in	al,ppi_pb_reg
  1662                              <1> 	test	al,refresh_flag
  1663                              <1> 	jnz	.one_loop		; wait 15.09 us
  1664                              <1> 	loop	.zero			; DEC CX; JNZ .one
  1665                              <1> 
  1666                              <1> %else ; AT_DELAY
  1667                              <1> 
  1668                              <1> .1:
  1669 00000EAB F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1670 00000EAE 750C                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1671                              <1> 
  1672                              <1> 	; wait 38.13 us (Intel 8088 CPU running on 4.77 MHz)
  1673 00000EB0 B00A                <1> 	mov	al,10
  1674                              <1> 
  1675                              <1> .2:
  1676 00000EB2 FEC8                <1> 	dec	al
  1677 00000EB4 75FC                <1> 	jnz	.2
  1678 00000EB6 E2F3                <1> 	loop	.1
  1679                              <1> 
  1680                              <1> %endif ; AT_DELAY
  1681                              <1> 
  1682                              <1> .timeout:
  1683 00000EB8 B480                <1> 	mov	ah,fdc_e_timeout
  1684 00000EBA F9                  <1> 	stc
  1685 00000EBB C3                  <1> 	ret
  1686                              <1> 
  1687                              <1> .exit:
  1688 00000EBC 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  1689 00000EBF B400                <1> 	mov	ah,fdc_e_success
  1690 00000EC1 F8                  <1> 	clc				; DEBUG - remove after debug
  1691 00000EC2 C3                  <1> 	ret
  1692                              <1> 
  1693                              <1> ;=========================================================================
  1694                              <1> ; fdc_wait_ready - Wait until FDC is ready to receive or send commands
  1695                              <1> ;		   but no more than one second
  1696                              <1> ; Input:
  1697                              <1> ; Output:
  1698                              <1> ;	CF clear if FDC is ready
  1699                              <1> ;		AL = FDC main status register
  1700                              <1> ;	CF set on timeout
  1701                              <1> ;		AL trashed
  1702                              <1> ;	DX - trashed
  1703                              <1> ;-------------------------------------------------------------------------
  1704                              <1> 
  1705                              <1> fdc_wait_ready:
  1706 00000EC3 51                  <1> 	push	cx
  1707 00000EC4 BAF403              <1> 	mov	dx,fdc_status_reg
  1708 00000EC7 31C9                <1> 	xor	cx,cx
  1709                              <1> 
  1710                              <1> %ifdef AT_DELAY
  1711                              <1> 
  1712                              <1> .zero:
  1713                              <1> 	in	al,dx			; read I/O port
  1714                              <1> 	test	al,fdc_stat_ready
  1715                              <1> 	jnz	.exit			; exit loop if bit(s) set to 1
  1716                              <1> 
  1717                              <1> .zero_loop:
  1718                              <1> 	in	al,ppi_pb_reg
  1719                              <1> 	test	al,refresh_flag
  1720                              <1> 	jz	.zero_loop		; wait 15.09 us
  1721                              <1> 	dec	cx
  1722                              <1> 	jz	.timeout
  1723                              <1> 	in	al,dx			; read I/O port again
  1724                              <1> 	test	al,fdc_stat_ready
  1725                              <1> 	jnz	.exit			; exit loop of bit(s) set to 1
  1726                              <1> 
  1727                              <1> .one_loop:
  1728                              <1> 	in	al,ppi_pb_reg
  1729                              <1> 	test	al,refresh_flag
  1730                              <1> 	jnz	.one_loop		; wait 15.09 us
  1731                              <1> 	loop	.zero
  1732                              <1> 
  1733                              <1> %else ; AT_DELAY
  1734                              <1> 
  1735                              <1> .1:
  1736 00000EC9 EC                  <1> 	in	al,dx			; read I/O port
  1737 00000ECA A880                <1> 	test	al,fdc_stat_ready
  1738 00000ECC 7509                <1> 	jnz	.exit			; exit loop if bit(s) set to 1
  1739                              <1> 
  1740                              <1> 	; wait 38.13 us (Intel 8088 CPU running on 4.77 MHz)
  1741 00000ECE B00A                <1> 	mov	al,10
  1742                              <1> 
  1743                              <1> .2:
  1744 00000ED0 FEC8                <1> 	dec	al
  1745 00000ED2 75FC                <1> 	jnz	.2
  1746 00000ED4 E2F3                <1> 	loop	.1
  1747                              <1> 
  1748                              <1> %endif ; AT_DELAY
  1749                              <1> 
  1750                              <1> .timeout:
  1751 00000ED6 F9                  <1> 	stc
  1752                              <1> 
  1753                              <1> .exit:
  1754 00000ED7 59                  <1> 	pop	cx
  1755 00000ED8 C3                  <1> 	ret
  1756                              <1> ;=========================================================================
  1757                              <1> ; detect_floppy - Detect floppy configuration
  1758                              <1> ;                 set equipment bits accordingly
  1759                              <1> ; Input:
  1760                              <1> ;	none
  1761                              <1> ; Ouput:
  1762                              <1> ;	AL = NVRAM floppy configuration byte
  1763                              <1> ;-------------------------------------------------------------------------
  1764                              <1> detect_floppy:
  1765                              <1> %ifdef BIOS_SETUP
  1766                              <1> 	call	get_floppy
  1767                              <1> %else ; BIOS_SETUP
  1768 00000ED9 B044                <1> 	mov	al,44h			; FIXME: fake two 1.44MB floppy drives
  1769                              <1> %endif ; BIOS_SETUP
  1770 00000EDB 3C00                <1> 	cmp	al,00h			; No floppy drives?
  1771 00000EDD 740E                <1> 	je	.exit
  1772 00000EDF 800E100001          <1> 	or	byte [equipment_list],equip_floppies
  1773 00000EE4 A80F                <1> 	test	al,0Fh			; Second floppy drive installed?
  1774 00000EE6 7405                <1> 	jz	.exit
  1775 00000EE8 800E100040          <1> 	or	byte [equipment_list],equip_floppy2
  1776                              <1> .exit:
  1777 00000EED C3                  <1> 	ret
  1778                              <1> 
  1779                              <1> ;=========================================================================
  1780                              <1> ; print_floppy - Print floppy configuration
  1781                              <1> ; Input:
  1782                              <1> ;	AL = NVRAM floppy configuration byte
  1783                              <1> ; Ouput:
  1784                              <1> ;	none
  1785                              <1> ;-------------------------------------------------------------------------
  1786                              <1> print_floppy:
  1787 00000EEE 50                  <1> 	push	ax
  1788 00000EEF 56                  <1> 	push	si
  1789 00000EF0 BE[C201]            <1> 	mov	si,msg_floppy
  1790 00000EF3 E8B807              <1> 	call	print
  1791 00000EF6 D0C8                <1> 	ror	al,1
  1792 00000EF8 D0C8                <1> 	ror	al,1
  1793 00000EFA D0C8                <1> 	ror	al,1
  1794 00000EFC D0C8                <1> 	ror	al,1
  1795 00000EFE 89C6                <1> 	mov	si,ax
  1796 00000F00 83E607              <1> 	and	si,0007h
  1797 00000F03 D1E6                <1> 	shl	si,1
  1798 00000F05 2E8BB4[7303]        <1>     cs	mov	si,word [tbl_floppy+si]
  1799 00000F0A E8A107              <1> 	call	print
  1800 00000F0D BE[E801]            <1> 	mov	si,msg_floppy_2
  1801 00000F10 E89B07              <1> 	call	print
  1802 00000F13 D0C8                <1> 	ror	al,1
  1803 00000F15 D0C8                <1> 	ror	al,1
  1804 00000F17 D0C8                <1> 	ror	al,1
  1805 00000F19 D0C8                <1> 	ror	al,1
  1806 00000F1B 89C6                <1> 	mov	si,ax
  1807 00000F1D 83E607              <1> 	and	si,0007h
  1808 00000F20 D1E6                <1> 	shl	si,1
  1809 00000F22 2E8BB4[7303]        <1>     cs	mov	si,word [tbl_floppy+si]
  1810 00000F27 E88407              <1> 	call	print
  1811 00000F2A BE[5000]            <1> 	mov	si,msg_crlf
  1812 00000F2D E87E07              <1> 	call	print
  1813 00000F30 5E                  <1> 	pop	si
  1814 00000F31 58                  <1> 	pop	ax
  1815 00000F32 C3                  <1> 	ret
   192                                  %include	"scancode.inc"		; keyboard scancodes translation func.
   193                              <1> ;=========================================================================
   194                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion and related INT 16h functions:
   195                              <1> ; 键盘扫描码到ASCII码的转换和相关INT 16h功能
   196                              <1> ;	INT 16h - BIOS Keyboard Services
   197                              <1> ;		- function AH=00h
   198                              <1> ;		- function AH=01h
   199                              <1> ;		- function AH=10h
   200                              <1> ;		- function AH=11h
   201                              <1> ;-------------------------------------------------------------------------
   202                              <1> ;
   203                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   204                              <1> ;
   205                              <1> ;=========================================================================
   206                              <1> 
   207                              <1> ;=========================================================================
   208                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and BIOS scan code translation table
   209                              <1> ; 	            键盘扫描代码到ASCII和BIOS扫描代码转换表
   210                              <1> ; Note 1: Table starts with scancode == 1 表格以scancode==1开头
   211                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags “Normal”字段的高位字节表示按键标志
   212                              <1> ;	00 - no flags
   213                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
   214                              <1> ;	       键盘数字键，可与Alt一起使用以输入ASCII码
   215                              <1> ;	     x in this case equals digit value 在这种情况下等于数字值
   216                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
   217                              <1> ;	       键受Caps Log或Num Lock的影响（反转Shift操作）
   218                              <1> ;	40 - there is an extended key, so check for 0E0h flag 有一个扩展按键，因此请检查0E0h标志
   219                              <1> ;	8x - F11, F12 BIOS scan codes
   220                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
   221                              <1> ;	   （观察：对于所有其他键，BIOS扫描代码==kbd扫描代码）
   222                              <1> ;-------------------------------------------------------------------------
   223                              <1> 
   224                              <1> scan_xlat_table:
   225                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   226 00000F33 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
   227 00000F3B 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
   228 00000F43 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
   229 00000F4B 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
   230 00000F53 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
   231 00000F5B 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
   232 00000F63 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
   233 00000F6B 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
   234 00000F73 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
   235 00000F7B 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
   236 00000F83 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
   237 00000F8B 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
   238 00000F93 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
   239 00000F9B 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
   240 00000FA3 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
   241 00000FAB 71205110111E001E    <1> 	dw	2071h,	1051h,	1E11h,	1E00h	; q	Q	10h
   242                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   243 00000FB3 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
   244 00000FBB 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
   245 00000FC3 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
   246 00000FCB 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
   247 00000FD3 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
   248 00000FDB 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
   249 00000FE3 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
   250 00000FEB 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
   251 00000FF3 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
   252 00000FFB 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
   253 00001003 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
   254 0000100B 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
   255 00001013 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
   256 0000101B 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
   257 00001023 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
   258 0000102B 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
   259                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   260 00001033 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
   261 0000103B 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
   262 00001043 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
   263 0000104B 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
   264 00001053 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
   265 0000105B 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
   266 00001063 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
   267 0000106B 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
   268 00001073 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
   269 0000107B 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift		2Ah
   270 00001083 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
   271 0000108B 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
   272 00001093 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
   273 0000109B 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
   274 000010A3 7620562F062F002F    <1> 	dw	2076h,	2F56h,	2F06h,	2F00h	; v	V	2Fh
   275 000010AB 6220423006300030    <1> 	dw	2062h,	3042h,	3006h,	3000h	; b	B	30h
   276                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   277 000010B3 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
   278 000010BB 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
   279 000010C3 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
   280 000010CB 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
   281 000010D3 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
   282 000010DB 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
   283 000010E3 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
   284 000010EB 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
   285 000010F3 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
   286 000010FB 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
   287 00001103 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
   288 0000110B 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
   289 00001113 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
   290 0000111B 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
   291 00001123 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
   292 0000112B 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
   293                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   294 00001133 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
   295 0000113B 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
   296 00001143 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
   297 0000114B 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
   298 00001153 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
   299 0000115B 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
   300 00001163 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
   301 0000116B 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
   302 00001173 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
   303 0000117B 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -		4Ah
   304 00001183 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
   305 0000118B F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5		4Ch
   306 00001193 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
   307 0000119B 2B002B4E0000F04E    <1> 	dw	002Bh,	4E2Bh,	0,	4EF0h	; Gray +		4Eh
   308 000011A3 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
   309 000011AB 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
   310                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
   311 000011B3 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
   312 000011BB 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
   313 000011C3 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
   314 000011CB 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
   315 000011D3 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
   316 000011DB 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
   317 000011E3 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
   318 000011EB 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
   319                              <1> .end:
   320                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
   321                              <1> 
   322                              <1> ;=========================================================================
   323                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
   324                              <1> ; Input:
   325                              <1> ;	AL - scan code
   326                              <1> ; Output:
   327                              <1> ;	AX - ASCII character / scan code pair
   328                              <1> ;-------------------------------------------------------------------------
   329                              <1> scan_xlat:
   330 000011F3 53                  <1> 	push	bx
   331 000011F4 FEC8                <1> 	dec	al
   332 000011F6 3C58                <1> 	cmp	al,scan_xlat_table_size
   333 000011F8 7205                <1> 	jb	.1
   334 000011FA 31C0                <1> 	xor	ax,ax
   335 000011FC E9AB00              <1> 	jmp	.exit
   336                              <1> 
   337                              <1> .1:
   338 000011FF B700                <1> 	mov	bh,00h				; calculate offset of the key
   339 00001201 88C3                <1> 	mov	bl,al				; in scan_xlat_table
   340 00001203 D1E3                <1> 	shl	bx,1				; BX = AL * 8
   341 00001205 D1E3                <1> 	shl	bx,1
   342 00001207 D1E3                <1> 	shl	bx,1
   343                              <1> 
   344 00001209 F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
   345 0000120E 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
   346 00001210 2E8B87[390F]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
   347                              <1> 	; check for numeric Keypad keys
   348 00001215 2EF687[340F]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
   349 0000121B 7474                <1> 	jz	.check_extended
   350 0000121D F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   351 00001222 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
   352                              <1> 						; and so it is not a keypad key
   353                              <1> 
   354 00001224 2E8A87[340F]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
   355 00001229 240F                <1> 	and	al,0Fh				; get the numeric value
   356 0000122B 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
   357 0000122F D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
   358 00001231 A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
   359                              <1> 
   360 00001234 31C0                <1> 	xor	ax,ax				; return nothing
   361 00001236 EB72                <1> 	jmp	.exit
   362                              <1> 
   363                              <1> .check_ctrl:
   364 00001238 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
   365 0000123D 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
   366 0000123F 2E8B87[370F]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
   367 00001244 EB4B                <1> 	jmp	.check_extended
   368                              <1> 
   369                              <1> .check_locks:
   370 00001246 2EF687[340F]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
   371 0000124C 741D                <1> 	jz	.check_shift			; not affected by Locks
   372                              <1> 
   373 0000124E 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
   374 00001250 7309                <1> 	jae	.check_num_lock			; above or equal 47h
   375                              <1> 
   376 00001252 F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
   377 00001257 7412                <1> 	jz	.check_shift			; Caps Lock is not active
   378 00001259 EB07                <1> 	jmp	.lock_active
   379                              <1> 
   380                              <1> .check_num_lock:
   381 0000125B F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
   382 00001260 7409                <1> 	jz	.check_shift			; Num Lock is not active
   383                              <1> .lock_active:
   384                              <1> 	; are any of Shift keys active?
   385 00001262 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   386 00001267 7409                <1> 	jz	.shift				; Lock active, Shift inactive
   387 00001269 EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
   388                              <1> 
   389                              <1> .check_shift:
   390                              <1> 	; are any of Shift keys active?
   391 0000126B F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   392 00001270 7407                <1> 	jz	.no_shift
   393                              <1> .shift:
   394 00001272 2E8B87[350F]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
   395 00001277 EB18                <1> 	jmp	.check_extended
   396                              <1> 
   397                              <1> .no_shift:
   398 00001279 88C4                <1> 	mov	ah,al				; Move scan code to AH
   399 0000127B FEC4                <1> 	inc	ah
   400 0000127D 2E8A87[330F]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
   401 00001282 2EF687[340F]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
   402 00001288 7407                <1> 	jz	.check_extended			; not F11 or F12
   403 0000128A 2E8AA7[340F]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
   404 0000128F EB19                <1> 	jmp	.exit
   405                              <1> 
   406                              <1> .check_extended:
   407 00001291 2EF687[340F]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
   408 00001297 7411                <1> 	jz	.exit				; no extended key
   409 00001299 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   410 0000129E 740A                <1> 	jz	.exit				; ... not a 0E0h
   411 000012A0 3C00                <1> 	cmp	al,00h
   412 000012A2 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
   413 000012A4 B0E0                <1> 	mov	al,0E0h				; indicate extended key
   414 000012A6 EB02                <1> 	jmp	.exit
   415                              <1> 
   416                              <1> .ascii_code:
   417 000012A8 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
   418                              <1> 						; key with valid ASCII code
   419                              <1> 						; (Keypad Enter, *, and /)
   420                              <1> 
   421                              <1> .exit:
   422 000012AA 5B                  <1> 	pop	bx
   423 000012AB C3                  <1> 	ret
   424                              <1> 
   425                              <1> ;=========================================================================
   426                              <1> ; int_16_fn00 - get keystroke
   427                              <1> ; Input:
   428                              <1> ;	AH = 00h
   429                              <1> ; Output:
   430                              <1> ;	AH = BIOS scan code
   431                              <1> ;	AL = ASCII character
   432                              <1> ; Notes:
   433                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   434                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   435                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   436                              <1> ;	- Use function AH=10h for extended keystrokes handling
   437                              <1> ;-------------------------------------------------------------------------
   438                              <1> int_16_fn00:
   439 000012AC FB                  <1> 	sti
   440                              <1> .1:
   441 000012AD 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   442 000012B1 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   443 000012B5 74F6                <1> 	jz	.1			; wait or keystroke
   444 000012B7 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   445 000012B9 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   446                              <1> 					;   location
   447 000012BC 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   448 000012C0 7504                <1> 	jne	.2
   449 000012C2 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   450                              <1> .2:
   451 000012C6 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   452 000012CA 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   453                              <1> 					;   extended key?
   454 000012CC 7504                <1> 	jne	.3			; not a convertible key
   455 000012CE B000                <1> 	mov	al,00h			; convert to a standard key
   456 000012D0 EB2C                <1> 	jmp	.exit
   457                              <1> .3:
   458 000012D2 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   459 000012D4 74D7                <1> 	je	.1			; an ignored extended key, get next key
   460 000012D6 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   461                              <1> 					;   (scancode above 84h)
   462 000012D9 77D2                <1> 	ja	.1			; an ignored extended key, get next key
   463 000012DB 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   464 000012DE 751E                <1> 	jne	.exit
   465 000012E0 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   466 000012E2 7504                <1> 	jne	.4
   467 000012E4 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   468 000012E6 EB16                <1> 	jmp	.exit
   469                              <1> .4:
   470 000012E8 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   471 000012EA 7504                <1> 	jne	.5
   472 000012EC B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   473 000012EE EB0E                <1> 	jmp	.exit
   474                              <1> .5:
   475 000012F0 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   476 000012F2 7504                <1> 	jne	.6
   477 000012F4 B435                <1> 	mov	ah,35h			; standard / scancode
   478 000012F6 EB06                <1> 	jmp	.exit
   479                              <1> .6:
   480 000012F8 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   481 000012FA 7502                <1> 	jne	.exit
   482 000012FC B437                <1> 	mov	ah,37h			; standard * scancode
   483                              <1> .exit:
   484 000012FE E96A55              <1> 	jmp	int_16_exit
   485                              <1> 
   486                              <1> ;=========================================================================
   487                              <1> ; int_16_fn01 - check for keystroke
   488                              <1> ; Input:
   489                              <1> ;	AH = 01h
   490                              <1> ; Output:
   491                              <1> ;	ZF = 1 - no keystroke available
   492                              <1> ;	ZF = 0 = keystroke is available and put in AX
   493                              <1> ;		AH = BIOS scan code
   494                              <1> ;		AL = ASCII character
   495                              <1> ; Notes:
   496                              <1> ;	- Does not remove keystroke from keyboard buffer
   497                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   498                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   499                              <1> ;	- Use function AH=11h for extended keystrokes handling
   500                              <1> ;-------------------------------------------------------------------------
   501                              <1> int_16_fn01:
   502 00001301 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   503 00001305 8B07                <1> 	mov	ax,word [bx]
   504 00001307 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   505 0000130B 7436                <1> 	jz	.exit			; no keystroke, exit
   506 0000130D 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   507                              <1> 					;   extended key?
   508 0000130F 7504                <1> 	jne	.1			; not a convertible key
   509 00001311 B000                <1> 	mov	al,00h			; convert to a standard key
   510 00001313 EB2C                <1> 	jmp	.clear_zf
   511                              <1> .1:
   512 00001315 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   513 00001317 742D                <1> 	je	.discard_key		; an ignored extended key, discard
   514 00001319 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   515                              <1> 					;   (scancode above 84h)
   516 0000131C 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
   517 0000131E 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   518 00001321 751E                <1> 	jne	.clear_zf
   519 00001323 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   520 00001325 7504                <1> 	jne	.2
   521 00001327 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   522 00001329 EB16                <1> 	jmp	.clear_zf
   523                              <1> .2:
   524 0000132B 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   525 0000132D 7504                <1> 	jne	.3
   526 0000132F B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   527 00001331 EB0E                <1> 	jmp	.clear_zf
   528                              <1> .3:
   529 00001333 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   530 00001335 7504                <1> 	jne	.4
   531 00001337 B435                <1> 	mov	ah,35h			; standard / scancode
   532 00001339 EB06                <1> 	jmp	.clear_zf
   533                              <1> .4:
   534 0000133B 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   535 0000133D 7502                <1> 	jne	.clear_zf
   536 0000133F B437                <1> 	mov	ah,37h			; standard * scancode
   537                              <1> 
   538                              <1> .clear_zf:
   539 00001341 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   540                              <1> .exit:
   541 00001343 E92855              <1> 	jmp	int_16_exitf
   542                              <1> 
   543                              <1> .discard_key:
   544 00001346 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   545                              <1> 					;   location
   546 00001349 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   547 0000134D 7504                <1> 	jne	.5
   548 0000134F 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   549                              <1> .5:
   550 00001353 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   551 00001357 EBA8                <1> 	jmp	int_16_fn01		; check for the next key
   552                              <1> 	
   553                              <1> 
   554                              <1> ;=========================================================================
   555                              <1> ; int_16_fn10 - get extended keystroke
   556                              <1> ; Input:
   557                              <1> ;	AH = 10h
   558                              <1> ; Output:
   559                              <1> ;	AH = BIOS scan code
   560                              <1> ;	AL = ASCII character
   561                              <1> ; Note:
   562                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   563                              <1> ;-------------------------------------------------------------------------
   564                              <1> int_16_fn10:
   565 00001359 FB                  <1> 	sti
   566                              <1> .1:
   567 0000135A 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   568 0000135E 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   569 00001362 74F6                <1> 	jz	.1			; wait or keystroke
   570 00001364 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   571 00001366 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   572                              <1> 					;   location
   573 00001369 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   574 0000136D 7504                <1> 	jne	.2
   575 0000136F 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   576                              <1> .2:
   577 00001373 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   578 00001377 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   579 00001379 7507                <1> 	jne	.exit			; not an extended key
   580 0000137B 80FC00              <1> 	cmp	ah,00h			; is it Alt + 240 (F0 00)?
   581 0000137E 7402                <1> 	je	.exit			; yes it is Alt + 240, return ASCII
   582 00001380 B000                <1> 	mov	al,00h			; set ASCII character to zero
   583                              <1> 
   584                              <1> .exit:
   585 00001382 E9E654              <1> 	jmp	int_16_exit
   586                              <1> 
   587                              <1> ;=========================================================================
   588                              <1> ; int_16_fn11 - check for extended keystroke
   589                              <1> ; Input:
   590                              <1> ;	AH = 01h
   591                              <1> ; Output:
   592                              <1> ;	ZF = 1 - no keystroke available
   593                              <1> ;	ZF = 0 = keystroke is available and put in AX
   594                              <1> ;		AH = BIOS scan code
   595                              <1> ;		AL = ASCII character
   596                              <1> ; Note:
   597                              <1> ;	- Does not remove keystroke from keyboard buffer
   598                              <1> ;-------------------------------------------------------------------------
   599                              <1> int_16_fn11:
   600 00001385 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   601 00001389 8B07                <1> 	mov	ax,word [bx]
   602 0000138B 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   603 0000138F 7408                <1> 	jz	.exit			; no keystroke, exit
   604 00001391 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   605 00001393 7502                <1> 	jne	.clear_zf		; not a extended key
   606 00001395 B000                <1> 	mov	al,00h			; set scancode to zero
   607                              <1> .clear_zf:
   608 00001397 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   609                              <1> .exit:
   610 00001399 E9D254              <1> 	jmp	int_16_exitf
   193                                  %include	"serial1.inc"		; serial port services & detection
   194                              <1> ;========================================================================
   195                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
   196                              <1> ;       INT 14h, function AH=01h
   197                              <1> ;	INT 14h, function AH=02h
   198                              <1> ;	detect_serial
   199                              <1> ;	serial port related definitions and tables
   200                              <1> ;	- see serial2.inc for other INT 14h functions
   201                              <1> ;-------------------------------------------------------------------------
   202                              <1> ;
   203                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   204                              <1> ;
   205                              <1> ; Copyright (C) 2010 - 2020 Sergey Kiselev.
   206                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   207                              <1> ;
   208                              <1> ; This program is free software: you can redistribute it and/or modify
   209                              <1> ; it under the terms of the GNU General Public License as published by
   210                              <1> ; the Free Software Foundation, either version 3 of the License, or
   211                              <1> ; (at your option) any later version.
   212                              <1> ;
   213                              <1> ; This program is distributed in the hope that it will be useful,
   214                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   215                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   216                              <1> ; GNU General Public License for more details.
   217                              <1> ;
   218                              <1> ; You should have received a copy of the GNU General Public License
   219                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   220                              <1> ;
   221                              <1> ;=========================================================================
   222                              <1> 
   223                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
   224                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
   225                              <1> 
   226                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
   227                              <1> 
   228                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
   229                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
   230                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
   231                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
   232                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
   233                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
   234                              <1> 
   235                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
   236                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
   237                              <1> uart_mcr_rts	equ	2		; MCR - request to send (RTS)
   238                              <1> 
   239                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
   240                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
   241                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
   242                              <1> 
   243                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
   244                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
   245                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
   246                              <1> 
   247                              <1> uart_err_timeout equ	80h		; timeout error
   248                              <1> 
   249                              <1> num_serial	equ	4		; number of serial ports
   250                              <1> 
   251                              <1> ;=========================================================================
   252                              <1> ; int_14_fn01 - Send character
   253                              <1> ; Input:
   254                              <1> ;	AH = 01h - function 01h - send character
   255                              <1> ;	AL = character to send
   256                              <1> ;	DX = serial port number (0-3)
   257                              <1> ; Output:
   258                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   259                              <1> ;-------------------------------------------------------------------------
   260                              <1> int_14_fn01:
   261 0000139C 50                  <1> 	push	ax
   262 0000139D B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; set DTR and RTS in MCR:
   263                              <1> 					; ready to communicate, request to send
   264 0000139F B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR:
   265                              <1> 					; ready to communicate, clear to send
   266 000013A1 B320                <1> 	mov	bl,uart_lsr_thre	; and for THRE in LSR:
   267                              <1> 					; UART is ready to accept new character
   268 000013A3 E82200              <1> 	call	uart_wait_status
   269 000013A6 59                  <1> 	pop	cx
   270 000013A7 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
   271 000013A9 88C8                <1> 	mov	al,cl
   272 000013AB EE                  <1> 	out	dx,al			; sent the character
   273 000013AC E9B753              <1> 	jmp	int_14_exit
   274                              <1> 
   275                              <1> int_14_timeout:
   276 000013AF 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
   277 000013B1 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
   278 000013B4 E9AF53              <1> 	jmp	int_14_exit
   279                              <1> 
   280                              <1> ;=========================================================================
   281                              <1> ; int_14_fn02 - Receive character
   282                              <1> ; Input:
   283                              <1> ;	AH = 02h - function 02h - receive character
   284                              <1> ;	DX = serial port number (0-3)
   285                              <1> ; Output:
   286                              <1> ;	AL = character received
   287                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   288                              <1> ;-------------------------------------------------------------------------
   289                              <1> int_14_fn02:
   290 000013B7 50                  <1> 	push	ax
   291 000013B8 B001                <1> 	mov	al,uart_mcr_dtr		; set DTR in MCR:
   292                              <1> 					; ready to communicate
   293 000013BA B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR:
   294                              <1> 					; ready to communicate
   295 000013BC B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR:
   296                              <1> 					; UART has received a character
   297 000013BE E80700              <1> 	call	uart_wait_status
   298 000013C1 59                  <1> 	pop	cx
   299 000013C2 75EB                <1> 	jnz	int_14_timeout
   300 000013C4 EC                  <1> 	in	al,dx			; receive the character
   301 000013C5 E99E53              <1> 	jmp	int_14_exit
   302                              <1> 
   303                              <1> ;=========================================================================
   304                              <1> ; uart_wait_status - wait for modem and line status
   305                              <1> ; Input:
   306                              <1> ;	AL = value to write to MCR (Modem Control Register)
   307                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
   308                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
   309                              <1> ;	DX = UART base address
   310                              <1> ;	SI = address of the timeout value (in seconds)
   311                              <1> ; Output:
   312                              <1> ;	AH = line status
   313                              <1> ;	ZF = 0 - timeout
   314                              <1> ;	CX,BX - destroyed
   315                              <1> ;-------------------------------------------------------------------------
   316                              <1> uart_wait_status:
   317 000013C8 52                  <1> 	push	dx
   318 000013C9 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
   319 000013CC EE                  <1> 	out	dx,al			; output MCR value
   320 000013CD 42                  <1> 	inc	dx
   321 000013CE 42                  <1> 	inc	dx			; DX = UART MSR address
   322                              <1> 					; OPTIMIZATION:
   323                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
   324 000013CF E80A00              <1> 	call	wait_for_port		; wait for MSR status
   325 000013D2 7506                <1> 	jnz	.wait_exit
   326 000013D4 4A                  <1> 	dec	dx			; DX = UART LSR address
   327                              <1> 					; OPTIMIZATION:
   328                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
   329 000013D5 88DF                <1> 	mov	bh,bl			; BH = LSR mask
   330 000013D7 E80200              <1> 	call	wait_for_port		; wait for LSR status
   331                              <1> .wait_exit:
   332 000013DA 5A                  <1> 	pop	dx
   333 000013DB C3                  <1> 	ret
   334                              <1> 
   335                              <1> ;=========================================================================
   336                              <1> ; wait_for_port - wait for set bits in a register
   337                              <1> ;
   338                              <1> ; Input:
   339                              <1> ;	BH = mask to wait for (bits that need to be 1)
   340                              <1> ;	DX = register address
   341                              <1> ;	SI = address of the timeout value (in seconds)
   342                              <1> ; Output:
   343                              <1> ;	AH = last port reading
   344                              <1> ;	ZF clear on timeout
   345                              <1> ;	ZF set on success
   346                              <1> ;	AL - trashed
   347                              <1> ;	CX - trashed
   348                              <1> ;-------------------------------------------------------------------------
   349                              <1> wait_for_port:
   350                              <1> 
   351 000013DC 53                  <1> 	push	bx
   352 000013DD 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
   353                              <1> 
   354                              <1> .loop_outer:
   355 000013DF B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
   356                              <1> 
   357                              <1> .loop_inner:
   358 000013E2 EC                  <1> 	in	al,dx			; read the register
   359 000013E3 88C4                <1> 	mov	ah,al			; save register in AH
   360 000013E5 20F8                <1> 	and	al,bh
   361 000013E7 38F8                <1> 	cmp	al,bh			; required bits are set?
   362 000013E9 740E                <1> 	je	.exit
   363                              <1> 
   364                              <1> %ifdef AT_DELAY
   365                              <1> 
   366                              <1> .zero_loop:
   367                              <1> 	in	al,ppi_pb_reg
   368                              <1> 	test	al,refresh_flag
   369                              <1> 	jz	.zero_loop		; wait 15.09 us
   370                              <1> 
   371                              <1> .one_loop:
   372                              <1> 	in	al,ppi_pb_reg
   373                              <1> 	test	al,refresh_flag
   374                              <1> 	jnz	.one_loop		; wait 15.09 us
   375                              <1> 
   376                              <1> %else ; AT_DELAY
   377                              <1> 
   378                              <1> 	; wait 30.17 us (Intel 8088 CPU running on 4.77 MHz)
   379 000013EB B008                <1>         mov     al,8
   380                              <1> .delay_loop:
   381 000013ED FEC8                <1>         dec     al
   382 000013EF 75FC                <1>         jnz     .delay_loop
   383                              <1> 
   384                              <1> %endif ; AT_DELAY
   385                              <1> 
   386 000013F1 E2EF                <1> 	loop	.loop_inner
   387                              <1> 
   388 000013F3 FECB                <1> 	dec	bl
   389 000013F5 75E8                <1> 	jnz	.loop_outer
   390 000013F7 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
   391                              <1> 
   392                              <1> .exit:
   393 000013F9 5B                  <1> 	pop	bx
   394 000013FA C3                  <1> 	ret
   395                              <1> 
   396                              <1> ;=========================================================================
   397                              <1> ; detect_serial - detect and print serial ports
   398                              <1> ; Input:
   399                              <1> ;	none
   400                              <1> ; Output:
   401                              <1> ;	none (updates BIOS data area)
   402                              <1> ;-------------------------------------------------------------------------
   403                              <1> detect_serial:
   404 000013FB 50                  <1> 	push	ax
   405 000013FC 53                  <1> 	push	bx
   406 000013FD 52                  <1> 	push	dx
   407 000013FE 56                  <1> 	push	si
   408 000013FF B024                <1> 	mov	al,e_serial_scan
   409 00001401 E680                <1> 	out	post_reg,al
   410                              <1> 
   411 00001403 BE[4C02]            <1> 	mov	si,msg_serial
   412 00001406 E8A502              <1> 	call	print
   413 00001409 BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
   414 0000140C 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
   415 00001410 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
   416 00001414 31DB                <1> 	xor	bx,bx			; BX = 0
   417                              <1> .detect_loop:
   418 00001416 BE[6902]            <1> 	mov	si,msg_serial_com
   419 00001419 E89202              <1> 	call	print
   420 0000141C 88D8                <1> 	mov	al,bl
   421 0000141E D0E8                <1> 	shr	al,1
   422 00001420 FEC0                <1> 	inc	al			; AL = COM port number (1..4)
   423 00001422 E8E702              <1> 	call	print_digit
   424 00001425 BE[5800]            <1> 	mov	si,msg_colon
   425 00001428 E88302              <1> 	call	print
   426 0000142B 2E8B97[7D14]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
   427 00001430 EC                  <1> 	in	al,dx
   428 00001431 B00F                <1> 	mov	al,0Fh
   429 00001433 EE                  <1> 	out	dx,al			; enable interrupts
   430 00001434 B000                <1> 	mov	al,00h
   431 00001436 E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
   432 00001438 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   433 00001439 3C0F                <1> 	cmp	al,0Fh
   434 0000143B 751C                <1> 	jne	.no_port		; no port at this address
   435 0000143D B000                <1> 	mov	al,00h
   436 0000143F EE                  <1> 	out	dx,al			; disable interrupts
   437 00001440 B0FF                <1> 	mov	al,0FFh
   438 00001442 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   439 00001444 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   440 00001445 3C00                <1> 	cmp	al,00h
   441 00001447 7510                <1> 	jne	.no_port		; no port at this address
   442 00001449 4A                  <1> 	dec	dx			; DX = UART base address
   443                              <1> 					; OPTIMIZATION:
   444                              <1> 					; uart_base = uart_ier_reg - 1
   445 0000144A 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
   446                              <1> 					; data area
   447 0000144C 810610000002        <1> 	add	word [equipment_list],0200h ; increment number of serial ports
   448 00001452 89D0                <1> 	mov	ax,dx
   449 00001454 E87202              <1> 	call	print_hex
   450 00001457 EB0A                <1> 	jmp	.next
   451                              <1> 
   452                              <1> .no_port:
   453 00001459 C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
   454 0000145D BE[5300]            <1> 	mov	si,msg_none
   455 00001460 E84B02              <1> 	call	print
   456                              <1> 	
   457                              <1> .next:
   458 00001463 43                  <1> 	inc	bx
   459 00001464 43                  <1> 	inc	bx
   460 00001465 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
   461 00001468 7408                <1> 	je	.done
   462 0000146A BE[5B00]            <1> 	mov	si,msg_semicolon
   463 0000146D E83E02              <1> 	call	print
   464 00001470 EBA4                <1> 	jmp	.detect_loop
   465                              <1> 
   466                              <1> .done:
   467 00001472 BE[5000]            <1> 	mov	si,msg_crlf
   468 00001475 E83602              <1> 	call	print
   469                              <1> 
   470 00001478 5E                  <1> 	pop	si
   471 00001479 5A                  <1> 	pop	dx
   472 0000147A 5B                  <1> 	pop	bx
   473 0000147B 58                  <1> 	pop	ax
   474 0000147C C3                  <1> 	ret
   475                              <1> 
   476                              <1> ;-------------------------------------------------------------------------
   477                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
   478 0000147D F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
   479 00001481 E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
   480                              <1> 
   481                              <1> ;-------------------------------------------------------------------------
   482                              <1> ; UART divisor values table
   483 00001485 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
   484 00001487 0003                <1> 		dw	uart_osc/16/150		; 150 bps
   485 00001489 8001                <1> 		dw	uart_osc/16/300		; 300 bps
   486 0000148B C000                <1> 		dw	uart_osc/16/600		; 600 bps
   487 0000148D 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
   488 0000148F 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
   489 00001491 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
   490 00001493 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
   491 00001495 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
   492 00001497 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
   493 00001499 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
   494 0000149B 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
   495                              <1> num_divisors	equ ($-uart_divisors)/2
   194                                  %include	"printer1.inc"		; parallel printer services & detection
   195                              <1> ;========================================================================
   196                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
   197                              <1> ;	INT 17h, function AH=01h 
   198                              <1> ;	detect_parallel
   199                              <1> ;	- see printer2.inc for other INT 17h functions
   200                              <1> ;-------------------------------------------------------------------------
   201                              <1> ;
   202                              <1> ;=========================================================================
   203                              <1> 
   204                              <1> num_parallel	equ	3		; number of parallel ports
   205                              <1> 
   206                              <1> prn_data_reg	equ	0		; printer data register (out)
   207                              <1> 
   208                              <1> prn_stat_reg	equ	1		; printer status register (in)
   209                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
   210                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
   211                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
   212                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
   213                              <1> 
   214                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
   215                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
   216                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
   217                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
   218                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
   219                              <1> 
   220                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
   221                              <1> 
   222                              <1> ;=========================================================================
   223                              <1> ; int_17_fn01 - Initialize printer port
   224                              <1> ; Input:
   225                              <1> ;	AH = 1 - function 01h - initialize printer port
   226                              <1> ;	DX = printer port number (0-2)
   227                              <1> ; Output:
   228                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
   229                              <1> ;-------------------------------------------------------------------------
   230                              <1> int_17_fn01:
   231 0000149D 42                  <1> 	inc	dx
   232 0000149E 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
   233                              <1> 					; OPTIMIZATION:
   234                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
   235 0000149F B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
   236 000014A1 EE                  <1> 	out	dx,al
   237 000014A2 51                  <1> 	push	cx
   238 000014A3 B9B509              <1> 	mov	cx,prn_init_delay
   239 000014A6 E8DAF2              <1> 	call	delay_15us
   240 000014A9 59                  <1> 	pop	cx
   241 000014AA B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
   242 000014AC EE                  <1> 	out	dx,al			; deactivate init bit
   243 000014AD 4A                  <1> 	dec	dx			; OPTIMIZATION:
   244                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
   245 000014AE E9885B              <1> 	jmp	int_17_status		; exit returning status
   246                              <1> 
   247                              <1> ;=========================================================================
   248                              <1> ; detect_parallel - detect and print parallel ports
   249                              <1> ; Input:
   250                              <1> ;	none
   251                              <1> ; Output:
   252                              <1> ;	none (updates BIOS data area)
   253                              <1> ; Notes:
   254                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
   255                              <1> ;	  enumeration is used:
   256                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
   257                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
   258                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
   259                              <1> ;-------------------------------------------------------------------------
   260                              <1> detect_parallel:
   261 000014B1 50                  <1> 	push	ax
   262 000014B2 53                  <1> 	push	bx
   263 000014B3 52                  <1> 	push	dx
   264 000014B4 56                  <1> 	push	si
   265 000014B5 B025                <1> 	mov	al,e_parallel_scan
   266 000014B7 E680                <1> 	out	post_reg,al
   267                              <1> 
   268 000014B9 BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
   269 000014BC 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
   270 000014C0 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
   271 000014C4 31DB                <1> 	xor	bx,bx			; BX = 0
   272 000014C6 31FF                <1> 	xor	di,di			; DI = 0
   273                              <1> .detect_loop:
   274 000014C8 2E8B95[4115]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
   275 000014CD B05A                <1> 	mov	al,05Ah			; just some test value
   276 000014CF EE                  <1> 	out	dx,al			; write it to the printer data register
   277 000014D0 B0FF                <1> 	mov	al,0FFh
   278 000014D2 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   279 000014D4 EC                  <1> 	in	al,dx
   280 000014D5 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
   281 000014D7 750B                <1> 	jne	.no_port		; no port at this address
   282 000014D9 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
   283                              <1> 					; data area
   284 000014DC 810610000040        <1> 	add	word [equipment_list],4000h ; increment number of printer ports
   285 000014E2 EB09                <1> 	jmp	.next
   286                              <1> 
   287                              <1> .no_port:
   288 000014E4 C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
   289 000014E9 09FF                <1> 	or	di,di			; no printer port at 3BCh?
   290 000014EB 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
   291                              <1> .next:
   292 000014ED 43                  <1> 	inc	bx
   293 000014EE 43                  <1> 	inc	bx
   294                              <1> 
   295                              <1> .next_skip_3BC:
   296 000014EF 47                  <1> 	inc	di
   297 000014F0 47                  <1> 	inc	di
   298 000014F1 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
   299 000014F4 7402                <1> 	je	.print			; done with detection, print findings
   300 000014F6 EBD0                <1> 	jmp	.detect_loop
   301                              <1> 
   302                              <1> .print:
   303 000014F8 BE[6D02]            <1> 	mov	si,msg_parallel
   304 000014FB E8B001              <1> 	call	print
   305 000014FE 31DB                <1> 	xor	bx,bx
   306                              <1> 
   307                              <1> .print_loop:
   308 00001500 BE[8A02]            <1> 	mov	si,msg_parallel_lpt
   309 00001503 E8A801              <1> 	call	print
   310 00001506 88D8                <1> 	mov	al,bl
   311 00001508 D0E8                <1> 	shr	al,1
   312 0000150A FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
   313 0000150C E8FD01              <1> 	call	print_digit
   314 0000150F BE[5800]            <1> 	mov	si,msg_colon
   315 00001512 E89901              <1> 	call	print
   316 00001515 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
   317 00001518 09C0                <1> 	or	ax,ax			; parallel interface installed?
   318 0000151A 7405                <1> 	jz	.print_no_port
   319 0000151C E8AA01              <1> 	call	print_hex
   320 0000151F EB06                <1> 	jmp	.print_next
   321                              <1> 
   322                              <1> .print_no_port:
   323 00001521 BE[5300]            <1> 	mov	si,msg_none
   324 00001524 E88701              <1> 	call	print
   325                              <1> 
   326                              <1> .print_next:
   327 00001527 43                  <1> 	inc	bx
   328 00001528 43                  <1> 	inc	bx
   329 00001529 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
   330 0000152C 7408                <1> 	je	.done
   331 0000152E BE[5B00]            <1> 	mov	si,msg_semicolon
   332 00001531 E87A01              <1> 	call	print
   333 00001534 EBCA                <1> 	jmp	.print_loop
   334                              <1> 
   335                              <1> .done:
   336 00001536 BE[5000]            <1> 	mov	si,msg_crlf
   337 00001539 E87201              <1> 	call	print
   338                              <1> 
   339 0000153C 5E                  <1> 	pop	si
   340 0000153D 5A                  <1> 	pop	dx
   341 0000153E 5B                  <1> 	pop	bx
   342 0000153F 58                  <1> 	pop	ax
   343 00001540 C3                  <1> 	ret
   344                              <1> 
   345                              <1> ;-------------------------------------------------------------------------
   346                              <1> ; parallel port base addresses - used for port detection
   347 00001541 BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
   195                                  %include	"sound.inc"		; sound test
   196                              <1> ;=========================================================================
   197                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
   198                              <1> ;-------------------------------------------------------------------------
   199                              <1> ;
   200                              <1> ;=========================================================================
   201                              <1> 
   202 00001547 6908                <1> notes	dw	pic_freq/554		; D flat
   203 00001549 FFFF                <1> 	dw	-1			; silent
   204 0000154B 8814                <1> 	dw	pic_freq/227		; D flat
   205 0000154D 980C                <1> 	dw	pic_freq/370		; G flat
   206 0000154F 8814                <1> 	dw	pic_freq/227		; D flat
   207 00001551 3B0B                <1> 	dw	pic_freq/415		; A flat
   208 00001553 0000                <1> 	dw	0
   209                              <1> 
   210                              <1> ;=========================================================================
   211                              <1> ; sound - Play power-on sound.
   212                              <1> ; Input:
   213                              <1> ;	none
   214                              <1> ; Output:
   215                              <1> ;	none, destroys some registers
   216                              <1> ;-------------------------------------------------------------------------
   217                              <1> sound:
   218 00001555 FC                  <1> 	cld
   219 00001556 BE[4715]            <1> 	mov	si,notes			; set SI to notes table
   220                              <1> 
   221 00001559 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
   222 0000155B E643                <1> 	out	pit_ctl_reg,al
   223                              <1> 
   224                              <1> .loop:
   225 0000155D 2EAD                <1>     cs	lodsw				; load next note to AX
   226 0000155F 83F800              <1> 	cmp	ax,0
   227 00001562 741E                <1> 	jz	.exit
   228 00001564 7C0A                <1> 	jl	.silent			; don't turn on speaker if silent note
   229 00001566 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
   230 00001568 88E0                <1> 	mov	al,ah
   231 0000156A E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
   232                              <1> 
   233                              <1> ;	in	al,ppi_pb_reg		; read current value of PORT B 读取端口已删除
   234 0000156C B003                <1>         	mov         al,03h			; turn on the speaker 直接D1=1打开扬声器，其他位无意义
   235 0000156E E661                <1>         	out    	ppi_pb_reg,al		; write the new value
   236                              <1> 
   237                              <1> .silent:
   238 00001570 B90030              <1> 	mov	cx,3000h
   239 00001573 E80DF2              <1> 	call	delay_15us		; delay while note is playing
   240                              <1> 
   241                              <1> ;	in	al,ppi_pb_reg		; read current value of PORT B 读取端口已删除，无需读取
   242 00001576 B000                <1> 	mov	al,00h			; turn off the speaker 直接赋值0，关闭扬声器
   243 00001578 E661                <1>         	out     	ppi_pb_reg,al		; write the new value
   244                              <1> 
   245 0000157A B90001              <1>         	mov    	 cx,0100h
   246 0000157D E803F2              <1> 	call	delay_15us		; delay after the note
   247                              <1>         
   248 00001580 EBDB                <1>         	jmp     .loop			; play the next note
   249                              <1> .exit:
   250 00001582 C3                  <1> 	ret
   251                              <1> 
   252                              <1> ;=========================================================================
   253                              <1> ; beep - Play a beep sound
   254                              <1> ; Input:
   255                              <1> ;	BL - duration in 0.1 second
   256                              <1> ; Output:
   257                              <1> ;	BL = 0
   258                              <1> ;-------------------------------------------------------------------------
   259                              <1> beep:
   260 00001583 50                  <1> 	push	ax
   261 00001584 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
   262 00001586 E643                <1> 	out	pit_ctl_reg,al
   263 00001588 B8A806              <1> 	mov	ax,pic_freq/700			; approximately 200 Hz
   264 0000158B E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
   265 0000158D 88E0                <1> 	mov	al,ah
   266 0000158F E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
   267                              <1> ;	in	al,ppi_pb_reg		; read current value of PORT B 读取端口已删除，无需读取
   268 00001591 B003                <1> 	MOV	al,03h			; turn on the speaker  直接赋值D0=1，因为其他位已删除
   269 00001593 E661                <1> 	out	ppi_pb_reg,al		; write the new value
   270                              <1> .loop:
   271 00001595 B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
   272 00001598 E8E8F1              <1> 	call	delay_15us
   273 0000159B E8E5F1              <1> 	call	delay_15us
   274 0000159E FECB                <1> 	dec	bl
   275 000015A0 75F3                <1> 	jnz	.loop
   276 000015A2 B000                <1> 	mov	al,0			; turn off the speaker
   277 000015A4 E661                <1> 	out	ppi_pb_reg,al		; write the new value
   278 000015A6 58                  <1> 	pop	ax
   279 000015A7 C3                  <1> 	ret
   280                              <1> 
   281                              <1> 
   282                              <1> 
   196                                  %include	"cpu.inc"			; CPU and FPU detection
   197                              <1> ;=========================================================================
   198                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
   199                              <1> ;-------------------------------------------------------------------------
   200                              <1> ;
   201                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   202                              <1> ;
   203                              <1> ; Copyright (C) 2010 - 2020 Sergey Kiselev.
   204                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   205                              <1> ;
   206                              <1> ; This program is free software: you can redistribute it and/or modify
   207                              <1> ; it under the terms of the GNU General Public License as published by
   208                              <1> ; the Free Software Foundation, either version 3 of the License, or
   209                              <1> ; (at your option) any later version.
   210                              <1> ;
   211                              <1> ; This program is distributed in the hope that it will be useful,
   212                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   213                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   214                              <1> ; GNU General Public License for more details.
   215                              <1> ;
   216                              <1> ; You should have received a copy of the GNU General Public License
   217                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   218                              <1> ;
   219                              <1> ;=========================================================================
   220                              <1> 
   221                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
   222                              <1> 
   223                              <1> ;=========================================================================
   224                              <1> ; detect_cpu - detect and print CPU type
   225                              <1> ; Note:
   226                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
   227                              <1> ;	  incorrect results if used on other CPU types.
   228                              <1> ;-------------------------------------------------------------------------
   229                              <1> detect_cpu:
   230 000015A8 50                  <1> 	push	ax
   231 000015A9 56                  <1> 	push	si
   232 000015AA B021                <1> 	mov	al,e_cpu_detect
   233 000015AC E680                <1> 	out	post_reg,al
   234                              <1> 
   235 000015AE BE[5E00]            <1> 	mov	si,msg_cpu
   236 000015B1 E8FA00              <1> 	call	print
   237                              <1> 
   238                              <1> ; test for NEC V20
   239 000015B4 B80101              <1> 	mov	ax,0101h
   240 000015B7 D510                <1> 	aad	10h			; NEC V20 ignores the argument
   241 000015B9 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
   242 000015BB 7452                <1> 	je	.nec_v20
   243                              <1> 
   244                              <1> ; not NEC V20, test for various 8088 versions
   245                              <1> .i8088:					; 8088 - NMOS version of 8088
   246 000015BD FA                  <1> 	cli				; disable interrupts
   247 000015BE 1E                  <1> 	push	ds
   248 000015BF 31C0                <1> 	xor	ax,ax
   249 000015C1 8ED8                <1> 	mov	ds,ax			; interrupt table segment
   250 000015C3 B8[2916]            <1> 	mov	ax,.int_01			; new int 01h offset
   251 000015C6 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
   252 000015CA 50                  <1> 	push	ax			; save to stack
   253 000015CB 8CC8                <1> 	mov	ax,cs			; new int 01h segment
   254 000015CD 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
   255 000015D1 50                  <1> 	push	ax			; save to stack
   256 000015D2 9C                  <1> 	pushf				; push flags to stack (save)
   257 000015D3 9C                  <1> 	pushf				; push flags to stack (modify)
   258 000015D4 58                  <1> 	pop	ax			; and move them to AX
   259 000015D5 0D0001              <1> 	or	ax,flags_tf			; set TF
   260 000015D8 50                  <1> 	push	ax
   261 000015D9 31C0                <1> 	xor	ax,ax			; AX = 0
   262 000015DB 9D                  <1> 	popf				; load modified value to FLAGS register
   263                              <1> 					; enable single-step
   264 000015DC 90                  <1> 	nop
   265 000015DD 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
   266                              <1> 					; after PUSH SREG instructions
   267                              <1> .push_sreg:				; and will not single-step to here
   268 000015DE 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
   269                              <1> 					; after modifying segment registers
   270                              <1> .pop_sreg:					; and will not single-step to here
   271 000015DF 90                  <1> 	nop
   272 000015E0 9D                  <1> 	popf				; restore original FLAGS, disable
   273                              <1> 					; single-step
   274                              <1> 
   275 000015E1 5E                  <1> 	pop	si			; get original int 01h segment
   276 000015E2 89360600            <1> 	mov	word [6],si			; save it to interrupt table
   277 000015E6 5E                  <1> 	pop	si			; get original int 01h offset
   278 000015E7 89360400            <1> 	mov	word [4],si			; save it to interrupt table
   279 000015EB 1F                  <1> 	pop	ds	
   280 000015EC FB                  <1> 	sti				; enable interrupts
   281 000015ED 83F801              <1> 	cmp	ax,0001h			; if AX = 0001h - we have INTEL (C) 1978
   282 000015F0 740D                <1> 	jz	.i8088_78
   283                              <1> 
   284 000015F2 83F802              <1> 	cmp	ax,0002h
   285 000015F5 7410                <1> 	jz	.i8088_81
   286                              <1> 
   287                              <1> .harris:				; Harris / Intersil 80C88
   288 000015F7 BE[1301]            <1> 	mov	si,msg_cpu_harris
   289 000015FA E8B100              <1> 	call	print
   290 000015FD EB16                <1> 	jmp	.cpu_freq
   291                              <1> 
   292                              <1> .i8088_78:
   293 000015FF BE[9800]            <1> 	mov	si,msg_cpu_8088_78
   294 00001602 E8A900              <1> 	call	print
   295 00001605 EB0E                <1> 	jmp	.cpu_freq
   296                              <1> 
   297                              <1> .i8088_81:
   298 00001607 BE[F800]            <1> 	mov	si,msg_cpu_8088_81
   299 0000160A E8A100              <1> 	call	print
   300 0000160D EB06                <1> 	jmp	.cpu_freq
   301                              <1> 
   302                              <1> .nec_v20:
   303 0000160F BE[2001]            <1> 	mov	si,msg_cpu_nec_v20
   304 00001612 E89900              <1> 	call	print
   305                              <1> 
   306                              <1> .cpu_freq:
   307                              <1> 
   308                              <1> %ifdef TURBO_MODE
   309                              <1> ; print CPU clock frequency
   310                              <1> 
   311                              <1> 	mov	si,msg_at
   312                              <1> 	call	print
   313                              <1> 
   314                              <1> 	push	ax
   315                              <1> 	call	get_config_a		; read BIOS configuration byte A
   316                              <1> 	call	print_cpu_clk
   317                              <1> 	pop	ax
   318                              <1> 
   319                              <1> %endif ; TURBO_MODE
   320                              <1> 
   321 00001615 BE[5000]            <1> 	mov	si,msg_crlf
   322 00001618 E89300              <1> 	call	print
   323                              <1> 
   324 0000161B 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
   325 0000161E 7506                <1> 	jnz	.exit
   326 00001620 BE[A700]            <1> 	mov	si,msg_cpu_bug
   327 00001623 E88800              <1> 	call	print
   328                              <1> 
   329                              <1> .exit:
   330 00001626 5E                  <1> 	pop	si
   331 00001627 58                  <1> 	pop	ax
   332 00001628 C3                  <1> 	ret
   333                              <1> 
   334                              <1> ; stack frame after "push bp"
   335                              <1> ; BP - word [BP]
   336                              <1> ; IP - word [BP+2]
   337                              <1> ; CS - word [BP+4]
   338                              <1> ; FLAGS - word [BP+6]
   339                              <1> .int_01:
   340 00001629 55                  <1> 	push	bp
   341 0000162A 89E5                <1> 	mov	bp,sp
   342 0000162C 817E02[DF15]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
   343 00001631 7504                <1> 	jne	.1
   344 00001633 B001                <1> 	mov	al,01h			; (C) INTEL '79
   345 00001635 EB09                <1> 	jmp	.int_01_exit
   346                              <1> .1:
   347 00001637 817E02[DE15]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
   348 0000163C 7502                <1> 	jne	.int_01_exit
   349 0000163E B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
   350                              <1> .int_01_exit:
   351 00001640 5D                  <1> 	pop	bp
   352 00001641 CF                  <1> 	iret
   353                              <1> 
   354                              <1> ;=========================================================================
   355                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
   356                              <1> ;-------------------------------------------------------------------------
   357                              <1> test_word	equ	03FEh		; right at the end of interrupt table
   358                              <1> detect_fpu:
   359 00001642 50                  <1> 	push	ax
   360 00001643 51                  <1> 	push	cx
   361 00001644 56                  <1> 	push	si
   362 00001645 B022                <1> 	mov	al,e_fpu_detect
   363 00001647 E680                <1> 	out	post_reg,al
   364                              <1> 
   365 00001649 BE[7B00]            <1> 	mov	si,msg_fpu
   366 0000164C E85F00              <1> 	call	print
   367 0000164F DBE3                <1> 	fninit				; initialize coprocessor
   368 00001651 B90300              <1> 	mov	cx,3
   369                              <1> .wait:
   370 00001654 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
   371                              <1> 					;   (can't use fwait, since it could
   372                              <1> 					;   be no coprocessor at all)
   373 00001656 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
   374 0000165A C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
   375 00001660 D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
   376 00001664 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
   377 0000166A 750D                <1> 	jne	.no_fpu			;   after finit
   378                              <1> 
   379                              <1> .fpu:
   380 0000166C BE[2E01]            <1> 	mov	si,msg_fpu_present
   381 0000166F E83C00              <1> 	call	print
   382 00001672 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
   383 00001677 EB06                <1> 	jmp	.exit
   384                              <1> 
   385                              <1> .no_fpu:
   386                              <1> 
   387 00001679 BE[4302]            <1> 	mov	si,msg_absent
   388 0000167C E82F00              <1> 	call	print
   389                              <1> 
   390                              <1> .exit:
   391 0000167F 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
   392                              <1> 
   393 00001683 5E                  <1> 	pop	si
   394 00001684 59                  <1> 	pop	cx
   395 00001685 58                  <1> 	pop	ax
   396 00001686 C3                  <1> 	ret
   397                              <1> 
   398                              <1> %ifdef TURBO_MODE
   399                              <1> ;=========================================================================
   400                              <1> ; print_cpu_clk - Print CPU clock frequency
   401                              <1> ; Input:
   402                              <1> ;	AL - NVRAM CPU clock frequency configuration (bits 1:0)
   403                              <1> ;		0 - 4.77 MHz / Normal
   404                              <1> ;		1 - 7.16 MHz / Turbo
   405                              <1> ;		2 - 9.55 MHz (FE2010A)
   406                              <1> ; Output:
   407                              <1> ;	none
   408                              <1> ;-------------------------------------------------------------------------
   409                              <1> print_cpu_clk:
   410                              <1> 	push	ax
   411                              <1> 	push	si
   412                              <1> 	and	al,nvram_trbo_mask	; get turbo bits
   413                              <1> 
   414                              <1> %ifdef MACHINE_XI8088
   415                              <1> 	mov	si,msg_clk_turbo
   416                              <1> 	cmp	al,1
   417                              <1> 	je	.print
   418                              <1> %endif ; MACHINE_XI8088
   419                              <1> 	mov	si,msg_clk_4_77mhz
   420                              <1> 
   421                              <1> .print:
   422                              <1> 	call    print
   423                              <1> 	pop	si
   424                              <1> 	pop	ax
   425                              <1> 	ret
   426                              <1> 
   427                              <1> ;=========================================================================
   428                              <1> ; set_cpu_clk - Set CPU clock frequency
   429                              <1> ; Input:
   430                              <1> ;	AL - NVRAM CPU clock frequency configuration
   431                              <1> ;		0 - 4.77 MHz / Normal
   432                              <1> ;		1 - 7.16 MHz / Turbo
   433                              <1> ;		2 - 9.55 MHz (FE2010A)
   434                              <1> ; Output:
   435                              <1> ;	none
   436                              <1> ;-------------------------------------------------------------------------
   437                              <1> set_cpu_clk:
   438                              <1> 
   439                              <1> %ifdef MACHINE_XI8088
   440                              <1> 	cmp	al,1
   441                              <1> 	je	set_cpu_clk_turbo
   442                              <1> 	jmp	set_cpu_clk_4_77mhz   
   443                              <1> %endif ; MACHINE_XI8088
   444                              <1> 	ret
   445                              <1> 
   446                              <1> ;=========================================================================
   447                              <1> ; set_cpu_clk_4_77mhz - Set CPU clock at 4.77 MHz
   448                              <1> ; set_cpu_clk_7_16mhz - Set CPU clock at 7.16 MHz
   449                              <1> ; set_cpu_clk_9_55mhz - Set CPU clock at 9.55 MHz
   450                              <1> ; set_cpu_clk_turbo - Set CPU clock at turbo frequency (system dependent)
   451                              <1> ; Input:
   452                              <1> ;	none
   453                              <1> ; Output:
   454                              <1> ;	none
   455                              <1> ;-------------------------------------------------------------------------
   456                              <1> 
   457                              <1> %ifdef MACHINE_XI8088
   458                              <1> set_cpu_clk_4_77mhz:
   459                              <1> 	push	ax
   460                              <1> 	in	al,ppi_pb_reg
   461                              <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
   462                              <1> 	out	ppi_pb_reg,al
   463                              <1> 	pop	ax
   464                              <1> 	ret
   465                              <1> 
   466                              <1> set_cpu_clk_turbo:
   467                              <1> 	push	ax
   468                              <1> 	in	al,ppi_pb_reg
   469                              <1> 	or	al,04h			; set bit 2 (turbo enable bit)
   470                              <1> 	out	ppi_pb_reg,al
   471                              <1> 	pop	ax
   472                              <1> 	ret
   473                              <1> %endif ; MACHINE_XI8088
   474                              <1> 
   475                              <1> %endif ; TURBO_MODE
   197                                  
   198                                  ;=========================================================================
   199                                  ; boot_os -Boot the OS
   200                                  ;-------------------------------------------------------------------------
   201                                  boot_os:
   202                                  
   203                                  ;-------------------------------------------------------------------------
   204                                  ; Check for F1 (setup key), run setup utility if pressed
   205                                  
   206 00001687 B401                    	mov	ah,01h
   207 00001689 CD16                    	int	16h
   208 0000168B 740E                    	jz	.no_key
   209 0000168D B400                    	mov	ah,00h
   210 0000168F CD16                    	int	16h			; read the keystroke
   211 00001691 3D003B                  	cmp	ax,3B00h		; F1?
   212 00001694 7505                    	jne	.no_key
   213 00001696 800E120001              	or	byte [post_flags],post_setup
   214                                  .no_key:
   215                                  
   216 0000169B F606120001              	test	byte [post_flags],post_setup
   217 000016A0 7400                    	jz	.no_setup
   218                                  
   219                                  .no_setup:
   220                                  
   221                                  %ifdef TURBO_MODE
   222                                  	call	get_config_a		; read BIOS configuration byte A
   223                                  	and	al,nvram_trbo_mask
   224                                  	call	set_cpu_clk		; set CPU clock
   225                                  %endif ; TURBO_MODE
   226                                  
   227 000016A2 B000                    	mov	al,e_boot		; boot the OS POST code
   228 000016A4 E680                    	out	post_reg,al
   229                                  
   230 000016A6 BE[6303]                	mov	si,msg_boot
   231 000016A9 E80200                  	call	print
   232 000016AC CD19                    	int	19h			; boot the OS
   233                                  
   234                                  ;=========================================================================
   235                                  ; print - print ASCIIZ string to the console 将ASCIIZ字符串打印到控制台
   236                                  ; Input:
   237                                  ;	CS:SI - pointer to string to print 指向要打印的字符串的指针
   238                                  ; Output:
   239                                  ;	none
   240                                  ;-------------------------------------------------------------------------
   241                                  print:
   242 000016AE 9C                      	pushf		;标志寄存器PSW入栈(字传送)
   243 000016AF 50                      	push	ax
   244 000016B0 53                      	push	bx
   245 000016B1 56                      	push	si
   246 000016B2 1E                      	push	ds
   247 000016B3 0E                      	push	cs
   248 000016B4 1F                      	pop	ds
   249 000016B5 FC                      	cld		
   250                                  		; cld相对应的指令是std，二者均是用来操作方向标志位DF（Direction Flag）。. cld使DF 复位，即是让DF=0，std使DF置位，即DF=1
   251                                  		; 这两个指令用于串操作指令中。
   252                                  		; 通过执行cld或std指令可以控制方向标志DF，决定内存地址是增大（DF=0，向高地址增加）还是减小（DF=1，向地地址减小）。
   253                                  		; 串操作指令寻址方式有点特殊：
   254                                  		; 源操作数和目的操作数分别使用寄存器 (e)si和 (e)di进行间接寻址；没执行一次串操作，源指针 (e)si和目的指针 (e)di将自动进行修改：
   255                                  		; ±1、±2、±4，其对应的分别是字节操作、字操作和双字操作
   256                                  
   257                                  		; 汇编语言中，串操作指令LODSB/LODSW是块读出指令，其具体操作是把SI指向的存储单元读入累加器,其中LODSB是读入AL,LODSW是读入AX中,
   258                                  		; 然后SI自动增加或减小1或2位.当方向标志位DF=0时，则SI自动增加；DF=1时，SI自动减小。
   259                                  		; 与LODSB/LODSW类似的，STOSB/STOSW是块写入指令，其具体操作是把累加器的内容写入到指向的存储单元中。
   260                                  		; 其中STOSB是从AL中读入,STOSW是从AX中读入,然后DI自动增加或减小1或2位.当方向标志位DF=0时，则DI自动增加；DF=1时，DI自动减小。
   261                                  .1:
   262 000016B6 AC                      	lodsb
   263 000016B7 08C0                    	or	al,al
   264 000016B9 7408                    	jz	.exit	; AL=0转移; 结果为零(或相等)则转移(ZF=1)
   265 000016BB B40E                    	mov	ah,0Eh
   266 000016BD B30F                    	mov	bl,0Fh
   267 000016BF CD10                    	int	10h
   268 000016C1 EBF3                    	jmp	.1
   269                                  .exit:
   270 000016C3 1F                      	pop	ds
   271 000016C4 5E                      	pop	si
   272 000016C5 5B                      	pop	bx
   273 000016C6 58                      	pop	ax
   274 000016C7 9D                      	popf
   275 000016C8 C3                      	ret
   276                                  
   277                                  ;=========================================================================
   278                                  ; print_hex - print 16-bit number in hexadecimal
   279                                  ; Input:
   280                                  ;	AX - number to print
   281                                  ; Output:
   282                                  ;	none
   283                                  ;-------------------------------------------------------------------------
   284                                  print_hex:
   285 000016C9 86C4                    	xchg	al,ah
   286 000016CB E80600                  	call	print_byte		; print the upper byte
   287 000016CE 86C4                    	xchg	al,ah
   288 000016D0 E80100                  	call	print_byte		; print the lower byte
   289 000016D3 C3                      	ret
   290                                  
   291                                  ;=========================================================================
   292                                  ; print_byte - print a byte in hexadecimal
   293                                  ; Input:
   294                                  ;	AL - byte to print
   295                                  ; Output:
   296                                  ;	none
   297                                  ;-------------------------------------------------------------------------
   298                                  print_byte:
   299 000016D4 D0C0                    	rol	al,1
   300 000016D6 D0C0                    	rol	al,1
   301 000016D8 D0C0                    	rol	al,1
   302 000016DA D0C0                    	rol	al,1
   303 000016DC E82D00                  	call	print_digit
   304 000016DF D0C0                    	rol	al,1
   305 000016E1 D0C0                    	rol	al,1
   306 000016E3 D0C0                    	rol	al,1
   307 000016E5 D0C0                    	rol	al,1
   308 000016E7 E82200                  	call	print_digit
   309 000016EA C3                      	ret
   310                                  
   311                                  ;=========================================================================
   312                                  ; print_dec - print 16-bit number in decimal 以十进制打印16位数字
   313                                  ; Input:
   314                                  ;	AX - number to print
   315                                  ; Output:
   316                                  ;	none
   317                                  ;-------------------------------------------------------------------------
   318                                  print_dec:
   319 000016EB 50                      	push	ax
   320 000016EC 51                      	push	cx
   321 000016ED 52                      	push	dx
   322 000016EE B90A00                  	mov	cx,10		; base = 10
   323 000016F1 E80400                  	call	.print_rec
   324 000016F4 5A                      	pop	dx
   325 000016F5 59                      	pop	cx
   326 000016F6 58                      	pop	ax
   327 000016F7 C3                      	ret
   328                                  
   329                                  .print_rec:				; print all digits recursively
   330 000016F8 52                      	push	dx
   331 000016F9 31D2                    	xor	dx,dx		; DX = 0
   332 000016FB F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
   333 000016FD 83F800                  	cmp	ax,0
   334 00001700 7403                    	je	.below10
   335 00001702 E8F3FF                  	call	.print_rec		; print number / 10 recursively
   336                                  .below10:
   337 00001705 89D0                    	mov	ax,dx		; reminder is in DX
   338 00001707 E80200                  	call	print_digit		; print reminder
   339 0000170A 5A                      	pop	dx
   340 0000170B C3                      	ret
   341                                  
   342                                  ;=========================================================================
   343                                  ; print_digit - print hexadecimal digit 打印十六进制数字
   344                                  ; Input:
   345                                  ;	AL - bits 3...0 - digit to print (0...F)
   346                                  ; Output:
   347                                  ;	none
   348                                  ;-------------------------------------------------------------------------
   349                                  print_digit:
   350 0000170C 50                      	push	ax
   351 0000170D 53                      	push	bx
   352 0000170E 240F                    	and	al,0Fh
   353 00001710 0430                    	add	al,'0'			; convert to ASCII
   354 00001712 3C39                    	cmp	al,'9'			; less or equal 9?
   355 00001714 7602                    	jna	.1
   356 00001716 0407                    	add	al,'A'-'9'-1			; a hex digit
   357                                  .1:
   358 00001718 B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
   359 0000171A B307                    	mov	bl,07h			; just in case we're in graphic mode
   360 0000171C CD10                    	int	10h
   361 0000171E 5B                      	pop	bx
   362 0000171F 58                      	pop	ax
   363 00001720 C3                      	ret
   364                                  
   365                                  ;=========================================================================
   366                                  ; print display type 打印显示类型
   367                                  ;-------------------------------------------------------------------------
   368                                  print_display:
   369 00001721 BE[3B01]                	mov	si,msg_disp
   370 00001724 E887FF                  	call	print
   371 00001727 A01000                  	mov	al,byte [equipment_list] 	; get equipment - low byte
   372 0000172A 2430                    	and	al,equip_video		; get video adapter type
   373 0000172C BE[9301]                	mov	si,msg_disp_mda
   374 0000172F 3C30                    	cmp	al,equip_mono		; monochrome?
   375 00001731 7411                    	jz	.print_disp
   376 00001733 BE[7701]                	mov	si,msg_disp_cga_80
   377 00001736 3C20                    	cmp	al,equip_color_80		; CGA 80x25?
   378 00001738 740A                    	jz	.print_disp
   379 0000173A BE[8501]                	mov	si,msg_disp_cga_40
   380 0000173D 3C10                    	cmp	al,equip_color_40		; CGA 40x25?
   381 0000173F 7403                    	jz	.print_disp
   382 00001741 BE[5801]                	mov	si,msg_disp_ega		; otherwise EGA or later
   383                                  .print_disp:
   384 00001744 E867FF                  	call	print
   385 00001747 C3                      	ret
   386                                  ;=========================================================================	
   387                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
   388                                  ;-------------------------------------------------------------------------
   389                                  interrupt_table:
   390 00001748 [537F]                  	dw	int_dummy		; INT 00 - Divide by zero
   391 0000174A [537F]                  	dw	int_dummy		; INT 01 - Single step
   392 0000174C [C362]                  	dw	int_02			; INT 02 - Non-maskable interrupt
   393 0000174E [537F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
   394 00001750 [537F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
   395 00001752 [547F]                  	dw	int_05			; INT 05 - BIOS Print Screen
   396 00001754 [537F]                  	dw	int_dummy		; INT 06
   397 00001756 [537F]                  	dw	int_dummy		; INT 07
   398 00001758 [A57E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
   399 0000175A [8769]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
   400 0000175C [237F]                  	dw	int_ignore			; INT 0A - IRQ2
   401 0000175E [237F]                  	dw	int_ignore			; INT 0B - IRQ3
   402 00001760 [237F]                  	dw	int_ignore			; INT 0C - IRQ4
   403 00001762 [237F]                  	dw	int_ignore			; INT 0D - IRQ5
   404 00001764 [576F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
   405 00001766 [237F]                  	dw	int_ignore			; INT 0F - IRQ7
   406 00001768 [6570]                  	dw	int_10			; INT 10 - BIOS Video Services
   407 0000176A [4D78]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
   408 0000176C [4178]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
   409 0000176E [596C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
   410 00001770 [2967]                  	dw	int_14			; INT 14 - BIOS Serial Communications
   411 00001772 [5978]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
   412 00001774 [2E68]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
   413 00001776 [D26F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
   414 00001778 [4A63]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
   415 0000177A [F266]                  	dw	int_19			; INT 19 - BIOS Boot the OS
   416 0000177C [6E7E]                  	dw	int_1A			; INT 1A - BIOS Time Services
   417 0000177E [537F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
   418 00001780 [537F]                  	dw	int_dummy		; INT 1C - User Timer Tick
   419 00001782 [A470]                  	dw	int_1D			; INT 1D - Video Parameters Table
   420 00001784 [C76F]                  	dw	int_1E			; INT 1E - Floppy Parameters Table
   421                                  %ifndef MACHINE_XT
   422 00001786 [8303]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
   423                                  %else ; MACHINE_XT
   424                                  	dw	int_ignore
   425                                  %endif ; MACHINE_XT
   426                                  
   427                                  ;=========================================================================
   428                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
   429                                  ;-------------------------------------------------------------------------	
   430 00001788 FF<rep 48D3h>           	setloc	0E05Bh			; POST Entry Point
   430          ******************       warning: Inserting 18643 bytes [-w+user]
   431                                  cold_start:
   432 0000605B B84000                  	mov	ax,biosdseg
   433 0000605E 8ED8                    	mov	ds,ax
   434 00006060 C70672000000            	mov	word [warm_boot],0		; indicate cold boot
   435                                  
   436                                  warm_start:
   437 00006066 FA                      	cli				; disable interrupts
   438 00006067 FC                      	cld				; clear direction flag
   439 00006068 B001                    	mov	al,e_cpu_test
   440 0000606A E680                    	out	post_reg,al		; POST start code
   441                                  
   442                                  ;-------------------------------------------------------------------------
   443                                  ; test CPU's FLAG register
   444                                  
   445 0000606C 31C0                    	xor	ax,ax			; AX = 0
   446 0000606E 724A                    	jb	cpu_fail
   447 00006070 7048                    	jo	cpu_fail
   448 00006072 7846                    	js	cpu_fail
   449 00006074 7544                    	jnz	cpu_fail
   450 00006076 7B42                    	jpo	cpu_fail
   451 00006078 83C001                  	add	ax,1			; AX = 1
   452 0000607B 743D                    	jz	cpu_fail
   453 0000607D 7A3B                    	jpe	cpu_fail
   454 0000607F 2D0280                  	sub	ax,8002h
   455 00006082 7836                    	js	cpu_fail
   456 00006084 40                      	inc	ax
   457 00006085 7133                    	jno	cpu_fail
   458 00006087 D1E0                    	shl	ax,1
   459 00006089 732F                    	jnb	cpu_fail
   460 0000608B 752D                    	jnz	cpu_fail
   461 0000608D D1E0                    	shl	ax,1
   462 0000608F 7229                    	jb	cpu_fail
   463                                  
   464                                  ;-------------------------------------------------------------------------
   465                                  ; Test CPU registers
   466                                  
   467 00006091 B8AAAA                  	mov	ax,0AAAAh
   468                                  .1:
   469 00006094 8ED8                    	mov	ds,ax
   470 00006096 8CDB                    	mov	bx,ds
   471 00006098 8EC3                    	mov	es,bx
   472 0000609A 8CC1                    	mov	cx,es
   473 0000609C 8ED1                    	mov	ss,cx
   474 0000609E 8CD2                    	mov	dx,ss
   475 000060A0 89D5                    	mov	bp,dx
   476 000060A2 89EC                    	mov	sp,bp
   477 000060A4 89E6                    	mov	si,sp
   478 000060A6 89F7                    	mov	di,si
   479 000060A8 81FFAAAA                	cmp	di,0AAAAh
   480 000060AC 7506                    	jnz	.2
   481 000060AE 89F8                    	mov	ax,di
   482 000060B0 F7D0                    	not	ax
   483 000060B2 EBE0                    	jmp	.1
   484                                  .2:
   485 000060B4 81FF5555                	cmp	di,5555h
   486 000060B8 7418                    	jz	cpu_ok
   487                                  
   488                                  cpu_fail:
   489 000060BA B052                    	mov	al,e_cpu_fail
   490 000060BC E680                    	out	post_reg,al
   491                                  
   492                                  ;-------------------------------------------------------------------------
   493                                  ; CPU error: continious beep - 400 Hz
   494                                  
   495 000060BE B0B6                    	mov	al,0B6h
   496 000060C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   497 000060C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   498 000060C5 E642                    	out	pit_ch2_reg,al
   499 000060C7 88E0                    	mov	al,ah
   500 000060C9 E642                    	out	pit_ch2_reg,al
   501                                  ;	in	al,ppi_pb_reg		; 无需读取，直接赋值
   502 000060CB B003                    	mov	al,03h			; turn speaker on and enable
   503 000060CD E661                    	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   504                                  
   505                                  .1:
   506 000060CF F4                      	hlt
   507 000060D0 EBFD                    	jmp	.1
   508                                  
   509                                  ;-------------------------------------------------------------------------
   510                                  ; CPU test passed
   511                                  
   512                                  cpu_ok:
   513                                  
   514                                  ;-------------------------------------------------------------------------
   515                                  ; disable NMI, turbo mode, and video output on CGA and MDA
   516                                  
   517 000060D2 B002                    	mov	al,e_init_cfg
   518 000060D4 E680                    	out	post_reg,al
   519                                  
   520                                  %ifdef MACHINE_XI8088
   521                                  ;	mov	al,iochk_disable		; clear and disable ~IOCHK
   522                                  ;	out	ppi_pb_reg,al
   523 000060D6 B000                    	mov	al,00h			; clear turbo bit
   524 000060D8 E661                    	out	ppi_pb_reg,al		; and also turn off the speaker
   525                                  %endif ; MACHINE_XI8088
   526                                  
   527 000060DA B000                    	mov	al,00h
   528 000060DC BAD803                  	mov	dx,cga_mode_reg
   529 000060DF EE                      	out	dx,al			; disable video output on CGA
   530 000060E0 FEC0                    	inc	al
   531 000060E2 BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
   532 000060E5 EE                      	out	dx,al			; and set MDA high-resolution mode bit
   533                                  
   534                                  ;-------------------------------------------------------------------------
   535                                  ;-------------------------------------------------------------------------
   536                                  ; Initialize DMAC (8237)
   537                                   
   538 000060E6 B003                    	mov	al,e_init_dmac
   539 000060E8 E680                    	out	post_reg,al
   540 000060EA E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
   541 000060EC B040                     	mov	al,40h			; single mode, verify, channel 0
   542 000060EE E60B                     	out	dmac_mode_reg,al		; DMA Mode register
   543 000060F0 B041                     	mov	al,41h			; single mode, verify, channel 1
   544 000060F2 E60B                     	out	dmac_mode_reg,al		; DMA Mode register
   545 000060F4 B042                     	mov	al,42h			; single mode, verify, channel 2
   546 000060F6 E60B                     	out	dmac_mode_reg,al		; DMA Mode register
   547 000060F8 B043                     	mov	al,43h			; single mode, verify, channel 3
   548 000060FA E60B                     	out	dmac_mode_reg,al		; DMA Mode register
   549 000060FC B000                     	mov	al,0			; DMA Command register bits:
   550                                   					; DACK active low, DREQ active high,
   551                                   					; late write, fixed priority,
   552                                   					; normal timing, controller enable
   553                                   					; channel 0 addr hold disable
   554                                   					; memory to memory disable
   555 000060FE E608                     	out	08h,al			; DMA Command register
   556 00006100 E681                     	out	81h,al			; DMA Page, channel 2
   557 00006102 E682                     	out	82h,al			; DMA Page, channel 3
   558 00006104 E683                     	out	83h,al			; DMA Page, channels 0,1
   559                                  
   560                                  ;-------------------------------------------------------------------------
   561                                  
   562                                  ;-------------------------------------------------------------------------
   563                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
   564 00006106 B301                    	MOV	BL,01
   565 00006108 E878B4                  	call	beep
   566                                  
   567 0000610B B004                    	mov	al,e_low_ram_test
   568 0000610D E680                    	out	post_reg,al
   569 0000610F 31F6                    	xor	si,si
   570 00006111 31FF                    	xor	di,di
   571 00006113 8EDF                    	mov	ds,di
   572 00006115 8EC7                    	mov	es,di
   573 00006117 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
   574 0000611B B8AA55                  	mov	ax,55AAh			; first test pattern
   575 0000611E B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   576 00006121 F3AB                        rep	stosw				; store test pattern
   577 00006123 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   578                                  .1:
   579 00006126 AD                      	lodsw
   580 00006127 3DAA55                  	cmp	ax,55AAh			; compare to the test pattern
   581 0000612A 7524                    	jne	low_ram_fail
   582 0000612C E2F8                    	loop	.1
   583 0000612E 31F6                    	xor	si,si
   584 00006130 31FF                    	xor	di,di
   585 00006132 B855AA                  	mov	ax,0AA55h		; second test pattern
   586 00006135 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   587 00006138 F3AB                        rep stosw				; store test pattern
   588 0000613A B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   589                                  .2:
   590 0000613D AD                      	lodsw
   591 0000613E 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
   592 00006141 750D                    	jne	low_ram_fail
   593 00006143 E2F8                    	loop	.2
   594 00006145 31FF                    	xor	di,di
   595 00006147 31C0                    	xor	ax,ax			; zero
   596 00006149 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   597 0000614C F3AB                        rep stosw				; zero the memory
   598 0000614E EB27                    	jmp	low_ram_ok		; test passed
   599                                  
   600                                  low_ram_fail:
   601 00006150 B054                    	mov	al,e_low_ram_fail	; test failed
   602 00006152 E680                    	out	post_reg,al
   603                                  
   604                                  ;-------------------------------------------------------------------------
   605                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
   606                                  
   607 00006154 B0B6                    	mov	al,0B6h
   608 00006156 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   609 00006158 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   610 0000615B E642                    	out	pit_ch2_reg,al
   611 0000615D 88E0                    	mov	al,ah
   612 0000615F E642                    	out	pit_ch2_reg,al
   613                                  ;	in	al,ppi_pb_reg		; 无需读取
   614                                  .1:
   615 00006161 B003                    	MOV	al,3			; turn speaker on and enable
   616 00006163 E661                    	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   617 00006165 B90000                  	mov	cx,0
   618                                  .2:
   619 00006168 90                      	nop
   620 00006169 E2FD                    	loop	.2
   621 0000616B B000                    	mov	al,00h			; turn off speaker
   622 0000616D E661                    	out	ppi_pb_reg,al
   623 0000616F B90000                  	mov	cx,0
   624                                  .3:
   625 00006172 90                      	nop
   626 00006173 E2FD                    	loop	.3
   627 00006175 EBEA                    	jmp	.1
   628                                  
   629                                  ;-------------------------------------------------------------------------
   630                                  ; Low memory test passed
   631                                  
   632                                  low_ram_ok:
   633 00006177 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
   634                                  
   635                                  ;-------------------------------------------------------------------------
   636                                  ; Set up stack - using upper 256 bytes of interrupt table
   637                                  
   638 0000617B B83000                  	mov	ax,0030h
   639 0000617E 8ED0                    	mov	ss,ax
   640 00006180 BC0001                  	mov	sp,0100h
   641                                  
   642                                  ;-------------------------------------------------------------------------
   643                                  ; Initialize interrupt table
   644                                  
   645 00006183 B005                    	mov     al,e_int_table
   646 00006185 E680                    	out	post_reg,al
   647 00006187 0E                      	push	cs
   648 00006188 1F                      	pop	ds
   649 00006189 31FF                    	xor	di,di
   650 0000618B 8EC7                    	mov	es,di
   651 0000618D BE[4817]                	mov	si,interrupt_table
   652 00006190 B92000                  	mov	cx,0020h			; 32 Interrupt vectors
   653 00006193 B800F0                  	mov	ax,bioscseg
   654                                  .1:
   655 00006196 A5                      	movsw				; copy ISR address (offset part)
   656 00006197 AB                      	stosw				; store segment part
   657 00006198 E2FC                    	loop	.1
   658                                  
   659                                  ;-------------------------------------------------------------------------
   660                                  ; set DS to BIOS data area
   661                                  
   662 0000619A B84000                  	mov	ax,biosdseg		; DS = BIOS data area
   663 0000619D 8ED8                    	mov	ds,ax
   664                                  
   665                                  ;-------------------------------------------------------------------------
   666                                  ; Initialize PIT (8254 timer)
   667                                  
   668 0000619F B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
   669 000061A1 E643                    	out	pit_ctl_reg,al
   670 000061A3 B000                    	mov	al,0
   671 000061A5 E640                    	out	pit_ch0_reg,al
   672 000061A7 E640                    	out	pit_ch0_reg,al
   673 000061A9 B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
   674 000061AB E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
   675 000061AD B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
   676 000061AF E641                    	out	pit_ch1_reg,al		; pulse every 15ms
   677 000061B1 B040                    	mov	al,40h			; channel 1, counter latch
   678 000061B3 E643                    	out	pit_ctl_reg,al		; FIXME - not needed?
   679                                  
   680                                  ;-------------------------------------------------------------------------
   681                                  ; Play "power on" sound - also tests PIT functionality
   682                                  
   683 000061B5 B006                    	mov     	al,e_pit_init
   684 000061B7 E680                    	out	post_reg,al
   685 000061B9 B301                    	MOV	BL,01
   686 000061BB E8C5B3                  	call	beep
   687 000061BE B301                    	MOV	BL,01
   688 000061C0 E8C0B3                  	call	beep
   689                                  
   690                                  ;-------------------------------------------------------------------------
   691                                  ; Initialize PIC (8259)
   692                                  
   693 000061C3 B007                    	mov	al,e_pic_init
   694 000061C5 E680                    	out	post_reg,al
   695                                  
   696 000061C7 B013                    	mov	al,13h			; (0001 0011) ICW1 - edge triggered, single, ICW4	ICW1-边缘触发，单，ICW4
   697 000061C9 E620                    	out	pic1_reg0,al
   698 000061CB B008                    	mov	al,8			; (0000 1000) ICW2 - interrupt vector offset = 8	ICW2-中断向量偏移=8
   699                                  					; 也就是说，IRQ0中断类型号为08h
   700                                  					;	  IRQ1中断类型号为09h
   701 000061CD E621                    	out	pic1_reg1,al
   702 000061CF B009                    	mov	al,9			; (0000 1001) ICW4 - buffered mode, 8086/8088	ICW4-缓冲模式，8086/8088
   703 000061D1 E621                    	out	pic1_reg1,al
   704                                  
   705                                  ;-------------------------------------------------------------------------
   706                                  ; initialize keyboard controller (8242), 
   707                                  
   708 000061D3 B008                    	mov	al,e_kbd_init
   709 000061D5 E680                    	out	post_reg,al
   710                                  ; 以下10条，由于PB端口已经定义为其他用途，所以不再用于控制键盘
   711                                  ;	in	al,ppi_pb_reg
   712                                  ;	and	al,00111111b		; set keyboard clock low
   713                                  ;	out	ppi_pb_reg,al
   714                                  ;	mov	cx,10582			; hold clock low for 20 ms
   715                                  ;.kbd_reset_wait:
   716                                  ;	loop	.kbd_reset_wait
   717                                  ;	or	al,11000000b		; set keyboard clear bit, enable clock
   718                                  ;	out	ppi_pb_reg,al
   719                                  ;	and	al,01111111b		; unset keyboard clear bit
   720                                  ;	out	ppi_pb_reg,al
   721                                  
   722 000061D7 B9E803                  	mov	cx,1000
   723                                  .kbd_flush:
   724 000061DA B401                    	mov 	ah,01h
   725 000061DC CD16                    	int	16h
   726 000061DE 7404                    	jz	.kbd_no_key
   727 000061E0 B400                    	mov	ah,00h
   728 000061E2 CD16                    	int	16h
   729                                  .kbd_no_key:
   730 000061E4 E2F4                    	loop	.kbd_flush
   731                                  
   732 000061E6 E8AE09                  	call	kbd_buffer_init		; setup keyboard buffer
   733                                  
   734                                  ;-------------------------------------------------------------------------
   735                                  ; enable interrupts
   736                                  
   737 000061E9 B009                    	mov	al,e_int_ena
   738 000061EB E680                    	out	post_reg,al
   739                                  
   740 000061ED FB                      	sti
   741                                  
   742 000061EE B080                    	mov	al,nmi_enable
   743 000061F0 E6A0                    	out	nmi_mask_reg,al		; enable NMIs
   744                                  ;----------------------------------------------------------------------------------------------------------------------------------------
   745                                  ;这里等待修改，在没有kbc的情况下如何设置显示器类型
   746                                  ;
   747                                  ;	or	word [equipment_list],equip_mono	; 设置显示器类型为mono
   748                                  ;	or	word [equipment_list],equip_color_80	; 设置显示器类型为color
   749                                  ;----------------------------------------------------------------------------------------------------------------------------------------
   750                                  
   751                                  ;-------------------------------------------------------------------------
   752                                  ; look for video BIOS, initialize it if present
   753                                  	
   754 000061F2 B010                    	mov	al,e_vid_bios_scan
   755 000061F4 E680                    	out	post_reg,al
   756 000061F6 BA00C0                  	mov	dx,0C000h
   757 000061F9 BB00C8                  	mov	bx,0C800h
   758 000061FC E89716                  	call	extension_scan
   759 000061FF 833E670000              	cmp	word [67h],0
   760 00006204 7414                    	jz	.no_video_bios
   761 00006206 B011                    	mov	al,e_vid_bios_init
   762 00006208 E680                    	out	post_reg,al
   763 0000620A FF1E6700                	call	far [67h]
   764 0000620E B84000                  	mov	ax,biosdseg		; DS = BIOS data area
   765 00006211 8ED8                    	mov	ds,ax
   766                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
   767 00006213 83261000CF              	and	word [equipment_list],~equip_video
   768                                  ;	or	word [equipment_list],equip_mono	;自己添加
   769 00006218 EB24                    	jmp	.video_initialized
   770                                  
   771                                  .no_video_bios:
   772 0000621A 830E100020              	or	word [equipment_list],equip_color_80	; 设置显示器类型为color(CGA)
   773 0000621F B012                    	mov	al,e_vid_no_bios
   774 00006221 E680                    	out	post_reg,al
   775 00006223 8A261000                	mov	ah,byte [equipment_list] 	; get equipment - low byte
   776 00006227 80E430                  	and	ah,equip_video		; get video adapter type
   777 0000622A B007                    	mov	al,07h			; monochrome 80x25 mode
   778 0000622C 80FC30                  	cmp	ah,equip_mono		; monochrome?
   779 0000622F 7409                    	jz	.set_mode
   780 00006231 B003                    	mov	al,03h			; color 80x25 mode
   781 00006233 80FC20                  	cmp	ah,equip_color_80		; 80x25 color?
   782 00006236 7402                    	jz	.set_mode
   783 00006238 B001                    	mov	al,01h			; color 40x24 mode
   784                                  
   785                                  .set_mode:
   786 0000623A B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
   787 0000623C CD10                    	int	10h
   788                                  
   789                                  .video_initialized:
   790                                  
   791                                  ;---------------------------------------bios显示面------------------------------------------------------------------------------------------
   792                                  ;==================================================================================
   793                                  ;==================================================================================
   794                                  ;--------------------------------------------------------------------------------------------------------------------------------------------
   795                                  ; print the copyright message
   796                                  
   797 0000623E BE[0000]                	mov	si,msg_copyright
   798 00006241 E86AB4                  	call	print
   799                                  ;-------------------------------------------------------------------------
   800                                  ; detect and print availability of various equipment
   801                                  
   802 00006244 E861B3                  	call	detect_cpu		; detect and print CPU type
   803 00006247 E8F8B3                  	call	detect_fpu		; detect and print FPU presence
   804                                  
   805 0000624A E8D4B4                  	call	print_display		; print display type
   806                                  
   807                                  ;	call	detect_serial		; detect serial ports and print findings
   808                                  ;	call	detect_parallel		; detect parallel ports and print
   809                                  					; findings
   810                                  ;	call	detect_floppy		; detect floppy drive types
   811                                  ;	call	print_floppy		; print floppy drive types
   812                                  
   813 0000624D E80A17                  	call	detect_ram		; test RAM, get RAM size in AX
   814                                  
   815 00006250 BE[D102]                	mov	si,msg_ram_total
   816 00006253 E858B4                  	call	print
   817 00006256 E892B4                  	call	print_dec			; print RAM size
   818 00006259 BE[EF02]                	mov	si,msg_kib
   819 0000625C E84FB4                  	call	print
   820                                  
   821 0000625F E83315                  	call	detect_rom_ext		; detect and initialize extension ROMs
   822                                  
   823 00006262 E922B4                  	jmp boot_os
   824                                  
   825                                  ;=========================================================================
   826                                  ; int_02 - NMI
   827                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not implemented
   828                                  ;-------------------------------------------------------------------------
   829 00006265 FF<rep 5Eh>             	setloc	0E2C3h			; NMI Entry Point
   829          ******************       warning: Inserting 94 bytes [-w+user]
   830                                  int_02:
   831 000062C3 50                      	push	ax
   832                                  
   833 000062C4 B000                    	mov	al,nmi_disable
   834 000062C6 E6A0                    	out	nmi_mask_reg,al
   835                                  
   836                                  ;	in	al,ppi_pb_reg		; read Port B
   837 000062C8 88C4                    	mov	ah,al
   838 000062CA 0C08                    	or	al,iochk_disable		; clear and disable ~IOCHK
   839                                  ;	out	ppi_pb_reg,al
   840 000062CC A840                    	test	al,iochk_status
   841 000062CE 7504                    	jnz	.iochk_nmi
   842 000062D0 88E0                    	mov	al,ah
   843                                  ;	out	ppi_pb_reg,al		; restore original bits
   844 000062D2 EB23                    	jmp	.exit
   845                                  
   846                                  .iochk_nmi:
   847 000062D4 56                      	push	si
   848 000062D5 BE[F962]                	mov	si,msg_iochk_nmi
   849 000062D8 E8D3B3                  	call	print
   850 000062DB 5E                      	pop	si
   851                                  .1:
   852 000062DC B400                    	mov	ah,0h
   853 000062DE CD16                    	int	16h
   854 000062E0 0C20                    	or	al,20h			; convert to lower case
   855 000062E2 3C64                    	cmp	al,'d'
   856 000062E4 7411                    	je	.exit			; leave NMIs disabled and exit
   857 000062E6 3C69                    	cmp	al,'i'
   858 000062E8 7409                    	je	.ignore			; enable NMIs and exit
   859 000062EA 3C72                    	cmp	al,'r'
   860 000062EC 7503E96AFD              	je	cold_start
   861 000062F1 EBE9                    	jmp	.1
   862                                  .ignore:
   863 000062F3 B080                    	mov	al,nmi_enable
   864 000062F5 E6A0                    	out	nmi_mask_reg,al
   865                                  .exit:
   866 000062F7 58                      	pop	ax
   867 000062F8 CF                      	iret
   868                                  
   869                                  msg_iochk_nmi:
   870 000062F9 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore, 'd' to disable NMIs, or 'r' to reboot."
   870 00006302 206465746563746564-
   870 0000630B 2E2054797065202769-
   870 00006314 2720746F2069676E6F-
   870 0000631D 72652C202764272074-
   870 00006326 6F2064697361626C65-
   870 0000632F 204E4D49732C206F72-
   870 00006338 2027722720746F2072-
   870 00006341 65626F6F742E       
   871 00006347 0D0A00                  	db	0Dh, 0Ah, 00h
   872                                  
   873                                  ;=========================================================================
   874                                  ; int_18 - execute ROM BASIC
   875                                  ; Note:
   876                                  ;	Prints an error message since we don't have ROM BASIC
   877                                  ;-------------------------------------------------------------------------
   878                                  int_18:
   879 0000634A BE[2203]                	mov	si,msg_no_basic
   880 0000634D E85EB3                  	call	print
   881                                  .1:
   882 00006350 F4                      	hlt
   883 00006351 EBFD                    	jmp	.1
   884                                  
   885                                  ;=========================================================================
   886                                  ; int_19 - load and execute the boot sector
   887                                  ;-------------------------------------------------------------------------
   888 00006353 FF<rep 39Fh>            	setloc	0E6F2h			; INT 19 Entry Point
   888          ******************       warning: Inserting 927 bytes [-w+user]
   889                                  int_19:
   890 000066F2 E9F311                  	jmp	ipl
   891                                  
   892                                  ;=========================================================================
   893                                  ; configuration data table
   894                                  ;-------------------------------------------------------------------------
   895                                  	setloc	0E6F5h
   896                                  config_table:
   897 000066F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
   898                                  .bytes:
   899 000066F7 FC                      	db	MODEL_BYTE		; byte 2: model
   900 000066F8 00                      	db	00h			; byte 3: submodel = 0
   901 000066F9 00                      	db	00h			; byte 4: release = 0
   902                                  
   903 000066FA 00                      	db	00000000b		; byte 5: feature byte 1
   904                                  ;		|||||||`-- system has dual bus (ISA and MCA)
   905                                  ;		||||||`-- bus is Micro Channel instead of ISA
   906                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
   907                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
   908                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
   909                                  ;		||`-- real time clock installed
   910                                  ;		|`-- 2nd interrupt controller installed
   911                                  ;		`-- DMA channel 3 used by hard disk BIOS
   912                                  
   913 000066FB 00                      	db	00h			; byte 6: feature byte 2
   914 000066FC 00                      	db	00h			; byte 7: feature byte 3
   915 000066FD 00                      	db	00h			; byte 8: feature byte 4
   916 000066FE 00                      	db	00h			; byte 9: feature byte 5
   917                                  .size	equ	$-.bytes
   918                                  
   919                                  ;=========================================================================
   920                                  ; Includes with fixed entry points (for IBM compatibility)
   921                                  ;-------------------------------------------------------------------------
   922                                  
   923                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
   924                              <1> ;========================================================================
   925                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
   926                              <1> ;       INT 14h, function AH=00h
   927                              <1> ;       INT 14h, function AH=03h
   928                              <1> ;       INT 14h, function AH=04h
   929                              <1> ;       INT 14h, function AH=05h
   930                              <1> ;	- see serial1.inc for other INT 14h functions
   931                              <1> ;-------------------------------------------------------------------------
   932                              <1> ;
   933                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   934                              <1> ;
   935                              <1> ; Copyright (C) 2010 - 2020 Sergey Kiselev.
   936                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   937                              <1> ;
   938                              <1> ; This program is free software: you can redistribute it and/or modify
   939                              <1> ; it under the terms of the GNU General Public License as published by
   940                              <1> ; the Free Software Foundation, either version 3 of the License, or
   941                              <1> ; (at your option) any later version.
   942                              <1> ;
   943                              <1> ; This program is distributed in the hope that it will be useful,
   944                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   945                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   946                              <1> ; GNU General Public License for more details.
   947                              <1> ;
   948                              <1> ; You should have received a copy of the GNU General Public License
   949                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   950                              <1> ;
   951                              <1> ;=========================================================================
   952                              <1> 
   953                              <1> ;=========================================================================
   954                              <1> ; int_14 - BIOS Serial Port Communication Services
   955                              <1> ;-------------------------------------------------------------------------
   956 000066FF FF<rep 2Ah>         <1> 	setloc	0E729h			; INT 14 Entry Point
   956          ******************  <1>  warning: Inserting 42 bytes [-w+user]
   957                              <1> int_14:
   958 00006729 FB                  <1> 	sti
   959 0000672A 51                  <1> 	push	cx
   960 0000672B 52                  <1> 	push	dx
   961 0000672C 56                  <1> 	push	si
   962 0000672D 1E                  <1> 	push	ds
   963 0000672E 53                  <1> 	push	bx
   964 0000672F BB4000              <1> 	mov	bx,biosdseg
   965 00006732 8EDB                <1> 	mov	ds,bx
   966 00006734 80FC06              <1> 	cmp	ah,.max/2
   967 00006737 732B                <1> 	jae	int_14_error		; invalid function number specified
   968 00006739 83FA04              <1> 	cmp	dx,num_serial
   969 0000673C 7326                <1> 	jae	int_14_error		; invalid port number specified
   970 0000673E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
   971 00006741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
   972 00006743 89D3                <1> 	mov	bx,dx
   973 00006745 D1E3                <1> 	shl	bx,1
   974 00006747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
   975 00006749 09D2                <1> 	or	dx,dx
   976 0000674B 7417                <1> 	jz	int_14_error		; specified port is not installed
   977 0000674D B700                <1> 	mov	bh,0
   978 0000674F 88E3                <1> 	mov	bl,ah
   979 00006751 D1E3                <1> 	shl	bx,1
   980 00006753 2EFFA7[5867]        <1>     cs	jmp	near [.dispatch+bx]
   981                              <1> .dispatch:
   982 00006758 [6C67]              <1> 	dw	int_14_fn00
   983 0000675A [9C13]              <1> 	dw	int_14_fn01
   984 0000675C [B713]              <1> 	dw	int_14_fn02
   985 0000675E [A167]              <1> 	dw	int_14_fn03
   986 00006760 [AB67]              <1> 	dw	int_14_fn04
   987 00006762 [0568]              <1> 	dw	int_14_fn05
   988                              <1> .max	equ	$-.dispatch
   989                              <1> 
   990                              <1> int_14_error:
   991 00006764 31C0                <1> 	xor	ax,ax
   992                              <1> 
   993                              <1> int_14_exit:
   994 00006766 5B                  <1> 	pop	bx
   995 00006767 1F                  <1> 	pop	ds
   996 00006768 5E                  <1> 	pop	si
   997 00006769 5A                  <1> 	pop	dx
   998 0000676A 59                  <1> 	pop	cx
   999 0000676B CF                  <1> 	iret
  1000                              <1> 
  1001                              <1> ;=========================================================================
  1002                              <1> ; int_14_fn00 - Initialize serial port
  1003                              <1> ; Input:
  1004                              <1> ;	AH = 0 - function 00h - initialize serial port
  1005                              <1> ;	AL - initialization parameters
  1006                              <1> ;		bit 1,0	= 10	- 7 data bits
  1007                              <1> ;			= 11	- 8 data bits
  1008                              <1> ;		bit 2	= 0	- 1 stop bit
  1009                              <1> ;			= 1	- 2 stop bits
  1010                              <1> ;		bit 3	= 0	- parity disable
  1011                              <1> ;			= 1	- parity enable
  1012                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  1013                              <1> ;			= 1	- even parity (if parity enabled)
  1014                              <1> ;		bit 7-5 = 000	- 110 bps
  1015                              <1> ;			= 001	- 150 bps
  1016                              <1> ;			= 010	- 300 bps
  1017                              <1> ;			= 011	- 600 bps
  1018                              <1> ;			= 100	- 1200 bps
  1019                              <1> ;			= 101	- 2400 bps
  1020                              <1> ;			= 110	- 4800 bps
  1021                              <1> ;			= 111	- 9600 bps
  1022                              <1> ;	DX = serial port number (0-3)
  1023                              <1> ; Output:
  1024                              <1> ;	AL = modem status
  1025                              <1> ;		bit 0	= 1	- delta clear to send
  1026                              <1> ;		bit 1	= 1	- delta data set ready
  1027                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  1028                              <1> ;		bit 3	= 1	- delta data carrier detect
  1029                              <1> ;		bit 4	= 1	- clear to send
  1030                              <1> ;		bit 5	= 1	- data set ready
  1031                              <1> ;		bit 6	= 1	- ring indicator
  1032                              <1> ;		bit 7	= 1	- data carrier detect
  1033                              <1> ;	AH = line status
  1034                              <1> ;		bit 0	= 1	- data ready
  1035                              <1> ;		bit 1	= 1	- overrun error
  1036                              <1> ;		bit 2	= 1	- parity error
  1037                              <1> ;		bit 3	= 1	- framing error
  1038                              <1> ;		bit 4	= 1	- break interrupt
  1039                              <1> ;		bit 5	= 1	- transmitter holding register
  1040                              <1> ;		bit 6	= 1	- transmitter empty
  1041                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  1042                              <1> ;-------------------------------------------------------------------------
  1043                              <1> int_14_fn00:
  1044 0000676C 88C4                <1> 	mov	ah,al			; save AL to AH
  1045 0000676E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  1046 00006771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  1047 00006773 EE                  <1> 	out	dx,al
  1048 00006774 31DB                <1> 	xor	bx,bx
  1049 00006776 88E3                <1> 	mov	bl,ah
  1050 00006778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  1051 0000677B D0EB                <1> 	shr	bl,1
  1052 0000677D D0EB                <1> 	shr	bl,1
  1053 0000677F D0EB                <1> 	shr	bl,1
  1054 00006781 D0EB                <1> 	shr	bl,1
  1055 00006783 2E8B9F[8514]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  1056 00006788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1057 0000678B 88D8                <1> 	mov	al,bl
  1058 0000678D EE                  <1> 	out	dx,al			; output divisor - low byte
  1059 0000678E 42                  <1> 	inc	dx			; DX = UART base address + 1
  1060 0000678F 88F8                <1> 	mov	al,bh
  1061 00006791 EE                  <1> 	out	dx,al			; output divisor - high byte
  1062 00006792 42                  <1> 	inc	dx
  1063 00006793 42                  <1> 	inc	dx			; DX = UART LCR address
  1064 00006794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  1065 00006796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  1066                              <1> 					; get control bits
  1067 00006798 EE                  <1> 	out	dx,al			; set LCR
  1068 00006799 4A                  <1> 	dec	dx
  1069 0000679A 4A                  <1> 	dec	dx			; DX = UART IER address
  1070                              <1> 					; OPTIMIZATION:
  1071                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  1072 0000679B B000                <1> 	mov	al,0
  1073 0000679D EE                  <1> 	out	dx,al			; disable interrupts
  1074 0000679E 4A                  <1> 	dec	dx			; DX = UART base address
  1075                              <1> 					; OPTIMIZATION:
  1076                              <1> 					; uart_base = uart_ier_reg - 1
  1077 0000679F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1078                              <1> 
  1079                              <1> ;=========================================================================
  1080                              <1> ; int_14_fn03 - Return serial port status
  1081                              <1> ; Input:
  1082                              <1> ;	AH = 03h - function 03h - return serial port status
  1083                              <1> ;	DX = serial port number (0-3)
  1084                              <1> ; Output:
  1085                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  1086                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  1087                              <1> ;-------------------------------------------------------------------------
  1088                              <1> int_14_fn03:
  1089 000067A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  1090 000067A4 EC                  <1> 	in	al,dx
  1091 000067A5 88C4                <1> 	mov	ah,al
  1092 000067A7 42                  <1> 	inc	dx			; DX = UART MSR address
  1093 000067A8 EC                  <1> 	in	al,dx
  1094 000067A9 EBBB                <1> 	jmp	int_14_exit
  1095                              <1> 
  1096                              <1> ;=========================================================================
  1097                              <1> ; int_14_fn04 - Extended initialize serial port
  1098                              <1> ; Input:
  1099                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  1100                              <1> ;	AL - break status:
  1101                              <1> ;		00h = no break
  1102                              <1> ;		01h = break
  1103                              <1> ;	BH - parity:
  1104                              <1> ;		00h = no parity
  1105                              <1> ;		01h = odd parity
  1106                              <1> ;		02h = even parity
  1107                              <1> ;		03h = stick parity odd
  1108                              <1> ;		04h = stick parity even
  1109                              <1> ;	BL - stop bits:
  1110                              <1> ;		00h = 1 stop bit
  1111                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  1112                              <1> ;	CH - word length:
  1113                              <1> ;		00h = 5 bits
  1114                              <1> ;		01h = 6 bits
  1115                              <1> ;		02h = 7 bits
  1116                              <1> ;		03h = 8 bits
  1117                              <1> ;	CL - bps rate:
  1118                              <1> ;		00h = 110 bps
  1119                              <1> ;		01h = 150 bps
  1120                              <1> ;		02h = 300 bps
  1121                              <1> ;		03h = 600 bps
  1122                              <1> ;		04h = 1200 bps
  1123                              <1> ;		05h = 2400 bps
  1124                              <1> ;		06h = 6000 bps
  1125                              <1> ;		07h = 9600 bps
  1126                              <1> ;		08h = 19200 bps
  1127                              <1> ;		09h = 38400 bps
  1128                              <1> ;		0Ah = 57600 bps
  1129                              <1> ;		0Bh = 115200 bps
  1130                              <1> ;	DX = serial port number (0-3)
  1131                              <1> ; Output:
  1132                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  1133                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  1134                              <1> ;-------------------------------------------------------------------------
  1135                              <1> int_14_fn04:
  1136 000067AB 88C4                <1> 	mov	ah,al			; save AL to AH
  1137 000067AD 80F90C              <1> 	cmp	cl,num_divisors
  1138 000067B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  1139                              <1> 					; exit returning modem and line status
  1140 000067B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  1141 000067B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  1142 000067B7 EE                  <1> 	out	dx,al
  1143 000067B8 31DB                <1> 	xor	bx,bx
  1144 000067BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  1145 000067BC D0E3                <1> 	shl	bl,1			; index to the word table
  1146 000067BE 2E8B9F[8514]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  1147 000067C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1148 000067C6 88D8                <1> 	mov	al,bl
  1149 000067C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  1150 000067C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  1151 000067CA 88F8                <1> 	mov	al,bh
  1152 000067CC EE                  <1> 	out	dx,al			; output divisor - high byte
  1153 000067CD 42                  <1> 	inc	dx
  1154 000067CE 42                  <1> 	inc	dx			; DX = UART LCR address
  1155                              <1> 
  1156 000067CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  1157 000067D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  1158                              <1> 
  1159 000067D4 D0E0                <1> 	shl	al,1
  1160 000067D6 D0E0                <1> 	shl	al,1
  1161 000067D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  1162                              <1> 	
  1163 000067DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  1164 000067DB 53                  <1> 	push	bx			; push it back to the stack
  1165                              <1> 
  1166 000067DC 80FF01              <1> 	cmp	bh,1			; parity setting
  1167 000067DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  1168 000067E1 FECF                <1> 	dec	bh
  1169 000067E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  1170 000067E6 D0E7                <1> 	shl	bh,1
  1171 000067E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  1172                              <1> 
  1173                              <1> .set_parity:
  1174 000067EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  1175                              <1> 
  1176 000067EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  1177                              <1> 	
  1178 000067EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  1179 000067F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  1180                              <1> 
  1181 000067F3 D0E0                <1> 	shl	al,1
  1182 000067F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  1183                              <1> 
  1184 000067F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  1185 000067FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  1186                              <1> 
  1187 000067FC EE                  <1> 	out	dx,al			; set LCR
  1188 000067FD 4A                  <1> 	dec	dx
  1189 000067FE 4A                  <1> 	dec	dx			; DX = UART IER address
  1190                              <1> 					; OPTIMIZATION:
  1191                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  1192 000067FF B000                <1> 	mov	al,0
  1193 00006801 EE                  <1> 	out	dx,al			; disable interrupts
  1194 00006802 4A                  <1> 	dec	dx			; DX = UART base address
  1195                              <1> 					; OPTIMIZATION:
  1196                              <1> 					; uart_base = uart_ier_reg - 1
  1197 00006803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1198                              <1> 
  1199                              <1> ;=========================================================================
  1200                              <1> ; int_14_fn05 - Extended serial port control
  1201                              <1> ; Input:
  1202                              <1> ;	AH = 05h - function 05h - extended serial port control
  1203                              <1> ;	AL - sub-function:
  1204                              <1> ;		00h = read modem control register
  1205                              <1> ;		01h = write modem control register
  1206                              <1> ;			BL = modem control register
  1207                              <1> ;	DX = serial port number (0-3)
  1208                              <1> ; Output:
  1209                              <1> ;	AX = status	
  1210                              <1> ;	sub-function AL = 00h:
  1211                              <1> ;		BL = modem control register
  1212                              <1> ;-------------------------------------------------------------------------
  1213                              <1> int_14_fn05:
  1214 00006805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  1215 00006807 750D                <1> 	jnz	int_14_fn05_01
  1216                              <1> 
  1217                              <1> ;-------------------------------------------------------------------------
  1218                              <1> ; sub-function 00h - read modem control register
  1219                              <1> ; int_14_fn05_00:
  1220 00006809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  1221 0000680C EC                  <1> 	in	al,dx
  1222 0000680D 5B                  <1> 	pop	bx			; get BX from the stack
  1223 0000680E 88C3                <1> 	mov	bl,al			; BL = MCR content
  1224 00006810 53                  <1> 	push	bx			; put BX back to the stack
  1225 00006811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1226 00006814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1227                              <1> 
  1228                              <1> ;-------------------------------------------------------------------------
  1229                              <1> ; sub-function 01h - write modem control register
  1230                              <1> int_14_fn05_01:
  1231 00006816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  1232 00006819 5B                  <1> 	pop	bx			; get BX from the stack
  1233 0000681A 53                  <1> 	push	bx			; put BX back to the stack
  1234 0000681B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  1235 0000681D EE                  <1> 	out	dx,al
  1236 0000681E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1237 00006821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
   924                                  %include	"keyboard.inc"		; INT 16, INT 09
   925                              <1> ;=========================================================================
   926                              <1> ; keyboard.inc - Keyboard support
   927                              <1> ;       INT 16h - BIOS Keyboard Services
   928                              <1> ;		- function AH=02h
   929                              <1> ;		- function AH=03h
   930                              <1> ;		- function AH=05h
   931                              <1> ;		- function AH=12h
   932                              <1> ;		- see scancode.inc for other (scancode related) 请参阅scancode.inc用于其他（扫描码相关）
   933                              <1> ;                 INT 16h functions
   934                              <1> ;       INT 09h - IRQ1 interrupt handler 中断处理程序
   935                              <1> ;-------------------------------------------------------------------------
   936                              <1> ;
   937                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   938                              <1> ;
   939                              <1> ;
   940                              <1> ;=========================================================================
   941                              <1> 
   942                              <1> ;=========================================================================
   943                              <1> ; Scan codes and keyboard flags 扫描代码和键盘标志
   944                              <1> ;-------------------------------------------------------------------------
   945                              <1> 
   946                              <1> ; scancodes for special keys 特殊按键的扫描码
   947                              <1> 
   948                              <1> kbd_num_code	equ	45h
   949                              <1> kbd_scroll_code	equ	46h
   950                              <1> kbd_caps_code	equ	3ah
   951                              <1> kbd_ctrl_code	equ	1dh
   952                              <1> kbd_alt_code	equ	38h
   953                              <1> kbd_rshift_code	equ	36h
   954                              <1> kbd_prtsc_code	equ	37h
   955                              <1> kbd_lshift_code	equ	2ah
   956                              <1> kbd_ins_code	equ	52h
   957                              <1> kbd_del_code	equ	53h
   958                              <1> 
   959                              <1> ; Bits for the various modifier keys 各种修改键的位
   960                              <1> 
   961                              <1> kbd_rshft_bit	equ	1
   962                              <1> kbd_lshft_bit	equ	2
   963                              <1> kbd_ctrl_bit	equ	4
   964                              <1> kbd_alt_bit	equ	8
   965                              <1> kbd_scroll_bit	equ	10h
   966                              <1> kbd_num_bit	equ	20h
   967                              <1> kbd_caps_bit	equ	40h
   968                              <1> kbd_ins_bit	equ	80h
   969                              <1> 
   970                              <1> ;=========================================================================
   971                              <1> ; int_16 - BIOS keyboard functions BIOS键盘功能
   972                              <1> ;-------------------------------------------------------------------------
   973 00006824 FF<rep Ah>          <1> 	setloc	0E82Eh
   973          ******************  <1>  warning: Inserting 10 bytes [-w+user]
   974                              <1> int_16:
   975                              <1> ;	call	int_trace		; DEBUG
   976 0000682E 53                  <1> 	push	bx
   977 0000682F 1E                  <1> 	push	ds
   978 00006830 BB4000              <1> 	mov	bx,biosdseg	; biosdseg=0040h
   979 00006833 8EDB                <1> 	mov	ds,bx		; ds=0040h
   980 00006835 80FC13              <1> 	cmp	ah,.num_func
   981 00006838 7331                <1> 	jae	int_16_exit
   982 0000683A B700                <1> 	mov	bh,0
   983 0000683C 88E3                <1> 	mov	bl,ah
   984 0000683E D1E3                <1> 	shl	bx,1
   985 00006840 2EFFA7[4568]        <1>     cs	jmp	near [.dispatch+bx]
   986                              <1> 
   987                              <1> .dispatch:
   988 00006845 [AC12]              <1> 	dw	int_16_fn00	; read char from buffer, wait if empty
   989 00006847 [0113]              <1> 	dw	int_16_fn01	; check buffer, do not clear
   990 00006849 [7468]              <1> 	dw	int_16_fn02	; get shift status
   991 0000684B [6B68]              <1> 	dw	int_16_exit		; not implemented on XT
   992 0000684D [6B68]              <1> 	dw	int_16_exit		; keyclick
   993 0000684F [7968]              <1> 	dw	int_16_fn05	; write to keyboard buffer
   994 00006851 [6B68]              <1> 	dw	int_16_exit		; 06
   995 00006853 [6B68]              <1> 	dw	int_16_exit		; 07
   996 00006855 [6B68]              <1> 	dw	int_16_exit		; 08
   997 00006857 [6B68]              <1> 	dw	int_16_exit		; 09
   998 00006859 [6B68]              <1> 	dw	int_16_exit		; 0A
   999 0000685B [6B68]              <1> 	dw	int_16_exit		; 0B
  1000 0000685D [6B68]              <1> 	dw	int_16_exit		; 0C
  1001 0000685F [6B68]              <1> 	dw	int_16_exit		; 0D
  1002 00006861 [6B68]              <1> 	dw	int_16_exit		; 0E
  1003 00006863 [6B68]              <1> 	dw	int_16_exit		; 0F
  1004 00006865 [5913]              <1> 	dw	int_16_fn10	; get enhanced keystroke
  1005 00006867 [8513]              <1> 	dw	int_16_fn11	; check enhanced keystroke
  1006 00006869 [A268]              <1> 	dw	int_16_fn12	; get enhanced shift flags
  1007                              <1> .num_func	equ	($-.dispatch)/2
  1008                              <1> 
  1009                              <1> int_16_exit:
  1010 0000686B 1F                  <1> 	pop	ds
  1011 0000686C 5B                  <1> 	pop	bx
  1012 0000686D CF                  <1> 	iret
  1013                              <1> 
  1014                              <1> int_16_exitf:
  1015 0000686E 1F                  <1> 	pop	ds
  1016 0000686F 5B                  <1> 	pop	bx
  1017 00006870 FB                  <1> 	sti
  1018 00006871 CA0200              <1> 	retf	2
  1019                              <1> 
  1020                              <1> ;=========================================================================
  1021                              <1> ; int_16_fn02 - get shift flags 获取移位标志
  1022                              <1> ; Input:
  1023                              <1> ;	AH = 02h
  1024                              <1> ; Output:
  1025                              <1> ;	AL - shift flags
  1026                              <1> ;           	AL bits:
  1027                              <1> ;		7 - Insert active
  1028                              <1> ;		6 - Caps Lock active
  1029                              <1> ;		5 - Num Lock active
  1030                              <1> ;		4 - Scroll Lock active
  1031                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  1032                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  1033                              <1> ;		1 - left shift key pressed
  1034                              <1> ;		0 - right shift key pressed
  1035                              <1> ;-------------------------------------------------------------------------
  1036                              <1> int_16_fn02:
  1037 00006874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  1038 00006877 EBF2                <1> 	jmp	int_16_exit
  1039                              <1> 
  1040                              <1> ;=========================================================================
  1041                              <1> ; int_16_fn05 - store keystroke in keyboard buffer 在键盘缓冲区中存储击键
  1042                              <1> ; Input:
  1043                              <1> ;	AH = 05h
  1044                              <1> ;	CH = BIOS scan code
  1045                              <1> ;	CL = ACII character
  1046                              <1> ; Output:
  1047                              <1> ;	AL - status 状态
  1048                              <1> ;	     00h - success
  1049                              <1> ;	     01h - keyboard buffer full
  1050                              <1> ;-------------------------------------------------------------------------
  1051                              <1> int_16_fn05:
  1052 00006879 56                  <1> 	push	si
  1053 0000687A B001                <1> 	mov	al,1			; assume no space
  1054 0000687C FA                  <1> 	cli				; critical section
  1055 0000687D 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  1056 00006881 89DE                <1> 	mov	si,bx
  1057 00006883 83C302              <1> 	add	bx,2
  1058 00006886 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  1059 0000688A 7504                <1> 	jne	.1
  1060 0000688C 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  1061                              <1> .1:
  1062 00006890 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  1063 00006894 7408                <1> 	je	.no_space			; no space in buffer
  1064 00006896 890C                <1> 	mov	word [si],cx
  1065 00006898 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1066 0000689C B000                <1> 	mov	al,0			; stored successfully
  1067                              <1> .no_space:
  1068 0000689E FB                  <1> 	sti
  1069 0000689F 5E                  <1> 	pop	si
  1070 000068A0 EBC9                <1> 	jmp	int_16_exit
  1071                              <1> 
  1072                              <1> ;=========================================================================
  1073                              <1> ; int_16_fn12 - get extended shift flags 获取扩展移位标志
  1074                              <1> ; Input:
  1075                              <1> ;	AH = 12h
  1076                              <1> ; Output:
  1077                              <1> ;	AL - shift flags 1 (same as returned by function AH=02) 移位标志1（与函数AH=02返回的相同）
  1078                              <1> ;	AH - shift flags 2
  1079                              <1> ;            AH bits:
  1080                              <1> ;		7 - SysRq key pressed
  1081                              <1> ;		6 - Caps Lock pressed
  1082                              <1> ;		5 - Num Lock pressed
  1083                              <1> ;		4 - Scroll Lock pressed
  1084                              <1> ;		3 - right Alt key pressed
  1085                              <1> ;		2 - right Ctrl key pressed
  1086                              <1> ;		1 - left Alt key pressed
  1087                              <1> ;		0 - left Ctrl key pressed
  1088                              <1> ;-------------------------------------------------------------------------
  1089                              <1> int_16_fn12:
  1090 000068A2 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  1091 000068A6 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  1092 000068A9 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  1093 000068AC 7403                <1> 	je	.1
  1094 000068AE 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  1095                              <1> .1:
  1096 000068B1 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  1097 000068B4 A09600              <1> 	mov	al,byte [kbd_flags_3]
  1098 000068B7 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  1099 000068B9 08C4                <1> 	or	ah,al			; copy to AH
  1100 000068BB A01700              <1> 	mov	al,byte [kbd_flags_1]
  1101 000068BE EBAB                <1> 	jmp	int_16_exit
  1102                              <1> 
  1103                              <1> ;=========================================================================
  1104                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler 键盘硬件中断（IRQ1）处理程序
  1105                              <1> ;-------------------------------------------------------------------------
  1106 000068C0 FF<rep C7h>         <1> 	setloc	0E987h			; INT 09 Entry Point
  1106          ******************  <1>  warning: Inserting 199 bytes [-w+user]
  1107                              <1> int_09:
  1108 00006987 50                  <1> 	push	ax
  1109 00006988 53                  <1> 	push	bx
  1110 00006989 1E                  <1> 	push	ds
  1111                              <1> 
  1112 0000698A B84000              <1> 	mov	ax,biosdseg		; =0040h
  1113 0000698D 8ED8                <1> 	mov	ds,ax			; ds=0040h
  1114 0000698F E460                <1> 	in	al,ppi_pa_reg		; get keyboard data / scancode	从60h端口获取键盘数据/扫描码
  1115                              <1> 
  1116                              <1> ;	mov	ah,al			; save it in AH
  1117                              <1> ;	in	al,ppi_pb_reg		; read PPI port B, control	获取61h端口数据
  1118                              <1> ;	or	al,10000000b		; set keyboard clear bit	将61h数据最高位置1
  1119                              <1> ;	out	ppi_pb_reg,al		; write it back to PPI port B	写回61h
  1120                              <1> ;	and	al,01111111b		; unset keyboard clear bit
  1121                              <1> ;	out	ppi_pb_reg,al		; write it back to PPI port B
  1122                              <1> ;	mov	al,ah			; restore AL / scancode
  1123                              <1> 
  1124 00006991 FB                  <1> 	sti				; 开中断
  1125                              <1> 
  1126 00006992 3CFF                <1> 	cmp	al,0FFh			; check for overrun 检查是否超限
  1127 00006994 7503E9B901          <1> 	jz	keyboard_int_exit		; 相等(ZF=1)则转移
  1128                              <1> 
  1129 00006999 3CFD                <1> 	cmp	al,0FDh			; 自定WIN键，开启扬声器
  1130 0000699B 7500                <1> 	jne	.outmy1			; 
  1131                              <1> ;	MOV        AH,AL
  1132                              <1> ;	MOV	AL,1
  1133                              <1> ;	OUT	ppi_pb_reg,AL
  1134                              <1> ;	MOV	AL,AH
  1135                              <1> .outmy1
  1135          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+label-orphan]
  1136 0000699D 3C52                <1> 	cmp	al,052h			; 自定--键，关闭扬声器
  1137 0000699F 7500                <1> 	jne	.outmy2			; 
  1138                              <1> ;	MOV        AH,AL
  1139                              <1> ;	MOV	AL,0
  1140                              <1> ;	OUT	ppi_pb_reg,AL
  1141                              <1> ;	MOV	AL,AH
  1142                              <1> .outmy2
  1142          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+label-orphan]
  1143                              <1> 
  1144                              <1> ; check for KBC response codes 检查KBC响应代码
  1145                              <1> 
  1146 000069A1 3CEE                <1> 	cmp	al,0EEh			; echo response? 回声响应？
  1147 000069A3 7503E9AA01          <1> 	je      keyboard_int_exit		; je和jz一模一样，所以相等(ZF=1)则转移
  1148 000069A8 3CFA                <1> 	cmp	al,0FAh			; acknowledge? 应答？
  1149 000069AA 7508                <1> 	jne     .2				; 不相等(ZF=0)转移，如果转移则说明是 非应答
  1150 000069AC 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  1151 000069B1 E99E01              <1> 	jmp	keyboard_int_exit
  1152                              <1> .2:
  1153 000069B4 3CFE                <1> 	cmp	al,0FEh			; resend command? 重发命令？
  1154 000069B6 7508                <1> 	jne	.3			; 不相等转移，如果转移说明是 非重发命令
  1155 000069B8 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  1156 000069BD E99201              <1> 	jmp	keyboard_int_exit
  1157                              <1> 
  1158                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  1159                              <1> ; 其他KBC响应代码已设置MSB位，将被忽略
  1160                              <1> 
  1161                              <1> .3:
  1162                              <1> 
  1163                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  1164                              <1> ; 检查0E0h和0E1h扫描码，在kbd_flags_3中设置标志
  1165                              <1> 
  1166 000069C0 3CE0                <1> 	cmp	al,0E0h
  1167 000069C2 750D                <1> 	jne	.4			; 
  1168 000069C4 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  1169 000069C9 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  1170 000069CE E98101              <1> 	jmp	keyboard_int_exit
  1171                              <1> .4:
  1172 000069D1 3CE1                <1> 	cmp	al,0E1h
  1173 000069D3 750D                <1> 	jne	.5
  1174 000069D5 800E960001          <1> 	or	byte [kbd_flags_3],1		; set E1 flag
  1175 000069DA 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  1176 000069DF E97001              <1> 	jmp	keyboard_int_exit
  1177                              <1> 
  1178                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  1179                              <1> ; 检查各种<Ctrl>+<Alt>+<Key>组合：
  1180                              <1> 
  1181                              <1> .5:
  1182 000069E2 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  1183 000069E6 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  1184 000069E9 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  1185 000069EC 750F                <1> 	jne	.6
  1186 000069EE 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  1187 000069F0 750B                <1> 	jne	.check_turbo_off
  1188 000069F2 C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  1189 000069F8 EA[6660]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  1190                              <1> 
  1191                              <1> 
  1192                              <1> ; handle turbo mode switch combinations 
  1193                              <1> ; 处理turbo模式开关组合
  1194                              <1> .check_turbo_off:
  1195                              <1> %ifdef TURBO_MODE
  1196                              <1> 	cmp	al,4Ah			; gray - scancode
  1197                              <1> 	jne	.check_turbo_mid
  1198                              <1> 
  1199                              <1> 	call	set_cpu_clk_4_77mhz
  1200                              <1> 	jmp	keyboard_int_exit
  1201                              <1> 
  1202                              <1> .check_turbo_mid:
  1203                              <1> 
  1204                              <1> .check_turbo_hi:
  1205                              <1> 	cmp	al,4Eh			; gray + scancode
  1206                              <1> 	jne	.6
  1207                              <1> 
  1208                              <1> 	call	set_cpu_clk_turbo
  1209                              <1> 	jmp	keyboard_int_exit
  1210                              <1> 
  1211                              <1> %endif ; TURBO_MODE
  1212                              <1> 
  1213                              <1> ; Check for the INS key here. This one needs to toggle the ins bit in the keyboard flags variables.
  1214                              <1> ; 在这里检查INS键。这需要切换键盘标志变量中的ins位。
  1215                              <1> 
  1216                              <1> .6:
  1217 000069FD 3C52                <1> 	cmp	al,kbd_ins_code
  1218 000069FF 7508                <1> 	jne	.7			; 比较是否为ins键，若不是则转移(jne:不相等转移)
  1219 00006A01 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit	 ; set INS bit
  1220 00006A06 E90A01              <1> 	jmp	.translate	   		; pass on INS key
  1221                              <1> 	
  1222                              <1> .7:
  1223 00006A09 3CD2                <1> 	cmp	al,kbd_ins_code+80h		; INS "break" scan code
  1224 00006A0B 750D                <1> 	jne     .8
  1225 00006A0D 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  1226 00006A12 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit 	; toggle INS bit
  1227 00006A17 E93301              <1> 	jmp     .no_buffer
  1228                              <1> 
  1229                              <1> ; handle the left and right Shift keys 处理左右Shift键
  1230                              <1> 
  1231                              <1> .8:
  1232 00006A1A 3C2A                <1> 	cmp	al,kbd_lshift_code
  1233 00006A1C 7508                <1> 	jne	.9
  1234 00006A1E 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit 	; set left Shift bit
  1235 00006A23 E92701              <1> 	jmp	.no_buffer
  1236                              <1> .9:
  1237 00006A26 3CAA                <1> 	cmp	al,kbd_lshift_code+80h 	;kbd_lshift_code+80h
  1238 00006A28 7508                <1> 	jne     .10
  1239 00006A2A 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit		; clear left Shift bit
  1240 00006A2F E91B01              <1> 	jmp     .no_buffer
  1241                              <1> .10:
  1242 00006A32 3C36                <1> 	cmp	al,kbd_rshift_code
  1243 00006A34 7508                <1> 	jne	.11
  1244 00006A36 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit		; set right Shift bit
  1245 00006A3B E90F01              <1> 	jmp	.no_buffer
  1246                              <1> .11:
  1247 00006A3E 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  1248 00006A40 7508                <1> 	jne     .12
  1249 00006A42 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit	; clear right Shift bit
  1250 00006A47 E90301              <1> 	jmp	.no_buffer
  1251                              <1> 
  1252                              <1> ; handle the Alt key 处理Alt键
  1253                              <1> 
  1254                              <1> .12:
  1255 00006A4A 3C38                <1> 	cmp	al,kbd_alt_code
  1256 00006A4C 7508                <1> 	jne	.13
  1257 00006A4E 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit 		; set Alt bit
  1258 00006A53 E9F700              <1> 	jmp	.no_buffer
  1259                              <1> .13:
  1260 00006A56 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  1261 00006A58 751C                <1> 	jne	.14
  1262 00006A5A 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit 		; clear Alt bit
  1263 00006A5F 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  1264 00006A64 7503E9E400          <1> 	je	.no_buffer				; nothing there - exit
  1265 00006A69 A01900              <1> 	mov	al,byte [kbd_alt_keypad]		; put it in the buffer
  1266 00006A6C C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  1267 00006A71 B400                <1> 	mov	ah,0
  1268 00006A73 E9B600              <1> 	jmp	.put_in_buffer
  1269                              <1> 
  1270                              <1> ; handle the Ctrl key 处理Ctrl键
  1271                              <1> 
  1272                              <1> .14:
  1273 00006A76 3C1D                <1> 	cmp	al,kbd_ctrl_code
  1274 00006A78 7508                <1> 	jne	.15
  1275 00006A7A 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit		 ; set Ctrl bit
  1276 00006A7F E9CB00              <1> 	jmp	.no_buffer
  1277                              <1> .15:
  1278 00006A82 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  1279 00006A84 7508                <1> 	jne	.16
  1280 00006A86 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit 	; clear Ctrl bit
  1281 00006A8B E9BF00              <1> 	jmp	.no_buffer
  1282                              <1> 
  1283                              <1> ; handle the Caps Lock key 处理Caps Lock键
  1284                              <1> 
  1285                              <1> .16:
  1286 00006A8E 3C3A                <1> 	cmp	al,kbd_caps_code
  1287 00006A90 750D                <1> 	jne	.17
  1288 00006A92 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit		; set Caps Lock bit
  1289 00006A97 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit 	; toggle Caps Lock bit
  1290 00006A9C E9AE00              <1> 	jmp	.no_buffer
  1291                              <1> .17:
  1292 00006A9F 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  1293 00006AA1 7508                <1> 	jne	.18
  1294 00006AA3 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit 	; clear Caps Lock bit
  1295 00006AA8 E9D000              <1> 	jmp	set_LEDs
  1296                              <1> 
  1297                              <1> ; check if print screen key was pressed 检查是否按下了打印屏幕键
  1298                              <1> 
  1299                              <1> .18:
  1300 00006AAB 3C37                <1> 	cmp	al,kbd_prtsc_code
  1301 00006AAD 750A                <1> 	jne	.test_scroll_loc
  1302 00006AAF F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  1303 00006AB4 7403                <1> 	jz	.test_scroll_loc	; jump if no 0E0h flag (Keypad *)
  1304 00006AB6 E9B500              <1> 	jmp	print_screen
  1305                              <1> 
  1306                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  1307                              <1> ; 操作Scroll Lock（046h）键和Ctrl-Break组合键（0E0h，046h
  1308                              <1> 
  1309                              <1> .test_scroll_loc:
  1310 00006AB9 3C46                <1> 	cmp	al,kbd_scroll_code
  1311 00006ABB 7528                <1> 	jne	.19
  1312 00006ABD F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  1313 00006AC2 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  1314                              <1> 
  1315                              <1> ; handle Ctrl-Break
  1316                              <1> 
  1317 00006AC4 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  1318 00006AC8 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  1319 00006ACC 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1320 00006AD0 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  1321 00006AD5 CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  1322 00006AD7 EB74                <1> 	jmp	.no_buffer
  1323                              <1> 
  1324                              <1> ; handle Scroll Lock
  1325                              <1> 
  1326                              <1> .scroll_lock:
  1327 00006AD9 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  1328 00006ADE 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  1329 00006AE3 EB68                <1> 	jmp	.no_buffer
  1330                              <1> .19:
  1331 00006AE5 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  1332 00006AE7 7508                <1> 	jne	.20
  1333 00006AE9 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  1334 00006AEE E98A00              <1> 	jmp	set_LEDs
  1335                              <1> 
  1336                              <1> ; handle the Num Lock
  1337                              <1> 
  1338                              <1> .20:
  1339 00006AF1 3C45                <1> 	cmp	al,kbd_num_code
  1340 00006AF3 7513                <1> 	jne	.21
  1341 00006AF5 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  1342 00006AFA 755E                <1> 	jnz	pause			; jump if pause
  1343 00006AFC 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  1344 00006B01 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  1345 00006B06 EB45                <1> 	jmp	.no_buffer
  1346                              <1> .21:
  1347 00006B08 3CC5                <1> 	cmp	al,kbd_num_code+80h
  1348 00006B0A 7507                <1> 	jne	.translate
  1349 00006B0C 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  1350 00006B11 EB68                <1> 	jmp	set_LEDs
  1351                              <1> 
  1352                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  1353                              <1> ; 将键盘扫描代码转换为ASCII和BIOS扫描代码
  1354                              <1> 
  1355                              <1> .translate:
  1356 00006B13 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  1357 00006B18 7407                <1> 	jz	.check_release
  1358 00006B1A 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  1359 00006B1F EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  1360                              <1> .check_release:
  1361 00006B21 A880                <1> 	test	al,80h			; ignore key release and KBC responses
  1362 00006B23 7528                <1> 	jnz	.no_buffer
  1363                              <1> 
  1364 00006B25 E8CBA6              <1> 	call	scan_xlat
  1365 00006B28 85C0                <1> 	test	ax,ax		 	; check for bad code
  1366 00006B2A 7421                <1> 	je	.no_buffer
  1367                              <1> 
  1368                              <1> .put_in_buffer:
  1369 00006B2C 56                  <1> 	push	si			; FIXME: Use Int 16h/05 instead?
  1370 00006B2D 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  1371 00006B31 89DE                <1> 	mov	si,bx
  1372 00006B33 83C302              <1> 	add	bx,2
  1373 00006B36 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  1374 00006B3A 7504                <1> 	jne	.1
  1375 00006B3C 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  1376                              <1> .1:
  1377 00006B40 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  1378 00006B44 7406                <1> 	je	.no_space			; no space in buffer
  1379 00006B46 8904                <1> 	mov	word [si],ax
  1380 00006B48 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1381                              <1> 
  1382                              <1> .no_space:
  1383 00006B4C 5E                  <1> 	pop	si
  1384                              <1> 
  1385                              <1> .no_buffer:
  1386 00006B4D 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh		; E0, E1 not last code
  1387                              <1> 
  1388                              <1> keyboard_int_exit:
  1389 00006B52 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1390 00006B54 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  1391                              <1> 
  1392                              <1> keyboard_int_exit1:
  1393 00006B56 1F                  <1> 	pop	ds
  1394 00006B57 5B                  <1> 	pop	bx
  1395 00006B58 58                  <1> 	pop	ax
  1396 00006B59 CF                  <1> 	iret
  1397                              <1> 
  1398                              <1> pause:
  1399 00006B5A 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  1400 00006B5F 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  1401                              <1> 
  1402 00006B61 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1403 00006B63 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1404                              <1> 
  1405                              <1> .pause_loop:
  1406 00006B65 F606180008          <1> 	test	byte [kbd_flags_2],08h
  1407 00006B6A 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  1408 00006B6C EBE8                <1> 	jmp	keyboard_int_exit1
  1409                              <1> 
  1410                              <1> print_screen:
  1411 00006B6E B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1412 00006B70 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1413 00006B72 CD05                <1> 	int	5h			; INT 5 - print screen
  1414 00006B74 80269600FD          <1> 	and     byte [kbd_flags_3],0FDh	; clear E0 flag
  1415 00006B79 EBDB                <1> 	jmp	keyboard_int_exit1
  1416                              <1> 
  1417                              <1> ;=========================================================================
  1418                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  1419                              <1> ; 	     variable and update LEDs on the keyboard
  1420                              <1> ;-------------------------------------------------------------------------
  1421                              <1> set_LEDs:
  1422 00006B7B B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1423 00006B7D E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1424                              <1> 
  1425 00006B7F A01700              <1> 	mov	al,byte [kbd_flags_1]
  1426 00006B82 D0E8                <1> 	shr	al,1
  1427 00006B84 D0E8                <1> 	shr	al,1
  1428 00006B86 D0E8                <1> 	shr	al,1
  1429 00006B88 D0E8                <1> 	shr	al,1
  1430 00006B8A 2407                <1> 	and	al,111b
  1431 00006B8C 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  1432 00006B91 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  1433                              <1> 
  1434 00006B95 EBBF                <1> 	jmp	keyboard_int_exit1
  1435                              <1> 
  1436                              <1> ;=========================================================================
  1437                              <1> ; kbd_buffer_init - Setup keyboard buffer
  1438                              <1> ;-------------------------------------------------------------------------
  1439                              <1> kbd_buffer_init:
  1440 00006B97 B81E00              <1> 	mov	ax,kbd_buffer		; setup keyboard buffer
  1441 00006B9A A38000              <1> 	mov	word [kbd_buffer_start],ax
  1442 00006B9D A31A00              <1> 	mov	word [kbd_buffer_head],ax
  1443 00006BA0 A31C00              <1> 	mov	word [kbd_buffer_tail],ax
  1444 00006BA3 83C020              <1> 	add	ax,20h			; size of the keyboard buffer
  1445 00006BA6 A38200              <1> 	mov	word [kbd_buffer_end],ax
  1446 00006BA9 31C0                <1> 	xor	ax,ax			; clear keyboard flags
  1447 00006BAB A31700              <1> 	mov	word [kbd_flags_1],ax
  1448 00006BAE A31800              <1> 	mov	word [kbd_flags_2],ax
  1449 00006BB1 A39600              <1> 	mov	word [kbd_flags_3],ax
  1450 00006BB4 A39700              <1> 	mov	word [kbd_flags_4],ax
  1451 00006BB7 C3                  <1> 	ret
   925                                  %include	"floppy2.inc"		; INT 13
   926                              <1> ;=========================================================================
   927                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
   928                              <1> ;	INT 13h, function AH=00h
   929                              <1> ;       INT 13h, function AH=02h
   930                              <1> ;       INT 13h, function AH=03h
   931                              <1> ;       INT 13h, function AH=04h
   932                              <1> ;       INT 13h, function AH=05h
   933                              <1> ;	- see floppy1.inc for other INT 13h functions
   934                              <1> ;-------------------------------------------------------------------------
   935                              <1> ;
   936                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   937                              <1> ;
   938                              <1> ; Copyright (C) 2010 - 2020 Sergey Kiselev.
   939                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   940                              <1> ;
   941                              <1> ; This program is free software: you can redistribute it and/or modify
   942                              <1> ; it under the terms of the GNU General Public License as published by
   943                              <1> ; the Free Software Foundation, either version 3 of the License, or
   944                              <1> ; (at your option) any later version.
   945                              <1> ;
   946                              <1> ; This program is distributed in the hope that it will be useful,
   947                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   948                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   949                              <1> ; GNU General Public License for more details.
   950                              <1> ;
   951                              <1> ; You should have received a copy of the GNU General Public License
   952                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   953                              <1> ;
   954                              <1> ;=========================================================================
   955                              <1> 
   956                              <1> ;-------------------------------------------------------------------------
   957                              <1> ; offsets for registers on stack
   958                              <1> int_13_bp	equ	0
   959                              <1> int_13_ds	equ	int_13_bp+2
   960                              <1> int_13_di	equ	int_13_ds+2
   961                              <1> int_13_si	equ	int_13_di+2
   962                              <1> int_13_dx	equ	int_13_si+2
   963                              <1> int_13_dl	equ	int_13_dx
   964                              <1> int_13_dh	equ	int_13_dx+1
   965                              <1> int_13_cx	equ	int_13_dx+2
   966                              <1> int_13_cl	equ	int_13_cx
   967                              <1> int_13_ch	equ	int_13_cx+1
   968                              <1> int_13_bx	equ	int_13_cx+2
   969                              <1> int_13_bl	equ	int_13_bx
   970                              <1> int_13_bh	equ	int_13_bx+1
   971                              <1> int_13_ax	equ	int_13_bx+2
   972                              <1> int_13_al	equ	int_13_ax
   973                              <1> int_13_ah	equ	int_13_ax+1
   974                              <1> int_13_ip	equ	int_13_ax+2
   975                              <1> int_13_cs	equ	int_13_ip+2
   976                              <1> int_13_flags	equ	int_13_cs+2
   977                              <1> int_13_flags_l	equ	int_13_flags
   978                              <1> 
   979                              <1> ;=========================================================================
   980                              <1> ; int_13 - BIOS floppy disk services
   981                              <1> ; Input:
   982                              <1> ;	AH = function
   983                              <1> ;		00h - Reset disk system
   984                              <1> ;		01h - Get status of last operation
   985                              <1> ;		02h - Read disk sectors
   986                              <1> ;		03h - Write disk sectors
   987                              <1> ;		04h - Verify disk sectors
   988                              <1> ;		05h - Format track
   989                              <1> ;		08h - Get drive parameters
   990                              <1> ;		15h - Get disk type
   991                              <1> ;		16h - Detect disk change
   992                              <1> ;		17h - Set disk type for format
   993                              <1> ;		18h - Set media type for format
   994                              <1> ; Output:
   995                              <1> ;	- depends on function
   996                              <1> ;	- for most functions:
   997                              <1> ;		CF clear if successful
   998                              <1> ;			AH = 00h - successful completion
   999                              <1> ;		CF set on error
  1000                              <1> ;			AH = error code
  1001                              <1> ;-------------------------------------------------------------------------
  1002 00006BB8 FF<rep A1h>         <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  1002          ******************  <1>  warning: Inserting 161 bytes [-w+user]
  1003                              <1> int_13:
  1004 00006C59 FB                  <1> 	sti
  1005 00006C5A 50                  <1> 	push	ax
  1006 00006C5B 53                  <1> 	push	bx
  1007 00006C5C 51                  <1> 	push	cx
  1008 00006C5D 52                  <1> 	push	dx
  1009 00006C5E 56                  <1> 	push	si
  1010 00006C5F 57                  <1> 	push	di
  1011 00006C60 1E                  <1> 	push	ds
  1012 00006C61 55                  <1> 	push	bp
  1013 00006C62 89E5                <1> 	mov	bp,sp
  1014 00006C64 80FC19              <1> 	cmp	ah,.num_func
  1015 00006C67 7743                <1> 	ja	.invalid_function
  1016 00006C69 88E0                <1> 	mov	al,ah
  1017 00006C6B 98                  <1> 	cbw
  1018 00006C6C 89C7                <1> 	mov	di,ax
  1019 00006C6E D1E7                <1> 	shl	di,1
  1020 00006C70 B84000              <1> 	mov	ax,biosdseg
  1021 00006C73 8ED8                <1> 	mov	ds,ax
  1022 00006C75 2EFFA5[7A6C]        <1>     cs	jmp	near [.dispatch+di]
  1023                              <1> 
  1024                              <1> .dispatch:
  1025 00006C7A [EF6C]              <1> 	dw	int_13_fn00		; Reset disk system
  1026 00006C7C [B207]              <1> 	dw	int_13_fn01		; Get status of last operation
  1027 00006C7E [5D6D]              <1> 	dw	int_13_fn02		; Read disk sectors
  1028 00006C80 [5D6D]              <1> 	dw	int_13_fn03		; Write disk sectors
  1029 00006C82 [5D6D]              <1> 	dw	int_13_fn04		; Verify disk sectors
  1030 00006C84 [A96E]              <1> 	dw	int_13_fn05		; Format track
  1031 00006C86 [AC6C]              <1> 	dw	.invalid_function	; AH = 06h
  1032 00006C88 [AC6C]              <1> 	dw	.invalid_function	; AH = 07h
  1033 00006C8A [BE07]              <1> 	dw	int_13_fn08		; Get drive parameters
  1034 00006C8C [AC6C]              <1> 	dw	.invalid_function	; AH = 09h
  1035 00006C8E [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ah
  1036 00006C90 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Bh
  1037 00006C92 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Ch
  1038 00006C94 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Dh
  1039 00006C96 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Eh
  1040 00006C98 [AC6C]              <1> 	dw	.invalid_function	; AH = 0Fh
  1041 00006C9A [AC6C]              <1> 	dw	.invalid_function	; AH = 10h
  1042 00006C9C [AC6C]              <1> 	dw	.invalid_function	; AH = 11h
  1043 00006C9E [AC6C]              <1> 	dw	.invalid_function	; AH = 12h
  1044 00006CA0 [AC6C]              <1> 	dw	.invalid_function	; AH = 13h
  1045 00006CA2 [AC6C]              <1> 	dw	.invalid_function	; AH = 14h
  1046 00006CA4 [6B08]              <1> 	dw	int_13_fn15		; Get disk type
  1047 00006CA6 [8C08]              <1> 	dw	int_13_fn16		; Detect disk change
  1048 00006CA8 [D808]              <1> 	dw	int_13_fn17		; Set disk type for format
  1049 00006CAA [4309]              <1> 	dw	int_13_fn18		; Set media type for format
  1050                              <1> .num_func	equ ($-.dispatch)/2
  1051                              <1> 
  1052                              <1> .invalid_function:
  1053 00006CAC B401                <1> 	mov	ah,fdc_e_invalid
  1054 00006CAE 88264100            <1> 	mov	byte [fdc_last_error],ah
  1055 00006CB2 F9                  <1> 	stc				; error condition
  1056 00006CB3 EB21                <1> 	jmp	int_13_exit
  1057                              <1> 
  1058                              <1> ;-------------------------------------------------------------------------
  1059                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  1060                              <1> 
  1061                              <1> int_13_upd_exit:
  1062 00006CB5 9C                  <1> 	pushf
  1063 00006CB6 50                  <1> 	push	ax
  1064 00006CB7 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; get drive number
  1065 00006CBA 3C01                <1> 	cmp	al,1
  1066 00006CBC 7716                <1> 	ja	.no_update		; skip if invalid drive number
  1067 00006CBE BB9000              <1> 	mov	bx,fdc_media_state
  1068 00006CC1 00C3                <1> 	add	bl,al			; BX -> drive media state
  1069 00006CC3 F60710              <1> 	test	byte [bx],fdc_m_established
  1070 00006CC6 740C                <1> 	jz	.no_update		; skip if media type not established
  1071 00006CC8 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  1072 00006CCA 08C0                <1> 	or	al,al
  1073 00006CCC 7402                <1> 	jz	.drive_0
  1074 00006CCE B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  1075                              <1> 
  1076                              <1> .drive_0:
  1077 00006CD0 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  1078                              <1> 
  1079                              <1> .no_update:
  1080 00006CD4 58                  <1> 	pop	ax
  1081 00006CD5 9D                  <1> 	popf
  1082                              <1> 
  1083                              <1> int_13_exit:
  1084 00006CD6 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  1085 00006CD9 B80102              <1> 	mov	ax,201h			; set IF and CF
  1086 00006CDC 7205                <1> 	jc	.set_error		; there is an error
  1087 00006CDE 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  1088 00006CE2 48                  <1> 	dec	ax			; clear CF in AX too
  1089                              <1> 
  1090                              <1> .set_error:
  1091 00006CE3 094614              <1> 	or	word [bp+int_13_flags],ax
  1092 00006CE6 5D                  <1> 	pop	bp
  1093 00006CE7 1F                  <1> 	pop	ds
  1094 00006CE8 5F                  <1> 	pop	di
  1095 00006CE9 5E                  <1> 	pop	si
  1096 00006CEA 5A                  <1> 	pop	dx
  1097 00006CEB 59                  <1> 	pop	cx
  1098 00006CEC 5B                  <1> 	pop	bx
  1099 00006CED 58                  <1> 	pop	ax
  1100 00006CEE CF                  <1> 	iret
  1101                              <1> 
  1102                              <1> ;=========================================================================
  1103                              <1> ; int_13_fn00: Reset disk system
  1104                              <1> ; Input:
  1105                              <1> ;	AH = 00h
  1106                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
  1107                              <1> ; Output:
  1108                              <1> ;	CF clear if successful
  1109                              <1> ;		AH = 00h - successful completion
  1110                              <1> ;	CF set on error
  1111                              <1> ;		AH = 20h - controller failure
  1112                              <1> ;		AH = 80h - timeout / device not ready
  1113                              <1> ; Note:
  1114                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
  1115                              <1> ;	normally will call this functions if bit 7 of DL is not set
  1116                              <1> ;-------------------------------------------------------------------------
  1117                              <1> int_13_fn00:
  1118 00006CEF E80600              <1> 	call	fdc_init
  1119 00006CF2 88264100            <1> 	mov	[fdc_last_error],ah	; save the error code
  1120 00006CF6 EBDE                <1> 	jmp	int_13_exit
  1121                              <1> 
  1122                              <1> ;=========================================================================
  1123                              <1> ; fdc_init - Initialize floppy disk controller
  1124                              <1> ; Input:
  1125                              <1> ;	none
  1126                              <1> ; Output:
  1127                              <1> ;	CF clear on success
  1128                              <1> ;		AH = 00h - successful completion
  1129                              <1> ;	CF set if error
  1130                              <1> ;		AH = 20h - controller failure
  1131                              <1> ;		AH = 80h - timeout / device not ready
  1132                              <1> ;-------------------------------------------------------------------------
  1133                              <1> fdc_init:
  1134 00006CF8 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
  1135 00006CFD E864A0              <1> 	call	fdc_reset		; reset FDC
  1136 00006D00 7257                <1> 	jc	fdc_init_error
  1137 00006D02 BAF403              <1> 	mov	dx,fdc_status_reg
  1138 00006D05 EC                  <1> 	in	al,dx
  1139 00006D06 A880                <1> 	test	al,80h
  1140 00006D08 7404                <1> 	jz	.try_again		; try again if FDC not ready
  1141 00006D0A A840                <1> 	test	al,40h
  1142 00006D0C 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
  1143                              <1> .try_again:
  1144 00006D0E E853A0              <1> 	call	fdc_reset
  1145 00006D11 BAF403              <1> 	mov	dx,fdc_status_reg
  1146 00006D14 EC                  <1> 	in	al,dx
  1147 00006D15 A880                <1> 	test	al,80h
  1148 00006D17 7440                <1> 	jz	fdc_init_error
  1149 00006D19 A840                <1> 	test	al,40h
  1150 00006D1B 753C                <1> 	jnz	fdc_init_error
  1151                              <1> .fdc_ready:
  1152 00006D1D B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
  1153 00006D1F E8949F              <1> 	call	fdc_write		; send the command
  1154 00006D22 7235                <1> 	jc	fdc_init_error
  1155 00006D24 E8DC9F              <1> 	call	fdc_read		; read ST0
  1156 00006D27 7230                <1> 	jc	fdc_init_error
  1157 00006D29 A24200              <1> 	mov	byte [fdc_ctrl_status],al	; save ST0
  1158 00006D2C 88C4                <1> 	mov	ah,al			; save AL to AH
  1159 00006D2E E8D29F              <1> 	call	fdc_read		; read current cylinder
  1160 00006D31 7226                <1> 	jc	fdc_init_error
  1161 00006D33 A24300              <1> 	mov	byte [fdc_ctrl_status+1],al	; save
  1162 00006D36 80E4C0              <1> 	and	ah,0C0h
  1163 00006D39 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
  1164 00006D3C 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
  1165                              <1> 
  1166                              <1> ; fall through to fdc_send_specify
  1167                              <1> 
  1168                              <1> ;=========================================================================
  1169                              <1> ; fdc_send_specify - Send specify command to FDC
  1170                              <1> ; Input:
  1171                              <1> ;	none
  1172                              <1> ; Output:
  1173                              <1> ;	CF clear on success
  1174                              <1> ;		AH = 00 - successful completion
  1175                              <1> ;	CF set if error
  1176                              <1> ;		AH = 20h - controller failure
  1177                              <1> ;	AX,CL,SI trashed
  1178                              <1> ; Note:
  1179                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
  1180                              <1> ;-------------------------------------------------------------------------
  1181                              <1> fdc_send_specify:
  1182                              <1> 
  1183 00006D3E 1E                  <1> 	push	ds
  1184 00006D3F 31C0                <1> 	xor	ax,ax
  1185 00006D41 8ED8                <1> 	mov	ds,ax
  1186 00006D43 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1187 00006D47 B003                <1> 	mov	al,3		 	; FDC Specify command
  1188 00006D49 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
  1189 00006D4B 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
  1190 00006D4E B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
  1191 00006D50 1F                  <1> 	pop	ds
  1192 00006D51 E8169F              <1> 	call	fdc_send_cmd		; send specify command to FDC
  1193 00006D54 7203                <1> 	jc	fdc_init_error
  1194 00006D56 B400                <1> 	mov	ah,fdc_e_success	; successful completion
  1195 00006D58 C3                  <1> 	ret
  1196                              <1> 
  1197                              <1> fdc_init_error:
  1198 00006D59 B420                <1> 	mov	ah,fdc_e_failure
  1199 00006D5B F9                  <1> 	stc
  1200 00006D5C C3                  <1> 	ret
  1201                              <1> 
  1202                              <1> ;=========================================================================
  1203                              <1> ; int_13_fn02 - Read disk sectors
  1204                              <1> ; int_13_fn03 - Write disk sectors
  1205                              <1> ; int_13_fn04 - Verify disk sectors
  1206                              <1> ; Input:
  1207                              <1> ;	AH = function
  1208                              <1> ;		02h - read
  1209                              <1> ;		03h - write
  1210                              <1> ;		04h - verify
  1211                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  1212                              <1> ;	CH = cylinder number
  1213                              <1> ;	CL = sector number
  1214                              <1> ;	DH = head number (0 or 1)
  1215                              <1> ;	DL = drive number (0 or 1)
  1216                              <1> ;	ES:BX -> data buffer
  1217                              <1> ; Output:
  1218                              <1> ;	CF clear if successful
  1219                              <1> ;		AH = 00h - successful completion
  1220                              <1> ;		AL = number of sectors transferred or verified
  1221                              <1> ;	CF set on error
  1222                              <1> ;		AH = error code
  1223                              <1> ;-------------------------------------------------------------------------
  1224                              <1> int_13_fn02:
  1225                              <1> int_13_fn03:
  1226                              <1> int_13_fn04:
  1227 00006D5D 80FA01              <1> 	cmp	dl,1
  1228 00006D60 7603E93F01          <1> 	ja	.invalid_drive
  1229 00006D65 BE9000              <1> 	mov	si,fdc_media_state
  1230 00006D68 52                  <1> 	push	dx
  1231 00006D69 B600                <1> 	mov	dh,00h
  1232 00006D6B 01D6                <1> 	add	si,dx			; SI -> drive media state
  1233 00006D6D 5A                  <1> 	pop	dx
  1234                              <1> 
  1235 00006D6E E828A0              <1> 	call	read_cmos_type		; get drive type in AL
  1236 00006D71 7303E92E01          <1> 	jc	.invalid_drive
  1237                              <1> 
  1238 00006D76 BF3F00              <1> 	mov	di,fdc_motor_state
  1239 00006D79 80257F              <1> 	and	byte [di],~fdc_write_flag ; read / verify operation
  1240 00006D7C 80FC03              <1> 	cmp	ah,03h			; write function
  1241 00006D7F 7503                <1> 	jne	.motor_on		; jump if not write function
  1242 00006D81 800D80              <1> 	or	byte [di],fdc_write_flag ; write / format operation
  1243                              <1> 
  1244                              <1> .motor_on:
  1245 00006D84 E87D9D              <1> 	call	fdc_motor_on
  1246                              <1> 
  1247 00006D87 E8349E              <1> 	call	fdc_disk_change
  1248 00006D8A 7303E91101          <1> 	jc	.error_end_io		; jump if disk change check failed
  1249                              <1> 
  1250 00006D8F F60410              <1> 	test	byte [si],fdc_m_established
  1251 00006D92 7508                <1> 	jnz	.select_rate		; jump if media type is established
  1252                              <1> 
  1253 00006D94 E822A0              <1> 	call	fdc_detect_media	; establish media type
  1254 00006D97 7303E90401          <1> 	jc	.error_end_io
  1255                              <1> 
  1256                              <1> .select_rate:
  1257 00006D9C E8D3A0              <1> 	call	fdc_select_rate		; select transfer rate
  1258                              <1> 	
  1259                              <1> ; send FDC specify command
  1260 00006D9F B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  1261                              <1> 					; 0BFh - specify byte 0 for 1.44M
  1262 00006DA2 803C17              <1> 	cmp	byte [si],fdc_m_1440	; 1.44M?
  1263 00006DA5 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  1264 00006DA7 B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  1265 00006DA9 803CD7              <1> 	cmp	byte [si],fdc_m_2880	; 2.88M?
  1266 00006DAC 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  1267 00006DAE B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  1268                              <1> 
  1269                              <1> .fdc_send_specify_cmd:
  1270 00006DB0 BE0200              <1> 	mov	si,2			; specify byte 1
  1271 00006DB3 B103                <1> 	mov	cl,3			; 3 bytes command
  1272 00006DB5 E8B29E              <1> 	call	fdc_send_cmd
  1273 00006DB8 7303E9E300          <1> 	jc	.error_end_io		; jump if failed to send command
  1274 00006DBD 1E                  <1> 	push	ds
  1275 00006DBE 31F6                <1> 	xor	si,si
  1276 00006DC0 8EDE                <1> 	mov	ds,si
  1277 00006DC2 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1278 00006DC6 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  1279 00006DC9 B400                <1> 	mov	ah,00h
  1280 00006DCB 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  1281 00006DCD 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  1282 00006DD0 FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  1283 00006DD2 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  1284 00006DD5 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  1285 00006DD7 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  1286                              <1> 
  1287                              <1> .calc_dma_count:
  1288 00006DDA 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  1289 00006DDD 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  1290 00006DE0 D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  1291 00006DE2 1F                  <1> 	pop	ds
  1292 00006DE3 48                  <1> 	dec	ax			; minus one byte
  1293 00006DE4 89C1                <1> 	mov	cx,ax			; ...count for DMA
  1294                              <1> 
  1295 00006DE6 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  1296 00006DE9 B046                <1> 	mov	al,46h			; DMA mode byte for read
  1297 00006DEB 80FC02              <1> 	cmp	ah,02h			; read function?
  1298 00006DEE 7409                <1> 	je	.configure_dma		; jump if read function
  1299 00006DF0 B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  1300 00006DF2 80FC03              <1> 	cmp	ah,03h			; write function?
  1301 00006DF5 7402                <1> 	je	.configure_dma		; jump if write function
  1302 00006DF7 B042                <1> 	mov	al,42h			; DMA mode byte for verification
  1303                              <1> 
  1304                              <1> .configure_dma:
  1305 00006DF9 E8109E              <1> 	call	fdc_configure_dma
  1306 00006DFC 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  1307 00006DFF 7303E99C00          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  1308                              <1> 
  1309 00006E04 E8469C              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  1310 00006E07 7303E98D00          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  1311                              <1> 
  1312 00006E0C 1E                  <1> 	push	ds
  1313 00006E0D 31C0                <1> 	xor	ax,ax
  1314 00006E0F 8ED8                <1> 	mov	ds,ax
  1315 00006E11 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1316 00006E15 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  1317 00006E18 88C8                <1> 	mov	al,cl			; AL = first sector number
  1318 00006E1A 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  1319 00006E1C 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  1320 00006E1F 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  1321 00006E22 1F                  <1> 	pop	ds
  1322                              <1> 
  1323 00006E23 BE9000              <1> 	mov	si,fdc_media_state
  1324 00006E26 B600                <1> 	mov	dh,00h
  1325 00006E28 01D6                <1> 	add	si,dx
  1326 00006E2A 8A14                <1> 	mov	dl,byte [si]		; drive media state
  1327 00006E2C B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  1328 00006E2E 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  1329 00006E31 7413                <1> 	je	.gap_set		; jump if 1.44M media
  1330 00006E33 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  1331 00006E36 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  1332 00006E38 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  1333 00006E3B 7409                <1> 	je	.gap_set		; jump if 2.88M media
  1334 00006E3D B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  1335 00006E3F 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  1336 00006E42 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  1337 00006E44 B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  1338                              <1> 	
  1339                              <1> .gap_set:
  1340 00006E46 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  1341 00006E49 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  1342 00006E4C 88F4                <1> 	mov	ah,dh			; head
  1343 00006E4E 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  1344 00006E50 D0E4                <1> 	shl	ah,1
  1345 00006E52 D0E4                <1> 	shl	ah,1
  1346 00006E54 08D4                <1> 	or	ah,dl			; FDC command byte 1
  1347 00006E56 B0E6                <1> 	mov	al,0E6h			; FDC Read command
  1348 00006E58 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  1349 00006E5C 7502                <1> 	jne	.send_command		; jump if not write 
  1350 00006E5E B0C5                <1> 	mov	al,0C5h			; FDC Write command
  1351                              <1> 
  1352                              <1> .send_command:
  1353 00006E60 B109                <1> 	mov	cl,9			; 9 bytes command
  1354 00006E62 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  1355 00006E67 E8009E              <1> 	call	fdc_send_cmd
  1356 00006E6A 722D                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  1357 00006E6C E82EA0              <1> 	call	fdc_wait_irq
  1358 00006E6F 7228                <1> 	jc	.error_fdc_get_result
  1359 00006E71 B107                <1> 	mov	cl,7
  1360 00006E73 E8599E              <1> 	call	fdc_get_result		; read result bytes
  1361 00006E76 7228                <1> 	jc	.error_end_io
  1362                              <1> 
  1363 00006E78 E8A99E              <1> 	call	fdc_get_error
  1364                              <1> 
  1365                              <1> .exit_end_io:
  1366 00006E7B 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  1367                              <1> ;	mov	dh,byte [bp+int_13_dl]	; DH = head
  1368 00006E7E E8129D              <1> 	call	fdc_end_io		; return number of last sector in BL
  1369 00006E81 08C0                <1> 	or	al,al
  1370 00006E83 7405                <1> 	jz	.zero_sectors		; jump if zero sectors were transferred
  1371 00006E85 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  1372 00006E87 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  1373                              <1> 
  1374                              <1> .zero_sectors:
  1375 00006E8A 08E4                <1> 	or	ah,ah
  1376 00006E8C 7401                <1> 	jz	.exit			; jump if no errors
  1377                              <1> 
  1378                              <1> .error:
  1379 00006E8E F9                  <1> 	stc				; indicate error
  1380                              <1> 
  1381                              <1> .exit:
  1382 00006E8F 88264100            <1> 	mov	byte [fdc_last_error],ah
  1383 00006E93 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  1384 00006E96 E91CFE              <1> 	jmp	int_13_upd_exit
  1385                              <1> 
  1386                              <1> .error_fdc_get_result:
  1387 00006E99 B107                <1> 	mov	cl,7
  1388 00006E9B 50                  <1> 	push	ax
  1389 00006E9C E8309E              <1> 	call	fdc_get_result		; read result bytes
  1390 00006E9F 58                  <1> 	pop	ax
  1391                              <1> 
  1392                              <1> .error_end_io:
  1393 00006EA0 B000                <1> 	mov	al,00h			; failure, no sectors transferred
  1394 00006EA2 EBD7                <1> 	jmp	.exit_end_io
  1395                              <1> 
  1396                              <1> .invalid_drive:
  1397 00006EA4 B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  1398 00006EA7 EBE5                <1> 	jmp	.error
  1399                              <1> 
  1400                              <1> 
  1401                              <1> ;=========================================================================
  1402                              <1> ; int_13_fn05 - Format track
  1403                              <1> ; Input:
  1404                              <1> ;	AH = 05h
  1405                              <1> ;	CH = track number
  1406                              <1> ;	DH = head number (0 or 1)
  1407                              <1> ;	DL = drive number (0 or 1)
  1408                              <1> ;	ES:BX -> address field buffer
  1409                              <1> ; Output:
  1410                              <1> ;	CF clear if successful
  1411                              <1> ;		AH = 00h - successful completion
  1412                              <1> ;	CF set on error
  1413                              <1> ;		AH = error code 
  1414                              <1> ;-------------------------------------------------------------------------
  1415                              <1> int_13_fn05:
  1416 00006EA9 80FA01              <1> 	cmp	dl,1
  1417 00006EAC 7603E99D00          <1> 	ja	.invalid_drive		; jump if invalid drive number
  1418 00006EB1 E8E59E              <1> 	call	read_cmos_type		; get drive type in AL
  1419 00006EB4 7303E99500          <1> 	jc	.invalid_drive
  1420 00006EB9 BE9000              <1> 	mov	si,fdc_media_state
  1421 00006EBC 52                  <1> 	push	dx
  1422 00006EBD B600                <1> 	mov	dh,00h
  1423 00006EBF 01D6                <1> 	add	si,dx			; SI -> drive media state
  1424 00006EC1 5A                  <1> 	pop	dx
  1425 00006EC2 803C00              <1> 	cmp	byte [si],0
  1426 00006EC5 7503E98000          <1> 	jz	.timeout		; jump if media type is not established
  1427 00006ECA 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; write operation
  1428 00006ECF E8329C              <1> 	call	fdc_motor_on
  1429 00006ED2 E8E99C              <1> 	call	fdc_disk_change		; read disk change line
  1430 00006ED5 726E                <1> 	jc	.error_end_io		; jump if disk change check failed
  1431 00006ED7 E8989F              <1> 	call	fdc_select_rate		; select transfer rate
  1432 00006EDA E861FE              <1> 	call	fdc_send_specify	; send FDC Specify command
  1433 00006EDD 1E                  <1> 	push	ds
  1434 00006EDE 31F6                <1> 	xor	si,si
  1435 00006EE0 8EDE                <1> 	mov	ds,si
  1436 00006EE2 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1437 00006EE6 8A4C04              <1> 	mov	cl,[si+4]		; sectors per track
  1438 00006EE9 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  1439 00006EEC 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  1440 00006EEF 1F                  <1> 	pop	ds
  1441 00006EF0 B500                <1> 	mov	ch,00h			; CX = sectors per track
  1442 00006EF2 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  1443 00006EF4 D1E1                <1> 	shl	cx,1
  1444 00006EF6 49                  <1> 	dec	cx	 		; minus one byte...
  1445 00006EF7 B04A                <1> 	mov	al,4Ah			; DMA mode byte for write
  1446 00006EF9 E8109D              <1> 	call	fdc_configure_dma
  1447 00006EFC 7247                <1> 	jc	.error_end_io		; DMA boundry crossed
  1448 00006EFE 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  1449 00006F01 56                  <1> 	push	si
  1450 00006F02 E8489B              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  1451 00006F05 5E                  <1> 	pop	si
  1452 00006F06 7234                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  1453                              <1> 
  1454 00006F08 88F4                <1> 	mov	ah,dh
  1455 00006F0A D0E4                <1> 	shl	ah,1
  1456 00006F0C D0E4                <1> 	shl	ah,1
  1457 00006F0E 08D4                <1> 	or	ah,dl
  1458 00006F10 B04D                <1> 	mov	al,4Dh			; FDC Format command
  1459                              <1> 
  1460 00006F12 B106                <1> 	mov	cl,6			; 6 byte command
  1461 00006F14 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ6
  1462 00006F19 E84E9D              <1> 	call	fdc_send_cmd
  1463 00006F1C 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  1464 00006F1E E87C9F              <1> 	call	fdc_wait_irq
  1465 00006F21 720A                <1> 	jc	.exit_end_io
  1466 00006F23 B107                <1> 	mov	cl,7
  1467 00006F25 E8A79D              <1> 	call	fdc_get_result		; read result bytes
  1468 00006F28 7203                <1> 	jc	.exit_end_io
  1469 00006F2A E8F79D              <1> 	call	fdc_get_error		; get error code
  1470                              <1> 
  1471                              <1> .exit_end_io:
  1472 00006F2D E8639C              <1> 	call	fdc_end_io
  1473 00006F30 08E4                <1> 	or	ah,ah
  1474 00006F32 7401                <1> 	jz	.exit			; jump if no errors
  1475                              <1> 
  1476                              <1> .error:
  1477 00006F34 F9                  <1> 	stc				; indicate error
  1478                              <1> 
  1479                              <1> .exit:
  1480 00006F35 88264100            <1> 	mov	byte [fdc_last_error],ah
  1481 00006F39 E979FD              <1> 	jmp	int_13_upd_exit
  1482                              <1> 
  1483                              <1> .error_fdc_get_result:
  1484 00006F3C B107                <1> 	mov	cl,7
  1485 00006F3E 50                  <1> 	push	ax
  1486 00006F3F E88D9D              <1> 	call	fdc_get_result		; read result bytes
  1487 00006F42 58                  <1> 	pop	ax
  1488 00006F43 EBE8                <1> 	jmp	.exit_end_io
  1489                              <1> 
  1490                              <1> .error_end_io:
  1491 00006F45 E84B9C              <1> 	call	fdc_end_io
  1492 00006F48 EBEA                <1> 	jmp	.error
  1493                              <1> 
  1494                              <1> .timeout:
  1495 00006F4A B480                <1> 	mov	ah,fdc_e_timeout
  1496 00006F4C EBE6                <1> 	jmp	.error
  1497                              <1> 
  1498                              <1> .invalid_drive:
  1499 00006F4E B401                <1> 	mov	ah,fdc_e_invalid
  1500 00006F50 EBE2                <1> 	jmp	.error
  1501                              <1> 
  1502                              <1> ;=========================================================================
  1503                              <1> ; int_0E - IRQ6 (FDC) service routine
  1504                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  1505                              <1> ;-------------------------------------------------------------------------
  1506 00006F52 FF<rep 5h>          <1> 	setloc	0EF57h
  1506          ******************  <1>  warning: Inserting 5 bytes [-w+user]
  1507                              <1> 
  1508                              <1> int_0E:
  1509 00006F57 50                  <1> 	push	ax
  1510 00006F58 1E                  <1> 	push	ds
  1511 00006F59 B84000              <1> 	mov	ax,biosdseg
  1512 00006F5C 8ED8                <1> 	mov	ds,ax
  1513 00006F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  1514 00006F63 1F                  <1> 	pop	ds
  1515 00006F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  1516 00006F66 E620                <1> 	out	pic1_reg0,al
  1517 00006F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  1518 00006F6B CD15                <1> 	int	15h
  1519 00006F6D 58                  <1> 	pop	ax
  1520 00006F6E CF                  <1> 	iret
  1521                              <1> 
  1522                              <1> ;=========================================================================
  1523                              <1> ; Disk parameter tables in INT 1Eh format
  1524                              <1> ; Byte 0: First byte for specify command:
  1525                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  1526                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  1527                              <1> ; Byte 1: Second byte for specify command:
  1528                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  1529                              <1> ;	bit 0: non-DMA mode (always 0)
  1530                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  1531                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  1532                              <1> ; Byte 4: sectors per track
  1533                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  1534                              <1> ; Byte 6: special sector size (0FFh - not used)
  1535                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  1536                              <1> ; Byte 8: format filler byte (default 0F6h)
  1537                              <1> ; Byte 9: head settle time in milliseconds
  1538                              <1> ; Byte A: motor start time, in 1/8 seconds
  1539                              <1> ; Byte B: number of cylinders minus one
  1540                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  1541                              <1> ;-------------------------------------------------------------------------
  1542                              <1> media_360_in_360:
  1543 00006F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  1543 00006F78 0F08                <1>
  1544 00006F7A 2780                <1> 	db	27h, 80h
  1545                              <1> media_1200:
  1546 00006F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  1546 00006F85 0F08                <1>
  1547 00006F87 4F00                <1> 	db	4Fh, 00h
  1548                              <1> media_720:
  1549 00006F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  1549 00006F92 0F08                <1>
  1550 00006F94 4F80                <1> 	db	4Fh, 80h
  1551                              <1> media_1440:
  1552 00006F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  1552 00006F9F 0F08                <1>
  1553 00006FA1 4F00                <1> 	db	4Fh, 00h
  1554                              <1> media_360_in_1200:
  1555 00006FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  1555 00006FAC 0F08                <1>
  1556 00006FAE 2740                <1> 	db	27h, 40h
  1557                              <1> media_2880:
  1558 00006FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  1558 00006FB9 0F08                <1>
  1559 00006FBB 4FC0                <1> 	db	4Fh, 0C0h
  1560                              <1> 
  1561                              <1> ;=========================================================================
  1562                              <1> ; Disk parameter table for IBM compatibility
  1563                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  1564                              <1> ;-------------------------------------------------------------------------
  1565 00006FBD FF<rep Ah>          <1> 	setloc	0EFC7h
  1565          ******************  <1>  warning: Inserting 10 bytes [-w+user]
  1566                              <1> int_1E:
  1567 00006FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  1567 00006FD0 0F08                <1>
   926                                  %include	"printer2.inc"		; INT 17
   927                              <1> ;=========================================================================
   928                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
   929                              <1> ;       INT 17h, function AH=00h
   930                              <1> ;	INT 17h, function AH=02h
   931                              <1> ;	- see printer1.inc for other INT 17h functions
   932                              <1> ;-------------------------------------------------------------------------
   933                              <1> ;
   934                              <1> ; Compiles with NASM 2.11.08, might work with other versions
   935                              <1> ;
   936                              <1> ; Copyright (C) 2010 - 2020 Sergey Kiselev.
   937                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   938                              <1> ;
   939                              <1> ; This program is free software: you can redistribute it and/or modify
   940                              <1> ; it under the terms of the GNU General Public License as published by
   941                              <1> ; the Free Software Foundation, either version 3 of the License, or
   942                              <1> ; (at your option) any later version.
   943                              <1> ;
   944                              <1> ; This program is distributed in the hope that it will be useful,
   945                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   946                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   947                              <1> ; GNU General Public License for more details.
   948                              <1> ;
   949                              <1> ; You should have received a copy of the GNU General Public License
   950                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   951                              <1> ;
   952                              <1> ;=========================================================================
   953                              <1> 
   954                              <1> ;=========================================================================
   955                              <1> ; int_17  - BIOS Printer Services
   956                              <1> ;-------------------------------------------------------------------------
   957                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
   958                              <1> int_17:
   959 00006FD2 FB                  <1> 	sti
   960 00006FD3 53                  <1> 	push	bx
   961 00006FD4 52                  <1> 	push	dx
   962 00006FD5 56                  <1> 	push	si
   963 00006FD6 1E                  <1> 	push	ds
   964 00006FD7 BB4000              <1> 	mov	bx,biosdseg
   965 00006FDA 8EDB                <1> 	mov	ds,bx
   966 00006FDC 83FA03              <1> 	cmp	dx,num_parallel
   967 00006FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
   968 00006FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
   969 00006FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
   970 00006FE6 89D3                <1> 	mov	bx,dx
   971 00006FE8 D1E3                <1> 	shl	bx,1
   972 00006FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
   973 00006FED 09D2                <1> 	or	dx,dx
   974 00006FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
   975                              <1> 
   976 00006FF1 88C3                <1> 	mov	bl,al			; save AL to BL
   977                              <1> 
   978 00006FF3 08E4                <1> 	or	ah,ah
   979 00006FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
   980 00006FF7 FECC                <1> 	dec	ah
   981 00006FF9 7503E99FA4          <1> 	jz	int_17_fn01		; AH = 01h
   982 00006FFE FECC                <1> 	dec	ah
   983 00007000 7436                <1> 	jz	int_17_fn02		; AH = 02h
   984                              <1> 
   985                              <1> int_17_exit:
   986 00007002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
   987 00007005 88D8                <1> 	mov	al,bl			; restore AL
   988                              <1> 
   989                              <1> int_17_error:
   990 00007007 1F                  <1> 	pop	ds
   991 00007008 5E                  <1> 	pop	si
   992 00007009 5A                  <1> 	pop	dx
   993 0000700A 5B                  <1> 	pop	bx
   994 0000700B CF                  <1> 	iret
   995                              <1> 
   996                              <1> ;=========================================================================
   997                              <1> ; int_17_fn00 - Print character
   998                              <1> ; Input:
   999                              <1> ;	AH = 0 - function 00h - print character
  1000                              <1> ;	AL = character to print
  1001                              <1> ;	DX = printer port number (0-2)
  1002                              <1> ; Output:
  1003                              <1> ;	AH = printer status:
  1004                              <1> ;		bit 0	= 1	- timeout error
  1005                              <1> ;		bit 1,2		- reserved
  1006                              <1> ;		bit 3	= 1	- I/O error
  1007                              <1> ;		bit 4	= 1	- printed selected
  1008                              <1> ;		bit 5	= 1	- out of paper
  1009                              <1> ;		bit 6	= 1	- acknowledge from printer
  1010                              <1> ;		bit 7	= 1	- printer not busy
  1011                              <1> ;-------------------------------------------------------------------------
  1012                              <1> int_17_fn00:
  1013 0000700C EE                  <1> 	out	dx,al			; output the character to the data port
  1014 0000700D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  1015                              <1> 					; OPTIMIZATION:
  1016                              <1> 					; prn_stat_reg = prn_data_reg + 1
  1017 0000700E EC                  <1> 	in	al,dx			; read status
  1018 0000700F 88C4                <1> 	mov	ah,al			; AH = printer status
  1019 00007011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  1020 00007014 750C                <1>         jnz     .not_busy
  1021                              <1> 
  1022 00007016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  1023 00007019 CD15                <1> 	int	15h			; call OS hook
  1024                              <1> 
  1025 0000701B B780                <1> 	mov	bh,prn_stat_busy
  1026 0000701D E8BCA3              <1> 	call	wait_for_port		; wait for printer to be ready
  1027 00007020 750E                <1> 	jnz	.timeout		; timeout had occured
  1028                              <1> 
  1029                              <1> .not_busy:
  1030 00007022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  1031                              <1> 					; OPTIMIZATION:
  1032                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  1033 00007023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  1034 00007025 EE                  <1> 	out	dx,al			; activate strobe
  1035 00007026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  1036 00007028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  1037 0000702A EE                  <1> 	out	dx,al			; de-activate strobe
  1038 0000702B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  1039 0000702E EBD2                <1> 	jmp	int_17_exit
  1040                              <1> 
  1041                              <1> .timeout:
  1042 00007030 80E4F8              <1> 	and	ah,prn_stat_bits
  1043 00007033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  1044 00007036 EBCA                <1> 	jmp	int_17_exit
  1045                              <1> 
  1046                              <1> ;=========================================================================
  1047                              <1> ; int_17_fn02 - Return printer status
  1048                              <1> ; Input:
  1049                              <1> ;	AH = 2 - function 02h - return printer status
  1050                              <1> ;	DX = printer port number (0-2)
  1051                              <1> ; Output:
  1052                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  1053                              <1> ;-------------------------------------------------------------------------
  1054                              <1> int_17_fn02:
  1055 00007038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  1056                              <1> 					; OPTIMIZATION:
  1057                              <1> 					; prn_stat_reg = prn_data_reg + 1
  1058                              <1> int_17_status:
  1059 00007039 EC                  <1> 	in	al,dx			; read the status
  1060 0000703A 88C4                <1> 	mov	ah,al			; move status to AH
  1061 0000703C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  1062 0000703F EBC1                <1> 	jmp	int_17_exit
   927                                  %include	"video.inc"		; INT 10
   928                              <1> ;=========================================================================
   929                              <1> ; video.inc - BIOS video services
   930                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
   931                              <1> ;-------------------------------------------------------------------------
   932                              <1> ;
   933                              <1> ;=========================================================================
   934                              <1> 
   935                              <1> ;-------------------------------------------------------------------------
   936                              <1> ; CRTC registers
   937                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
   938                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
   939                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
   940                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
   941                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
   942                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
   943                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
   944                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
   945                              <1> 
   946                              <1> ;-------------------------------------------------------------------------
   947                              <1> ; control characters
   948                              <1> bel	equ	07h
   949                              <1> bs	equ	08h
   950                              <1> lf	equ	0Ah
   951                              <1> cr	equ	0Dh
   952                              <1> 
   953 00007041 FF<rep 4h>          <1> 	setloc	0F045h			; int 10 functions table
   953          ******************  <1>  warning: Inserting 4 bytes [-w+user]
   954                              <1> 
   955                              <1> int_10_dispatch:
   956 00007045 [0471]              <1> 	dw	int_10_fn00		; Set video mode
   957 00007047 [AF71]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
   958 00007049 [B971]              <1> 	dw	int_10_fn02		; Set cursor position
   959 0000704B [DC71]              <1> 	dw	int_10_fn03		; Get cursor position and shape
   960 0000704D [F071]              <1> 	dw	int_10_fn04		; Read light pen position
   961 0000704F [8372]              <1> 	dw	int_10_fn05		; Set active display page
   962 00007051 [AE72]              <1> 	dw	int_10_fn06		; Scroll up window
   963 00007053 [AE72]              <1> 	dw	int_10_fn07		; Scroll down window
   964 00007055 [3474]              <1> 	dw	int_10_fn08		; Read character and attribute
   965 00007057 [3474]              <1> 	dw	int_10_fn09		; Write character and attribute
   966 00007059 [3474]              <1> 	dw	int_10_fn0A		; Write character only
   967 0000705B [0F76]              <1> 	dw	int_10_fn0B		; Set background color or palette
   968 0000705D [3976]              <1> 	dw	int_10_fn0C		; Write graphics pixel
   969 0000705F [7176]              <1> 	dw	int_10_fn0D		; Read graphics pixel
   970 00007061 [8F76]              <1> 	dw	int_10_fn0E		; Teletype output
   971 00007063 [0477]              <1> 	dw	int_10_fn0F		; Get current video mode
   972                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
   973                              <1> 
   974                              <1> 
   975                              <1> ;-------------------------------------------------------------------------
   976                              <1> ; offsets for registers on stack
   977                              <1> 
   978                              <1> int_10_ax	equ	0
   979                              <1> int_10_al	equ	int_10_ax
   980                              <1> int_10_ah	equ	int_10_ax+1
   981                              <1> int_10_bx	equ	int_10_ax+2
   982                              <1> int_10_bl	equ	int_10_bx
   983                              <1> int_10_bh	equ	int_10_bx+1
   984                              <1> int_10_cx	equ	int_10_bx+2
   985                              <1> int_10_ch	equ	int_10_cx+1
   986                              <1> int_10_dx	equ	int_10_cx+2
   987                              <1> 
   988                              <1> ;=========================================================================
   989                              <1> ; int_10 - BIOS video services
   990                              <1> ; Input:
   991                              <1> ;	AH - Function
   992                              <1> ;		00h - Set video mode
   993                              <1> ;		01h - Set text mode cursor shape
   994                              <1> ;		02h - Set cursor position
   995                              <1> ;		03h - Get cursor position and shape
   996                              <1> ;		04h - Read light pen position
   997                              <1> ;		05h - Select active display page
   998                              <1> ;		06h - Scroll up window
   999                              <1> ;		07h - Scroll down window
  1000                              <1> ;		08h - Read character and attribute at cursor position
  1001                              <1> ;		09h - Write character and attribute at cursor position
  1002                              <1> ;		0Ah - Write character only at cursor position
  1003                              <1> ;		0Bh -
  1004                              <1> ;			BH = 00h - Set background/border color
  1005                              <1> ;			BH = 01h - Set palette
  1006                              <1> ;		0Ch - Write graphics pixel
  1007                              <1> ;		0Dh - Read graphics pixel
  1008                              <1> ;		0Eh - Teletype output 电传打字输出
  1009                              <1> ;		0Fh - Get current video mode
  1010                              <1> ;-------------------------------------------------------------------------
  1011                              <1> 	setloc	0F065h			; int 10 Entry Point
  1012                              <1> int_10:
  1013 00007065 FB                  <1> 	sti
  1014 00007066 FC                  <1> 	cld				;  ...strings auto-increment
  1015 00007067 55                  <1> 	push	bp
  1016 00007068 06                  <1> 	push	es
  1017 00007069 1E                  <1> 	push	ds
  1018 0000706A 56                  <1> 	push	si
  1019 0000706B 57                  <1> 	push	di
  1020 0000706C 52                  <1> 	push	dx
  1021 0000706D 51                  <1> 	push	cx
  1022 0000706E 53                  <1> 	push	bx
  1023 0000706F 50                  <1> 	push	ax
  1024 00007070 BB4000              <1> 	mov	bx,biosdseg
  1025 00007073 8EDB                <1> 	mov	ds,bx
  1026 00007075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  1027 00007079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  1028 0000707C BB00B8              <1> 	mov	bx,0B800h			; assume CGA, BX = CGA video segment
  1029 0000707F 7202                <1> 	jb	.color			; it is CGA
  1030 00007081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  1031                              <1> 
  1032                              <1> .color:
  1033 00007083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  1034 00007085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  1035 00007087 80FC10              <1> 	cmp	ah,int_10_num_func		; dispatch table size
  1036 0000708A 730B                <1> 	jae	.exit			; invalid function
  1037 0000708C B700                <1> 	mov	bh,0
  1038 0000708E 88E3                <1> 	mov	bl,ah
  1039 00007090 D1E3                <1> 	shl	bx,1
  1040 00007092 2EFF97[4570]        <1>     cs	call	near [int_10_dispatch+bx]
  1041                              <1> 
  1042                              <1> .exit:
  1043 00007097 58                  <1> 	pop	ax
  1044 00007098 5B                  <1> 	pop	bx
  1045 00007099 59                  <1> 	pop	cx
  1046 0000709A 5A                  <1> 	pop	dx
  1047 0000709B 5F                  <1> 	pop	di
  1048 0000709C 5E                  <1> 	pop	si
  1049 0000709D 1F                  <1> 	pop	ds
  1050 0000709E 07                  <1> 	pop	es
  1051 0000709F 5D                  <1> 	pop	bp
  1052 000070A0 CF                  <1> 	iret
  1053                              <1> 
  1054                              <1> 
  1055                              <1> ;=========================================================================
  1056                              <1> ; int_1D - Video parameters tables
  1057                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  1058                              <1> ; video mode initialization
  1059                              <1> ;-------------------------------------------------------------------------
  1060 000070A1 FF<rep 3h>          <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  1060          ******************  <1>  warning: Inserting 3 bytes [-w+user]
  1061                              <1> int_1D:
  1062                              <1> 	; CGA test 40x25 modes
  1063 000070A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  1064 000070AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  1065                              <1> 
  1066                              <1> 	; CGA text 80x25 modes
  1067 000070B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  1068 000070BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  1069                              <1> 
  1070                              <1> 	; CGA graphics modes
  1071 000070C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  1072 000070CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  1073                              <1> 
  1074                              <1> 	; MDA text 80x25 mode
  1075 000070D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  1076 000070DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  1077                              <1> 
  1078                              <1> page_size:
  1079 000070E4 0008                <1> 	dw	0800h			; text 40x25 mode
  1080 000070E6 0010                <1> 	dw	1000h			; text 80x25 mode
  1081 000070E8 0040                <1> 	dw	4000h			; graphics modes
  1082 000070EA 0040                <1> 	dw	4000h
  1083                              <1> 
  1084                              <1> columns:
  1085 000070EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  1086 000070EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  1087 000070F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  1088 000070F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  1089                              <1> 
  1090 000070F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  1091                              <1> 
  1092 000070FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  1093                              <1> 
  1094                              <1> ;=========================================================================
  1095                              <1> ; int_10_fn00 - Set video mode
  1096                              <1> ; Input:
  1097                              <1> ;	AH = 00h
  1098                              <1> ;	AL = video mode
  1099                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  1100                              <1> ;		01h - CGA - text 40x25, 16 colors
  1101                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  1102                              <1> ;		03h - CGA - text 80x25, 16 colors
  1103                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  1104                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  1105                              <1> ;		06h - CGA - graphics 640x200, monochrome
  1106                              <1> ;		07h - MDA - text 80x25, monochrome
  1107                              <1> ;-------------------------------------------------------------------------
  1108                              <1> int_10_fn00:
  1109 00007104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  1110                              <1> 					; assume CGA mode
  1111 00007107 B900B8              <1> 	mov	cx,0B800h			; CGA video memory segment
  1112 0000710A BAD403              <1> 	mov	dx,3D4h			; port for MC6845 CRTC address register
  1113 0000710D B000                <1> 	mov	al,0
  1114 0000710F 80FB07              <1> 	cmp	bl,07h
  1115 00007112 7206                <1> 	jb	.color			; jump if CGA/color mode
  1116                              <1> 					; set MDA mode
  1117 00007114 B5B0                <1> 	mov	ch,0B0h			; MDA video memory segment
  1118 00007116 B2B4                <1> 	mov	dl,0B4h 			; port for MC6845 CRTC address register
  1119 00007118 FEC0                <1> 	inc	al
  1120                              <1> 
  1121                              <1> .color:
  1122 0000711A 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  1123 0000711C 89166300            <1> 	mov	word [video_port],dx		; Save current CRTC display port
  1124 00007120 80C204              <1> 	add	dl,4
  1125 00007123 EE                  <1> 	out	dx,al			; Reset the video
  1126 00007124 881E4900            <1> 	mov	byte [video_mode],bl		; Save current CRTC mode
  1127 00007128 B700                <1> 	mov	bh,0
  1128 0000712A 53                  <1> 	push	bx
  1129 0000712B 06                  <1> 	push	es
  1130 0000712C 31C0                <1> 	xor	ax,ax
  1131 0000712E 8EC0                <1> 	mov	es,ax			; Load interrupt table segment to ES
  1132 00007130 26C4367400          <1>     es	les	si,[1Dh*4]			; Load video parameters table
  1133                              <1> 					; (INT 1Dh vector) to ES:SI
  1134 00007135 2E8A9F[FC70]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get BL for indexing into int_1D
  1135 0000713A 01DE                <1> 	add	si,bx
  1136                              <1> 
  1137 0000713C 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] 	; cursor shape from INT 1Dh table
  1138 00007140 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  1139 00007142 890E6000            <1> 	mov	word [video_cur_shape],cx 	; store cursor shape
  1140                              <1> 
  1141 00007146 B91000              <1> 	mov	cx,10h			; Sixteen values to send
  1142                              <1> 
  1143                              <1> .setup_crt_loop:
  1144 00007149 268A04              <1>     es	mov	al,byte [si]			; Value to send in SI
  1145 0000714C E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  1146 0000714F FEC4                <1> 	inc	ah			;  ...bump count
  1147 00007151 46                  <1> 	inc	si			;  ...point to next
  1148 00007152 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  1149 00007154 07                  <1> 	pop	es
  1150 00007155 31FF                <1> 	xor	di,di
  1151 00007157 B90020              <1> 	mov	cx,2000h			; video memory size for CGA
  1152 0000715A 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  1153 0000715C E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  1154 0000715F 7208                <1> 	jc	.clear_screen		; jump if graphics mode
  1155 00007161 7503                <1> 	jnz	.text_fill			; jump if CGA mode
  1156 00007163 B90008              <1> 	mov	cx,0800h 			; video memory size for MDA
  1157                              <1> 
  1158                              <1> .text_fill:
  1159 00007166 B82007              <1> 	mov	ax,07h << 8 | ' '		; fill word for test mode
  1160                              <1> 
  1161                              <1> .clear_screen:
  1162 00007169 F3AB                <1> 	repz	stosw			; clear screen with fill word
  1163                              <1> 
  1164 0000716B 8B166300            <1> 	mov	dx,word [video_port]		; Get the port
  1165 0000716F 80C204              <1> 	add	dl,4
  1166 00007172 5B                  <1> 	pop	bx
  1167 00007173 2E8A87[F470]        <1>     cs	mov	al,byte [bx+MODES]		; Load data to set for mode
  1168 00007178 EE                  <1> 	out	dx,al			;  ...and send it
  1169 00007179 A26500              <1> 	mov	byte [video_mode_reg],al 	;  ...then save active data
  1170 0000717C 42                  <1> 	inc	dx
  1171 0000717D B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  1172 0000717F 80FB06              <1> 	cmp	bl,6			;  ...correct?
  1173 00007182 7502                <1> 	jnz	.set_palette
  1174 00007184 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  1175                              <1> 
  1176                              <1> .set_palette:
  1177 00007186 A26600              <1> 	mov	byte [video_palet_reg],al 	;  ...save palette
  1178 00007189 EE                  <1> 	out	dx,al			;  ...send palette
  1179                              <1> 
  1180 0000718A 8CD8                <1> 	mov	ax,ds
  1181 0000718C 8EC0                <1> 	mov	es,ax
  1182 0000718E 31C0                <1> 	xor	ax,ax
  1183 00007190 A26200              <1> 	mov	byte [video_page],al		;  ...active page=page 0
  1184 00007193 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  1185 00007196 BF4E00              <1> 	mov	di,video_page_offt
  1186 00007199 F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  1187                              <1> 
  1188 0000719B 2E8A87[EC70]        <1>     cs	mov	al,byte [bx+columns]		; Get display width
  1189 000071A0 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  1190 000071A3 80E3FE              <1> 	and	bl,0FEh			; Clear the LSB to get an index
  1191                              <1> 					; to 16-bit word page_size table
  1192                              <1> 					; FIXME: It returns graphics mode page
  1193                              <1> 					; size for mode 7. Probably not
  1194                              <1> 					; critical, as MDA has only one page
  1195 000071A6 2E8B87[E470]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  1196 000071AB A34C00              <1> 	mov	word [video_page_size],ax 	;  ...save it
  1197 000071AE C3                  <1> 	ret
  1198                              <1> 
  1199                              <1> ;=========================================================================
  1200                              <1> ; int_10_fn01 - Set text-mode cursor shape
  1201                              <1> ; Input:
  1202                              <1> ;	AH = 01h
  1203                              <1> ;	CH = cursor scan line start
  1204                              <1> ;	CL = cursor scan line end
  1205                              <1> ; Output:
  1206                              <1> ;	none
  1207                              <1> ;-------------------------------------------------------------------------
  1208                              <1> int_10_fn01:
  1209 000071AF 890E6000            <1> 	mov	word [video_cur_shape],cx 	; save cursor shape to BIOS data area
  1210 000071B3 B40A                <1> 	mov	ah,crtc_cur_start		; select CRTC cursor shape registers
  1211 000071B5 E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  1212 000071B8 C3                  <1> 	ret
  1213                              <1> 
  1214                              <1> ;=========================================================================
  1215                              <1> ; int_10_fn02 - Set cursor position
  1216                              <1> ; Input:
  1217                              <1> ;	AH = 02h
  1218                              <1> ;	BH = page number
  1219                              <1> ;	DH = cursor row (00h is top)
  1220                              <1> ;	DL = cursor column (00h is left)
  1221                              <1> ; Output:
  1222                              <1> ;	none
  1223                              <1> ;-------------------------------------------------------------------------
  1224                              <1> int_10_fn02:
  1225 000071B9 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  1226 000071BC 381E6200            <1> 	cmp	byte [video_page],bl		; is it on current page?
  1227 000071C0 7512                <1> 	jne	bios_set_cur_pos		; if not visible only update BIOS data
  1228                              <1> 
  1229                              <1> ;=========================================================================
  1230                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  1231                              <1> ;	BL = page
  1232                              <1> ;	DH = cursor row (00h is top)
  1233                              <1> ;	DL = cursor column (00h is left)
  1234                              <1> ;-------------------------------------------------------------------------
  1235                              <1> set_cur_pos:
  1236 000071C2 89D0                <1> 	mov	ax,dx			; AX = cursor position
  1237 000071C4 E8AA05              <1> 	call	vid_position_to_offset	; AX - offset
  1238 000071C7 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  1239 000071CB D1E8                <1> 	shr	ax,1
  1240 000071CD 89C1                <1> 	mov	cx,ax
  1241 000071CF B40E                <1> 	mov	ah,crtc_cur_pos_hi		; CRCT cursor location high register
  1242 000071D1 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  1243                              <1> bios_set_cur_pos:
  1244 000071D4 B700                <1> 	mov	bh,0
  1245 000071D6 D0E3                <1> 	shl	bl,1			; index to words table
  1246 000071D8 895750              <1> 	mov	word [bx+video_cur_pos],dx 	; save position to BIOS data area
  1247 000071DB C3                  <1> 	ret
  1248                              <1> 
  1249                              <1> ;=========================================================================
  1250                              <1> ; int_10_fn03 - Get cursor position and shape
  1251                              <1> ; Input:
  1252                              <1> ;	AH = 03h
  1253                              <1> ;	BH = page number
  1254                              <1> ; Output:
  1255                              <1> ;	CH = cursor start scan line
  1256                              <1> ;	CL = cursor end scan line
  1257                              <1> ;	DH = cursor row (00h is top)
  1258                              <1> ;	DL = cursor column (00h is left)
  1259                              <1> ;-------------------------------------------------------------------------
  1260                              <1> int_10_fn03:
  1261 000071DC B700                <1> 	mov	bh,0
  1262 000071DE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  1263 000071E1 D0E3                <1> 	shl	bl,1
  1264 000071E3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] 	; get current cursor position
  1265 000071E6 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  1266 000071E9 A16000              <1> 	mov	ax,word [video_cur_shape]  	; get cursor shape
  1267 000071EC 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  1268 000071EF C3                  <1> 	ret
  1269                              <1> 
  1270                              <1> ;=========================================================================
  1271                              <1> ; int_10_fn04 - Read light pen position
  1272                              <1> ; Input:
  1273                              <1> ;	AH = 04h
  1274                              <1> ; Output:
  1275                              <1> ;	AH - light pen trigger flag
  1276                              <1> ;		00h not down/triggered
  1277                              <1> ;		01h down/triggered
  1278                              <1> ;	If light pen is triggered:
  1279                              <1> ;		DH = character row
  1280                              <1> ;		DL = character column
  1281                              <1> ;		CH = pixel row
  1282                              <1> ;		BX = pixel column
  1283                              <1> ;-------------------------------------------------------------------------
  1284                              <1> int_10_fn04:
  1285 000071F0 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  1286 000071F4 8B166300            <1> 	mov	dx,word [video_port]
  1287 000071F8 80C206              <1> 	add	dl,6			; CRTC status register
  1288 000071FB EC                  <1> 	in	al,dx			; read it
  1289 000071FC A804                <1> 	test	al,4			; test light pen switch bit
  1290 000071FE 7472                <1> 	jz	.reset_pen			; reset pen and return if switch is off
  1291 00007200 A802                <1> 	test	al,2			; test light pen tigger bit
  1292 00007202 7501                <1> 	jnz	.read_pen			; continue if triggered
  1293 00007204 C3                  <1> 	ret				; not triggered - return
  1294                              <1> 
  1295                              <1> .read_pen:
  1296 00007205 8B166300            <1> 	mov	dx,word [video_port]		; CRTC index register
  1297 00007209 B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  1298 0000720B EE                  <1> 	out	dx,al			; select it
  1299 0000720C 42                  <1> 	inc	dx			; CRTC data register
  1300 0000720D EC                  <1> 	in	al,dx			; read high byte of pen position
  1301 0000720E 88C4                <1> 	mov	ah,al
  1302 00007210 4A                  <1> 	dec	dx			; CRTC index register
  1303 00007211 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  1304 00007213 EE                  <1> 	out	dx,al			; select it
  1305 00007214 42                  <1> 	inc	dx			; CRTC data register
  1306 00007215 EC                  <1> 	in	al,dx			; read low byte of pen position
  1307                              <1> 
  1308 00007216 B700                <1> 	mov	bh,0
  1309 00007218 8A1E4900            <1> 	mov	bl,byte [video_mode]		; get current video mode
  1310 0000721C 2E8A9F[7B72]        <1>     cs	mov	bl,byte [bx+.correction] 	; light pen correction factor
  1311 00007221 29D8                <1> 	sub	ax,bx
  1312 00007223 7902                <1> 	jns	.1
  1313 00007225 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  1314                              <1> 
  1315                              <1> .1:
  1316 00007227 E8ED04              <1> 	call	vid_check_mode		; check video mode
  1317 0000722A 7325                <1> 	jnc	.text			; calculate character position if text
  1318 0000722C B228                <1> 	mov	dl,40			; divide by 40
  1319 0000722E F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  1320 00007230 B700                <1> 	mov	bh,0
  1321 00007232 88E3                <1> 	mov	bl,ah
  1322 00007234 B103                <1> 	mov	cl,3
  1323 00007236 D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  1324 00007238 88C5                <1> 	mov	ch,al
  1325 0000723A D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  1326 0000723C 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  1327 0000723E 88C6                <1> 	mov	dh,al
  1328 00007240 D0EE                <1> 	shr	dh,1
  1329 00007242 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  1330 00007244 803E490006          <1> 	cmp	byte [video_mode],6		; check for 640x200 mode
  1331 00007249 751A                <1> 	jnz	.exit
  1332 0000724B D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  1333 0000724D D0E2                <1> 	shl	dl,1			; same or character column
  1334 0000724F EB14                <1> 	jmp	.exit
  1335                              <1> 
  1336                              <1> .text:
  1337 00007251 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  1338 00007255 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  1339 00007257 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  1340 00007259 B103                <1> 	mov	cl,3
  1341 0000725B D2E4                <1> 	shl	ah,cl
  1342 0000725D 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  1343 0000725F B700                <1> 	mov	bh,0
  1344 00007261 88C3                <1> 	mov	bl,al
  1345 00007263 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  1346                              <1> 
  1347                              <1> .exit:
  1348 00007265 C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  1349 00007269 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  1350 0000726C 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  1351 0000726F 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  1352                              <1> 
  1353                              <1> .reset_pen:
  1354 00007272 8B166300            <1> 	mov	dx,word [video_port]		; Get port of active CRTC card
  1355 00007276 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  1356 00007279 EE                  <1> 	out	dx,al			; reset it
  1357 0000727A C3                  <1> 	ret
  1358                              <1> 
  1359                              <1> .correction:
  1360 0000727B 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4		; light pen correction
  1361                              <1> 
  1362                              <1> ;=========================================================================
  1363                              <1> ; int_10_fn05 - Select active display page
  1364                              <1> ; Input:
  1365                              <1> ;	AH = 05h
  1366                              <1> ;	AL - new page number (00h is the first page)
  1367                              <1> ; Output:
  1368                              <1> ;	none
  1369                              <1> ;-------------------------------------------------------------------------
  1370                              <1> int_10_fn05:
  1371 00007283 A26200              <1> 	mov	byte [video_page],al		; update page number in BIOS data area
  1372 00007286 88C3                <1> 	mov	bl,al			; also copy it to BL
  1373 00007288 B400                <1> 	mov	ah,0
  1374 0000728A F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  1375 0000728E A34E00              <1> 	mov	word [video_page_offt],ax 	; save the offset
  1376 00007291 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  1377 00007293 89C1                <1> 	mov	cx,ax			; save a copy to CX
  1378 00007295 B40C                <1> 	mov	ah,crtc_offset_hi		; CRTC start address high register
  1379 00007297 E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  1380                              <1> 
  1381 0000729A B700                <1> 	mov	bh,0
  1382 0000729C D1E3                <1> 	shl	bx,1
  1383 0000729E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] 	; AX - cursor position for new page
  1384 000072A1 E8CD04              <1> 	call	vid_position_to_offset	; AX - offset relative to start of page
  1385 000072A4 D1E8                <1> 	shr	ax,1
  1386 000072A6 01C1                <1> 	add	cx,ax			; add to the page offset
  1387 000072A8 B40E                <1> 	mov	ah,crtc_cur_pos_hi		; CRCT cursor location high register
  1388 000072AA E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  1389 000072AD C3                  <1> 	ret
  1390                              <1> 
  1391                              <1> ;=========================================================================
  1392                              <1> ; int_10_fn06 - scroll up window
  1393                              <1> ; int_10_fn07 - scroll down window
  1394                              <1> ; Input:
  1395                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  1396                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  1397                              <1> ;	BH = attribute used to write blank rows at bottom of window
  1398                              <1> ;	CH,CL = row,column of window's upper left corner
  1399                              <1> ;	DH,DL = row,column of window's lower right corner
  1400                              <1> ; Output:
  1401                              <1> ;	none
  1402                              <1> ; TODO:
  1403                              <1> ;	optimize graphics fill
  1404                              <1> ;-------------------------------------------------------------------------
  1405                              <1> int_10_fn06:
  1406                              <1> int_10_fn07:
  1407 000072AE E86604              <1> 	call	vid_check_mode
  1408 000072B1 7303E9D900          <1> 	jc	.graphics_scroll
  1409                              <1> 
  1410 000072B6 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  1411 000072B8 803E490002          <1> 	cmp	byte [video_mode],2
  1412 000072BD 720A                <1> 	jb	.no_snow
  1413 000072BF 803E490003          <1> 	cmp	byte [video_mode],3
  1414 000072C4 7703                <1> 	ja	.no_snow
  1415 000072C6 BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  1416                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  1417                              <1> .no_snow:
  1418 000072C9 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  1419 000072CC 50                  <1> 	push	ax
  1420 000072CD 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  1421 000072D1 7403                <1> 	jz	.1			; jump if scroll down
  1422 000072D3 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  1423                              <1> 
  1424                              <1> .1:
  1425 000072D6 E89804              <1> 	call	vid_position_to_offset
  1426 000072D9 03064E00            <1> 	add	ax,word [video_page_offt]
  1427 000072DD 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  1428                              <1> 
  1429                              <1> ; calculate scroll window size (DX)
  1430                              <1> 
  1431 000072DF 5A                  <1> 	pop	dx			; DX = window's lower right corner
  1432 000072E0 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  1433 000072E3 81C20101            <1> 	add	dx,101h 			; add 1x1
  1434                              <1> 
  1435                              <1> ; calculate offset between the source and the destination (AX)
  1436                              <1> 
  1437 000072E7 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  1438 000072EB D1E3                <1> 	shl	bx,1			; each character takes two bytes
  1439 000072ED 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  1440 000072F0 52                  <1> 	push    dx
  1441 000072F1 B400                <1>         mov     ah,0
  1442 000072F3 F7E3                <1>         mul     bx
  1443 000072F5 5A                  <1>         pop     dx
  1444                              <1> 
  1445 000072F6 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  1446 000072F8 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  1447 000072FA 1E                  <1> 	push	ds
  1448 000072FB 8CC1                <1> 	mov	cx,es
  1449 000072FD 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  1450 000072FF 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  1451 00007303 7405                <1> 	jz	.2			; jump if scroll up
  1452 00007305 F7D8                <1> 	neg	ax			; negate offset
  1453 00007307 F7DB                <1> 	neg	bx			; negate distance
  1454 00007309 FD                  <1> 	std				; copy backwards
  1455                              <1> 
  1456                              <1> .2:
  1457 0000730A 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  1458 0000730D 08C9                <1> 	or	cl,cl
  1459 0000730F 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  1460 00007311 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  1461 00007312 01FE                <1> 	add	si,di			; SI = scroll copy source address
  1462 00007314 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  1463                              <1> 
  1464 00007316 09DB                <1> 	or	bx,bx
  1465 00007318 7434                <1> 	jz	.text_full_row_scroll
  1466                              <1> 
  1467                              <1> .text_scroll_loop:
  1468 0000731A B500                <1> 	mov	ch,0
  1469 0000731C 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  1470                              <1> 
  1471 0000731E D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  1472 00007320 7303                <1> 	jnc	.text_scroll_no_retrace
  1473 00007322 E85800              <1> 	call	.retrace_wait
  1474                              <1> 
  1475                              <1> .text_scroll_no_retrace:
  1476 00007325 F3A5                <1> 	repz	movsw			; copy one row
  1477                              <1> 
  1478                              <1> ;.text_scroll_next_row:
  1479 00007327 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  1480 00007329 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  1481 0000732B FECE                <1> 	dec	dh			; decrement row counter
  1482 0000732D 75EB                <1> 	jnz	.text_scroll_loop		; jump if there is more rows to copy
  1483                              <1> 
  1484                              <1> .text_fill:
  1485 0000732F 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  1486 00007332 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  1487                              <1> 
  1488                              <1> .text_fill_only:
  1489 00007334 B500                <1> 	mov	ch,0
  1490 00007336 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  1491 00007339 B020                <1> 	mov	al,' '			; AL = blank character
  1492                              <1> 
  1493                              <1> .text_fill_loop:
  1494 0000733B 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  1495 0000733D D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  1496 0000733F 7303                <1> 	jnc	.text_fill_no_retrace		; jump if LSB was zero - no wait
  1497 00007341 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  1498                              <1> 
  1499                              <1> .text_fill_no_retrace:
  1500 00007344 F3AB                <1> 	repz	stosw			; fill one row
  1501 00007346 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  1502 00007348 FECE                <1> 	dec	dh			; decrement row counter
  1503 0000734A 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  1504                              <1> 
  1505 0000734C 1F                  <1> 	pop	ds
  1506 0000734D C3                  <1> 	ret
  1507                              <1> 
  1508                              <1> .text_full_row_scroll:
  1509 0000734E 09C0                <1> 	or	ax,ax
  1510 00007350 741F                <1> 	jz	.text_full_row_no_snow
  1511 00007352 50                  <1> 	push	ax
  1512 00007353 88D0                <1> 	mov	al,dl
  1513 00007355 F6E6                <1> 	mul	dh
  1514                              <1> 
  1515                              <1> .text_full_row_loop:
  1516 00007357 B9F000              <1> 	mov	cx,240
  1517 0000735A 39C8                <1> 	cmp	ax,cx
  1518 0000735C 7705                <1> 	ja	.copy_chunk
  1519 0000735E 91                  <1> 	xchg	ax,cx
  1520 0000735F 31C0                <1> 	xor	ax,ax
  1521 00007361 EB02                <1> 	jmp	.do_copy
  1522                              <1> 
  1523                              <1> .copy_chunk:
  1524 00007363 29C8                <1> 	sub	ax,cx
  1525                              <1> 
  1526                              <1> .do_copy:
  1527 00007365 E81500              <1> 	call	.retrace_wait
  1528 00007368 F3A5                <1> 	rep	movsw
  1529 0000736A 09C0                <1> 	or	ax,ax
  1530 0000736C 75E9                <1> 	jnz	.text_full_row_loop
  1531 0000736E 58                  <1> 	pop	ax
  1532 0000736F EBBE                <1> 	jmp	.text_fill
  1533                              <1> 
  1534                              <1> .text_full_row_no_snow:
  1535 00007371 50                  <1> 	push	ax
  1536 00007372 88D0                <1> 	mov	al,dl
  1537 00007374 F6E6                <1> 	mul	dh
  1538 00007376 89C1                <1> 	mov	cx,ax
  1539 00007378 F3A5                <1> 	rep	movsw
  1540 0000737A 58                  <1> 	pop	ax
  1541 0000737B EBB2                <1> 	jmp	.text_fill
  1542                              <1> 
  1543                              <1> ;-------------------------------------------------------------------------
  1544                              <1> ; .retrace_wait - next till the next vertical retrace
  1545                              <1> 
  1546                              <1> .retrace_wait:
  1547 0000737D 50                  <1> 	push	ax
  1548 0000737E 52                  <1> 	push	dx
  1549 0000737F BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  1550                              <1> 
  1551                              <1> .retrace_wait_not_set:
  1552 00007382 EC                  <1> 	in	al,dx
  1553 00007383 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  1554 00007385 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  1555                              <1> 
  1556                              <1> .retrace_wait_set:
  1557 00007387 EC                  <1> 	in	al,dx
  1558 00007388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  1559 0000738A 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  1560 0000738C 5A                  <1> 	pop	dx
  1561 0000738D 58                  <1> 	pop	ax
  1562                              <1> 
  1563                              <1> .retrace_exit:
  1564 0000738E C3                  <1> 	ret
  1565                              <1> 
  1566                              <1> ;-------------------------------------------------------------------------
  1567                              <1> ; .graphics_scroll - scroll for graphics modes
  1568                              <1> 
  1569                              <1> .graphics_scroll:
  1570 0000738F 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  1571 00007392 50                  <1> 	push	ax
  1572 00007393 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  1573 00007397 7403                <1> 	jz	.3			; jump if scroll down
  1574 00007399 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  1575                              <1> 
  1576                              <1> .3:
  1577 0000739C E8E303              <1> 	call	vid_gfx_pos_to_offset	
  1578 0000739F 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  1579                              <1> 
  1580                              <1> ; calculate scroll windows size (DX)
  1581                              <1> 
  1582 000073A1 5A                  <1> 	pop	dx			; DX = window's lower right corner
  1583 000073A2 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  1584 000073A5 81C20101            <1> 	add	dx,101h 		; add 1x1
  1585 000073A9 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  1586 000073AB D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  1587 000073AD 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  1588 000073B0 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  1589 000073B5 7409                <1> 	jz	.4			; jump if 640x200 mode
  1590 000073B7 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  1591 000073B9 D1E7                <1> 	shl	di,1			; double character width for 320x200
  1592 000073BB 3C07                <1> 	cmp	al,07h			; check for scroll down function
  1593 000073BD 7509                <1> 	jnz	.5			; jump if scroll down
  1594 000073BF 47                  <1> 	inc	di			; scroll up - adjust source address
  1595                              <1> 
  1596                              <1> .4:
  1597 000073C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  1598 000073C2 7504                <1> 	jnz	.5			; jump if not scroll down
  1599 000073C4 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  1600                              <1> 					;   for copying backwards
  1601                              <1> 
  1602                              <1> .5:
  1603 000073C8 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  1604 000073CB D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  1605 000073CD D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  1606 000073CF 53                  <1> 	push	bx
  1607 000073D0 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  1608 000073D2 B050                <1> 	mov	al,50h
  1609 000073D4 F6E3                <1> 	mul	bl
  1610 000073D6 BBB01F              <1> 	mov	bx,1FB0h
  1611 000073D9 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  1612 000073DD 7406                <1> 	jz	.6			; jump if scroll up
  1613 000073DF F7D8                <1> 	neg	ax			; negate offset for scroll down
  1614 000073E1 BB5020              <1> 	mov	bx,2050h
  1615 000073E4 FD                  <1> 	std				; copy backwards
  1616                              <1> 
  1617                              <1> .6:
  1618 000073E5 89FE                <1> 	mov	si,di
  1619 000073E7 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  1620 000073E9 58                  <1> 	pop	ax
  1621 000073EA 8CC1                <1> 	mov	cx,es
  1622 000073EC 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  1623 000073EE 08C0                <1> 	or	al,al
  1624 000073F0 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  1625 000073F2 50                  <1> 	push	ax
  1626                              <1> 
  1627                              <1> .graphics_scroll_loop:
  1628 000073F3 B500                <1> 	mov	ch,0
  1629 000073F5 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  1630 000073F7 56                  <1> 	push	si
  1631 000073F8 57                  <1> 	push	di
  1632 000073F9 F3A4                <1> 	repz	movsb			; copy one row in the first plane
  1633 000073FB 5F                  <1> 	pop	di
  1634 000073FC 5E                  <1> 	pop	si
  1635 000073FD 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  1636 00007401 81C70020            <1> 	add	di,2000h
  1637 00007405 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  1638 00007407 56                  <1> 	push	si
  1639 00007408 57                  <1> 	push	di
  1640 00007409 F3A4                <1> 	repz	movsb			; copy one row in the second plane
  1641 0000740B 5F                  <1> 	pop	di
  1642 0000740C 5E                  <1> 	pop	si
  1643 0000740D 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  1644 0000740F 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  1645 00007411 FECE                <1> 	dec	dh			; decrement row counter
  1646 00007413 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  1647                              <1> 
  1648 00007415 58                  <1> 	pop	ax
  1649 00007416 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  1650                              <1> 
  1651                              <1> .graphics_fill:
  1652 00007418 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  1653 0000741B B500                <1> 	mov	ch,0
  1654                              <1> 
  1655                              <1> .graphics_fill_loop:
  1656 0000741D 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  1657 0000741F 57                  <1> 	push	di
  1658 00007420 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  1659 00007422 5F                  <1> 	pop	di
  1660 00007423 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  1661 00007427 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  1662 00007429 57                  <1> 	push	di
  1663 0000742A F3AA                <1> 	repz	stosb			; fill one row in the second plane
  1664 0000742C 5F                  <1> 	pop	di
  1665 0000742D 29DF                <1> 	sub	di,bx
  1666 0000742F FECE                <1> 	dec	dh			; decrement row counter
  1667 00007431 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  1668 00007433 C3                  <1> 	ret
  1669                              <1> 
  1670                              <1> ;=========================================================================
  1671                              <1> ; int_10_fn08 - Read character and attribute
  1672                              <1> ; Input:
  1673                              <1> ;	AH = 08h
  1674                              <1> ; Output:
  1675                              <1> ;	AL - character read
  1676                              <1> ;	BH - video attribute (text modes only)
  1677                              <1> ; int_10_fn09 - Write character and attribute
  1678                              <1> ; Input:
  1679                              <1> ;	AH = 09h
  1680                              <1> ;	AL - character to write
  1681                              <1> ;	BH - page number
  1682                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  1683                              <1> ;	CX - number of times to write character
  1684                              <1> ; Output:
  1685                              <1> ;	none
  1686                              <1> ; int_10_fn0A - Write character only
  1687                              <1> ; Input:
  1688                              <1> ;	AH = 0Ah
  1689                              <1> ;	AL - character to write
  1690                              <1> ;	BH - page number
  1691                              <1> ;	CX - repeat count
  1692                              <1> ; Output:
  1693                              <1> ;	none
  1694                              <1> ;-------------------------------------------------------------------------
  1695                              <1> int_10_fn08:
  1696                              <1> int_10_fn09:
  1697                              <1> int_10_fn0A:
  1698 00007434 E8E002              <1> 	call	vid_check_mode
  1699 00007437 7277                <1> 	jc	.graphics			; jump if graphics mode
  1700 00007439 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  1701 0000743C B700                <1> 	mov	bh,0
  1702 0000743E 53                  <1> 	push	bx
  1703 0000743F E82803              <1> 	call	vid_current_offset
  1704 00007442 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  1705 00007444 58                  <1> 	pop	ax			; AX = page number
  1706 00007445 F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  1707 00007449 01C7                <1> 	add	di,ax			; DI = character offset
  1708 0000744B 89FE                <1> 	mov	si,di			; SI = character offset
  1709 0000744D 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  1710 00007451 83C206              <1> 	add	dx,6			; DX = CGA status register
  1711 00007454 1E                  <1> 	push	ds
  1712 00007455 8CC3                <1> 	mov	bx,es
  1713 00007457 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  1714 00007459 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  1715 0000745C 3C08                <1> 	cmp	al,08h			; check for read character function
  1716 0000745E 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  1717                              <1> 
  1718                              <1> .read_retrace_wait:
  1719 00007460 EC                  <1> 	in	al,dx
  1720 00007461 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  1721 00007463 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  1722 00007465 FA                  <1> 	cli
  1723                              <1> 
  1724                              <1> .read_no_retrace_wait:
  1725 00007466 EC                  <1> 	in	al,dx
  1726 00007467 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  1727 00007469 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  1728                              <1> 
  1729 0000746B AD                  <1> 	lodsw				; read character and attribute
  1730 0000746C FB                  <1> 	sti
  1731 0000746D 1F                  <1> 	pop	ds
  1732 0000746E 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  1733 00007471 C3                  <1> 	ret
  1734                              <1> 
  1735                              <1> .text_write:
  1736 00007472 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  1737 00007475 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  1738 00007478 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  1739 0000747B 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  1740 0000747D 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  1741                              <1> 
  1742                              <1> .write_char_retrace:
  1743 0000747F EC                  <1> 	in	al,dx
  1744 00007480 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  1745 00007482 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  1746                              <1> 
  1747                              <1> .write_retrace_wait1:
  1748 00007484 EC                  <1> 	in	al,dx
  1749 00007485 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  1750 00007487 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  1751 00007489 FA                  <1> 	cli
  1752                              <1> 
  1753                              <1> .write_no_retrace_wait1:
  1754 0000748A EC                  <1> 	in	al,dx
  1755 0000748B A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  1756 0000748D 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  1757                              <1> 
  1758                              <1> .do_write_char_attr:
  1759 0000748F 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  1760 00007491 AB                  <1> 	stosw				; write it to video memory
  1761 00007492 FB                  <1> 	sti
  1762 00007493 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  1763 00007495 1F                  <1> 	pop	ds
  1764 00007496 C3                  <1> 	ret
  1765                              <1> 
  1766                              <1> .text_write_char_only:
  1767 00007497 EC                  <1> 	in	al,dx
  1768 00007498 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  1769 0000749A 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  1770                              <1> 
  1771                              <1> .write_retrace_wait2:
  1772 0000749C EC                  <1> 	in	al,dx
  1773 0000749D A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  1774 0000749F 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  1775 000074A1 FA                  <1> 	cli
  1776                              <1> 
  1777                              <1> .write_no_retrace_wait2:
  1778 000074A2 EC                  <1> 	in	al,dx
  1779 000074A3 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  1780 000074A5 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  1781                              <1> 
  1782                              <1> .do_write_char_only:
  1783 000074A7 88D8                <1> 	mov	al,bl			; AL = character to write
  1784 000074A9 AA                  <1> 	stosb				; write it to video memory
  1785 000074AA FB                  <1> 	sti
  1786 000074AB 47                  <1> 	inc	di			; skip attribute
  1787 000074AC E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  1788 000074AE 1F                  <1> 	pop	ds
  1789 000074AF C3                  <1> 	ret
  1790                              <1> 
  1791                              <1> .graphics:
  1792 000074B0 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  1793 000074B4 7503E9B300          <1> 	jz	.graphics_read
  1794                              <1> 
  1795 000074B9 A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  1796 000074BC E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  1797 000074BF 89C7                <1> 	mov	di,ax			; Save in displacement register
  1798 000074C1 1E                  <1> 	push	ds
  1799 000074C2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  1800 000074C5 B400                <1> 	mov	ah,0
  1801 000074C7 08C0                <1> 	or	al,al			; Is it user character set?
  1802 000074C9 7807                <1> 	js	.CG9_02			;  ...skip if so
  1803 000074CB 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  1804 000074CD BE[6E7A]            <1> 	mov	si,gfx_font		; load graphics font offset
  1805 000074D0 EB0C                <1> 	jmp	.CG9_03
  1806                              <1> 
  1807                              <1> .CG9_02:
  1808 000074D2 247F                <1> 	and	al,7Fh			; Origin to zero
  1809 000074D4 31DB                <1> 	xor	bx,bx			;  ...then go load
  1810 000074D6 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  1811 000074D8 C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  1812 000074DC 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  1813                              <1> 
  1814                              <1> .CG9_03:
  1815 000074DE 1F                  <1> 	pop	ds			; Restore data segment
  1816 000074DF B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  1817 000074E1 D3E0                <1> 	shl	ax,cl
  1818 000074E3 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  1819 000074E5 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  1820 000074E8 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  1821 000074ED 1E                  <1> 	push	ds
  1822 000074EE 8EDA                <1> 	mov	ds,dx
  1823 000074F0 7451                <1> 	jz	.CG8_02			;  ...skip if so
  1824 000074F2 D1E7                <1> 	shl	di,1
  1825 000074F4 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get character attribute
  1826 000074F7 83E003              <1> 	and	ax,3
  1827 000074FA BB5555              <1> 	mov	bx,5555h
  1828 000074FD F7E3                <1> 	mul	bx
  1829 000074FF 89C2                <1> 	mov	dx,ax
  1830 00007501 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Restore BL (character attribute)
  1831                              <1> 
  1832                              <1> .CG9_04:
  1833 00007504 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  1834 00007506 57                  <1> 	push	di
  1835 00007507 56                  <1> 	push	si
  1836                              <1> 
  1837                              <1> .CG9_05:
  1838 00007508 AC                  <1> 	lodsb				; Read the screen
  1839 00007509 51                  <1> 	push	cx
  1840 0000750A 53                  <1> 	push	bx
  1841 0000750B 31DB                <1> 	xor	bx,bx
  1842 0000750D B90800              <1> 	mov	cx,8
  1843                              <1> 
  1844                              <1> .CG9_06:
  1845 00007510 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  1846 00007512 D1DB                <1> 	rcr	bx,1
  1847 00007514 D1FB                <1> 	sar	bx,1
  1848 00007516 E2F8                <1> 	loop	.CG9_06
  1849                              <1> 
  1850 00007518 89D8                <1> 	mov	ax,bx			; Result into ax
  1851 0000751A 5B                  <1> 	pop	bx
  1852 0000751B 59                  <1> 	pop	cx
  1853 0000751C 21D0                <1> 	and	ax,dx
  1854 0000751E 86E0                <1> 	xchg	ah,al
  1855 00007520 08DB                <1> 	or	bl,bl
  1856 00007522 7903                <1> 	jns	.CG9_07
  1857 00007524 263305              <1>     es	xor	ax,word [di]
  1858                              <1> 
  1859                              <1> .CG9_07:
  1860 00007527 268905              <1>     es	mov	word [di],ax		; Write new word
  1861 0000752A 81F70020            <1> 	xor	di,2000h
  1862 0000752E F7C70020            <1> 	test	di,2000h		; Is this other plane?
  1863 00007532 7503                <1> 	jnz	.CG9_08			;  ...nope
  1864 00007534 83C750              <1> 	add	di,50h			; Else advance character
  1865                              <1> 
  1866                              <1> .CG9_08:
  1867 00007537 FECF                <1> 	dec	bh			; Show another char written
  1868 00007539 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  1869 0000753B 5E                  <1> 	pop	si
  1870 0000753C 5F                  <1> 	pop	di
  1871 0000753D 47                  <1> 	inc	di
  1872 0000753E 47                  <1> 	inc	di
  1873 0000753F E2C3                <1> 	loop	.CG9_04
  1874 00007541 1F                  <1> 	pop	ds
  1875 00007542 C3                  <1> 	ret
  1876                              <1> 
  1877                              <1> .CG8_02:
  1878 00007543 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  1879 00007546 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  1880                              <1> 
  1881                              <1> .CG8_03:
  1882 00007549 B708                <1> 	mov	bh,8			; Pixel count to write
  1883 0000754B 57                  <1> 	push	di
  1884 0000754C 56                  <1> 	push	si
  1885                              <1> 
  1886                              <1> .CG8_04:
  1887 0000754D AC                  <1> 	lodsb				; Read from one plane
  1888 0000754E 08DB                <1> 	or	bl,bl			;  ...done both planes?
  1889 00007550 7903                <1> 	jns	.CG8_05			;  ...skip if not
  1890 00007552 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  1891                              <1> 
  1892                              <1> .CG8_05:
  1893 00007555 268805              <1>     es	mov	byte [di],al		; Write out attribute
  1894 00007558 31D7                <1> 	xor	di,dx			;  ...get other plane
  1895 0000755A 85D7                <1> 	test	di,dx			; Done both planes?
  1896 0000755C 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  1897 0000755E 83C750              <1> 	add	di,50h			; Else position for now char
  1898                              <1> 
  1899                              <1> .CG8_06:
  1900 00007561 FECF                <1> 	dec	bh			; Show row of pixels read
  1901 00007563 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  1902 00007565 5E                  <1> 	pop	si
  1903 00007566 5F                  <1> 	pop	di
  1904 00007567 47                  <1> 	inc	di
  1905 00007568 E2DF                <1> 	loop	.CG8_03
  1906 0000756A 1F                  <1> 	pop	ds
  1907 0000756B C3                  <1> 	ret
  1908                              <1> 
  1909                              <1> .graphics_read:
  1910 0000756C FC                  <1> 	cld				; Increment upwards
  1911 0000756D A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  1912 00007570 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  1913 00007573 89C6                <1> 	mov	si,ax			;  ...save in si
  1914 00007575 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  1915 00007578 89E7                <1> 	mov	di,sp			;  ...save base in di
  1916 0000757A 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  1917 0000757F 8CC0                <1> 	mov	ax,es
  1918 00007581 1E                  <1> 	push	ds
  1919 00007582 57                  <1> 	push	di
  1920 00007583 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  1921 00007585 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  1922 00007587 B608                <1> 	mov	dh,8			; Eight pixels high/char
  1923 00007589 D1E6                <1> 	shl	si,1
  1924 0000758B BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  1925                              <1> 
  1926                              <1> CGR_02:
  1927 0000758E 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  1928 00007590 86E0                <1> 	xchg	ah,al
  1929 00007592 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  1930 00007595 B200                <1> 	mov	dl,0
  1931                              <1> 
  1932                              <1> CGR_03:
  1933 00007597 85C8                <1> 	test	ax,cx			; Look for attributes
  1934 00007599 F8                  <1> 	clc
  1935 0000759A 7401                <1> 	jz	CGR_04			;  ...set, skip
  1936 0000759C F9                  <1> 	stc				; Else show not set
  1937                              <1> 
  1938                              <1> CGR_04:
  1939 0000759D D0D2                <1> 	rcl	dl,1
  1940 0000759F D1E9                <1> 	shr	cx,1
  1941 000075A1 D1E9                <1> 	shr	cx,1
  1942 000075A3 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  1943 000075A5 368815              <1>     ss	mov	byte [di],dl
  1944 000075A8 47                  <1> 	inc	di
  1945 000075A9 31DE                <1> 	xor	si,bx			; Do other video plane
  1946 000075AB 85DE                <1> 	test	si,bx			;  ...done both planes?
  1947 000075AD 7503                <1> 	jnz	CGR_05			;  ...no, skip
  1948 000075AF 83C650              <1> 	add	si,50h			; Else advance pointer
  1949                              <1> 
  1950                              <1> CGR_05:
  1951 000075B2 FECE                <1> 	dec	dh			; Show another pixel row done
  1952 000075B4 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  1953 000075B6 EB17                <1> 	jmp	short	CGR_08
  1954                              <1> 
  1955                              <1> CGR_06:
  1956 000075B8 B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  1957                              <1> 
  1958                              <1> CGR_07:
  1959 000075BA 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  1960 000075BC 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  1961 000075BF 47                  <1> 	inc	di			;  ...advance
  1962 000075C0 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  1963 000075C4 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  1964 000075C7 47                  <1> 	inc	di			;  ...advance
  1965 000075C8 83C650              <1> 	add	si,50h			; Total pixels in char
  1966 000075CB FECE                <1> 	dec	dh			;  ...another row processed
  1967 000075CD 75EB                <1> 	jnz	CGR_07			;  ...more to do
  1968                              <1> 
  1969                              <1> CGR_08:
  1970 000075CF 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  1971 000075D1 BF[6E7A]            <1> 	mov	di,gfx_font		;  ...and offset
  1972 000075D4 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  1973 000075D6 8CD2                <1> 	mov	dx,ss
  1974 000075D8 8EDA                <1> 	mov	ds,dx
  1975 000075DA 5E                  <1> 	pop	si
  1976 000075DB B000                <1> 	mov	al,0
  1977                              <1> 
  1978                              <1> CGR_09:
  1979 000075DD BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  1980                              <1> 
  1981                              <1> CGR_10:
  1982 000075E0 56                  <1> 	push	si
  1983 000075E1 57                  <1> 	push	di
  1984 000075E2 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  1985 000075E5 F3A6                <1> 	repz	cmpsb			;  ...do compare
  1986 000075E7 5F                  <1> 	pop	di
  1987 000075E8 5E                  <1> 	pop	si
  1988 000075E9 741C                <1> 	jz	CGR_11			; Found graphics character
  1989 000075EB FEC0                <1> 	inc	al			;  ...else show another char
  1990 000075ED 83C708              <1> 	add	di,8			;  ...advance one row
  1991 000075F0 4A                  <1> 	dec	dx			;  ...one less char  to scan
  1992 000075F1 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  1993                              <1> 
  1994 000075F3 08C0                <1> 	or	al,al			; User graphics character set?
  1995 000075F5 7410                <1> 	jz	CGR_11			;  ...no, not found
  1996 000075F7 31DB                <1> 	xor	bx,bx			; 
  1997 000075F9 8EDB                <1> 	mov	ds,bx			; Load interrupt table segment to ES
  1998 000075FB C43E7C00            <1> 	les	di,[1Fh*4]		; Load user font for graphics 
  1999                              <1> 					; (INT 1Fh vector) to ES:SI
  2000 000075FF 8CC3                <1> 	mov	bx,es
  2001 00007601 09FB                <1> 	or	bx,di
  2002 00007603 7402                <1> 	jz	CGR_11			;  ...not found
  2003 00007605 EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  2004                              <1> 
  2005                              <1> CGR_11:
  2006 00007607 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  2007 0000760A 1F                  <1> 	pop	ds
  2008 0000760B 83C408              <1> 	add	sp,8			;  ...return temp storage
  2009 0000760E C3                  <1> 	ret
  2010                              <1> 
  2011                              <1> ;=========================================================================
  2012                              <1> ; int_10_fn0B - Set background color or palette
  2013                              <1> ; Input:
  2014                              <1> ; 	AH - 0Bh
  2015                              <1> ;	BH = 00h - set background / border color
  2016                              <1> ;		BL - background (graphics modes) or border (text modes)
  2017                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  2018                              <1> ;		BL - palette ID:
  2019                              <1> ;			00h - background, green, red, and yellow (brown)
  2020                              <1> ;			01h - background, cyan, magenta, and white
  2021                              <1> ; Output:
  2022                              <1> ;	none
  2023                              <1> ;-------------------------------------------------------------------------
  2024                              <1> int_10_fn0B:
  2025 0000760F A06600              <1> 	mov	al,byte [video_palet_reg] 	; AL = current palette register
  2026 00007612 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  2027 00007615 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  2028 00007619 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  2029                              <1> 
  2030 0000761B 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  2031 0000761D 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  2032 00007620 08E0                <1> 	or	al,ah			; apply new color
  2033 00007622 EB09                <1> 	jmp	.write_palet_reg
  2034                              <1> 
  2035                              <1> .set_palette:
  2036 00007624 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  2037 00007626 F6C401              <1> 	test	ah,01h
  2038 00007629 7402                <1> 	jz	.write_palet_reg
  2039 0000762B 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  2040                              <1> 
  2041                              <1> .write_palet_reg:
  2042 0000762D A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  2043 00007630 8B166300            <1> 	mov	dx,word [video_port]
  2044 00007634 83C205              <1> 	add	dx,5			; CRTC color select register
  2045 00007637 EE                  <1> 	out	dx,al			; send it to CRTC
  2046 00007638 C3                  <1> 	ret
  2047                              <1> 
  2048                              <1> ;=========================================================================
  2049                              <1> ; int_10_fn0C - Write graphics pixel
  2050                              <1> ; Input:
  2051                              <1> ;	AH = 0Ch
  2052                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  2053                              <1> ;	CX = column
  2054                              <1> ;	DX = row
  2055                              <1> ; Output:
  2056                              <1> ;	none
  2057                              <1> ;-------------------------------------------------------------------------
  2058                              <1> int_10_fn0C:
  2059 00007639 E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  2060 0000763C 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  2061 0000763E 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  2062 00007641 88C3                <1> 	mov	bl,al			; copy color to BL
  2063 00007643 2401                <1> 	and	al,1			; one bit per pixel
  2064 00007645 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  2065 00007647 B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  2066 00007649 EB0F                <1> 	jmp	.prepare_mask
  2067                              <1> 
  2068                              <1> .mode_320x200:
  2069 0000764B D0E1                <1> 	shl	cl,1
  2070 0000764D 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  2071 00007650 88C3                <1> 	mov	bl,al			; copy color to BL
  2072 00007652 2403                <1> 	and	al,3			; two bit per pixel
  2073 00007654 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  2074 00007656 D0C8                <1> 	ror	al,1
  2075 00007658 B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  2076                              <1> 
  2077                              <1> .prepare_mask:
  2078 0000765A D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  2079 0000765C D2E8                <1> 	shr	al,cl			; position color bits correctly
  2080 0000765E 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  2081 00007661 08DB                <1> 	or	bl,bl			; check if bit 7 set
  2082 00007663 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  2083 00007665 30C1                <1> 	xor	cl,al			; else XOR with existing color
  2084 00007667 EB04                <1> 	jmp	.write_pixel
  2085                              <1> 
  2086                              <1> .set_color:
  2087 00007669 20E1                <1> 	and	cl,ah			; clear existing color bits
  2088 0000766B 08C1                <1> 	or	cl,al			; set new color bits
  2089                              <1> 
  2090                              <1> .write_pixel:
  2091 0000766D 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  2092 00007670 C3                  <1> 	ret
  2093                              <1> 
  2094                              <1> ;=========================================================================
  2095                              <1> ; int_10_fn0D - Read graphics pixel
  2096                              <1> ; Input:
  2097                              <1> ;	AH = 0Dh
  2098                              <1> ;	CX = column
  2099                              <1> ;	DX = row
  2100                              <1> ; Output:
  2101                              <1> ;	AL = pixel color 
  2102                              <1> ;-------------------------------------------------------------------------
  2103                              <1> int_10_fn0D:
  2104 00007671 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  2105 00007674 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  2106 00007677 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  2107 00007679 D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  2108 0000767B D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  2109 0000767D 2401                <1> 	and	al,1			; one bit per pixel
  2110 0000767F EB0A                <1> 	jmp	.exit
  2111                              <1> 
  2112                              <1> .mode_320x200:
  2113 00007681 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  2114 00007683 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  2115 00007685 D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  2116 00007687 D0C0                <1> 	rol	al,1
  2117 00007689 2403                <1> 	and	al,3			; two bits per pixel
  2118                              <1> 
  2119                              <1> .exit:
  2120 0000768B 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  2121 0000768E C3                  <1> 	ret
  2122                              <1> 
  2123                              <1> ;=========================================================================
  2124                              <1> ; int_10_fn0E - Teletype output
  2125                              <1> ; Input:
  2126                              <1> ;	AH = 0Eh
  2127                              <1> ;	AL = character to write
  2128                              <1> ;	BL = foreground color (graphics modes only)
  2129                              <1> ; Output:
  2130                              <1> ;	none
  2131                              <1> ; Notes:
  2132                              <1> ;	- writes character to the active video page
  2133                              <1> ;	- support following control characters: BEL, BS, LF, CR
  2134                              <1> ;-------------------------------------------------------------------------
  2135                              <1> int_10_fn0E:
  2136 0000768F 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  2137 00007693 B700                <1> 	mov	bh,0
  2138 00007695 D0E3                <1> 	shl	bl,1			; word index
  2139 00007697 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  2140                              <1> 
  2141 0000769A 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  2142 0000769D 3C08                <1> 	cmp	al,bs
  2143 0000769F 7429                <1> 	jz	.bs			; jump if backspace (BS)
  2144 000076A1 3C0A                <1> 	cmp	al,lf
  2145 000076A3 741C                <1> 	jz	.lf			; jump if line feed (LF)
  2146 000076A5 3C07                <1> 	cmp	al,bel
  2147 000076A7 7433                <1> 	jz	.bel			; jump if beep (BEL)
  2148 000076A9 3C0D                <1> 	cmp	al,cr
  2149 000076AB 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  2150 000076AD 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  2151 000076B0 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  2152 000076B2 B90100              <1> 	mov	cx,1			; one character
  2153 000076B5 CD10                <1> 	int	10h			; write character
  2154 000076B7 FEC2                <1> 	inc	dl			; move cursor to the next column
  2155 000076B9 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  2156 000076BD 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  2157 000076BF B200                <1> 	mov	dl,0			; move to the first position
  2158                              <1> 
  2159                              <1> .lf:
  2160 000076C1 80FE18              <1> 	cmp	dh,24			; on the last row?
  2161 000076C4 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  2162 000076C6 FEC6                <1> 	inc	dh			; move cursor to the next row
  2163 000076C8 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  2164                              <1> 
  2165                              <1> .bs:
  2166 000076CA 80FA00              <1> 	cmp	dl,0			; on the first column?
  2167 000076CD 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  2168 000076CF FECA                <1> 	dec	dl			; move cursor to the previous position
  2169 000076D1 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  2170                              <1> 
  2171                              <1> .cr:
  2172 000076D3 B200                <1> 	mov	dl,0			; set cursor to the first column
  2173                              <1> 
  2174                              <1> .set_cursor_pos:
  2175 000076D5 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  2176 000076D9 E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  2177                              <1> 
  2178                              <1> .bel:
  2179 000076DC B302                <1> 	mov	bl,2			; 0.2 second beep
  2180 000076DE E8A29E              <1> 	call	beep
  2181 000076E1 C3                  <1> 	ret
  2182                              <1> 
  2183                              <1> .scroll:
  2184 000076E2 B402                <1> 	mov	ah,02h
  2185 000076E4 CD10                <1> 	int	10h			; set new cursor position
  2186 000076E6 E82E00              <1> 	call	vid_check_mode
  2187 000076E9 B700                <1> 	mov	bh,0
  2188 000076EB 7206                <1> 	jc	.do_scroll		; jump if text mode - do scroll
  2189 000076ED B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  2190 000076EF CD10                <1> 	int	10h			; read attirbute at current position
  2191 000076F1 88E7                <1> 	mov	bh,ah
  2192                              <1> 
  2193                              <1> .do_scroll:
  2194 000076F3 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
  2195 000076F5 B001                <1> 	mov	al,1			; scroll one line
  2196 000076F7 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
  2197 000076F9 B618                <1> 	mov	dh,24			; bottom row is 24
  2198 000076FB 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
  2199 000076FF FECA                <1> 	dec	dl
  2200 00007701 CD10                <1> 	int	10h			; scroll page up
  2201 00007703 C3                  <1> 	ret
  2202                              <1> 
  2203                              <1> ;=========================================================================
  2204                              <1> ; int_10_fn0F - Get current video mode
  2205                              <1> ; Input:
  2206                              <1> ;	AH = 0Fh
  2207                              <1> ; Output:
  2208                              <1> ;	AL = video mode
  2209                              <1> ;	AH = characters per column
  2210                              <1> ;	BH = active video page
  2211                              <1> ;-------------------------------------------------------------------------
  2212                              <1> int_10_fn0F:
  2213 00007704 A04A00              <1> 	mov	al,byte [video_columns]
  2214 00007707 884601              <1> 	mov	byte [bp+int_10_ah],al
  2215 0000770A A04900              <1> 	mov	al,byte [video_mode]
  2216 0000770D 884600              <1> 	mov	byte [bp+int_10_al],al
  2217 00007710 A06200              <1> 	mov	al,byte [video_page]
  2218 00007713 884603              <1> 	mov	byte [bp+int_10_bh],al
  2219 00007716 C3                  <1> 	ret
  2220                              <1> 
  2221                              <1> ;=========================================================================
  2222                              <1> ; vid_check_mode - Check current video mode
  2223                              <1> ; Input:
  2224                              <1> ;	none
  2225                              <1> ; Output:
  2226                              <1> ;	ZF set if monochrome mode (mode 07h)
  2227                              <1> ;	CF set if graphics modes (modes 04h - 06h)
  2228                              <1> ;-------------------------------------------------------------------------
  2229                              <1> vid_check_mode:
  2230 00007717 50                  <1> 	push	ax
  2231 00007718 A04900              <1> 	mov	al,byte [video_mode]
  2232 0000771B 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
  2233 0000771D 7408                <1> 	jz	.exit			; jump if monochrome
  2234 0000771F 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
  2235 00007721 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
  2236 00007722 7303                <1> 	jnc	.exit			; jump if not graphics (CF = 0, ZF = 0)
  2237 00007724 18C0                <1> 	sbb	al,al			; AL=AL-(AL+CF) set CF and clear ZF?
  2238 00007726 F9                  <1> 	stc				; set CF back
  2239                              <1> 
  2240                              <1> .exit:
  2241 00007727 58                  <1> 	pop	ax
  2242 00007728 C3                  <1> 	ret
  2243                              <1> 
  2244                              <1> ;=========================================================================
  2245                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  2246                              <1> ; 将一个字写入两个连续的CRTC寄存器
  2247                              <1> ; Input:
  2248                              <1> ;	AH = register number
  2249                              <1> ;	CX = word to write
  2250                              <1> ; Output:
  2251                              <1> ;	AX trashed
  2252                              <1> ; Note:
  2253                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
  2254                              <1> ; 	将CH写入寄存器号AH，将CL写入寄存器号AH+1
  2255                              <1> ;-------------------------------------------------------------------------
  2256                              <1> vid_crtc_writew:
  2257 00007729 88E8                <1> 	mov	al,ch
  2258 0000772B E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
  2259 0000772E FEC4                <1> 	inc	ah			; point AH to the next register
  2260 00007730 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
  2261                              <1> 
  2262                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
  2263                              <1> 
  2264                              <1> ;=========================================================================
  2265                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  2266                              <1> ; 将一个字写入两个连续的CRTC寄存器
  2267                              <1> ; Input:
  2268                              <1> ;	AH = register number
  2269                              <1> ;	AL = byte to write
  2270                              <1> ; Output:
  2271                              <1> ;	none
  2272                              <1> ;-------------------------------------------------------------------------
  2273                              <1> vid_crtc_writeb:
  2274 00007732 52                  <1> 	push	dx
  2275 00007733 8B166300            <1> 	mov	dx,word [video_port]		; DX = CRTC index port  (video_port=63H ;  [63H]=3B4h(mono), 3D4h(color)
  2276 00007737 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
  2277 00007739 EE                  <1> 	out	dx,al			; write register number
  2278 0000773A 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
  2279 0000773C FEC2                <1> 	inc	dl			; DX = CRTC data port
  2280 0000773E EE                  <1> 	out	dx,al			; write byte
  2281 0000773F 5A                  <1> 	pop	dx
  2282 00007740 C3                  <1> 	ret
  2283                              <1> 
  2284                              <1> ;=========================================================================
  2285                              <1> ; vid_pixel_address - calculate pixel address and mask
  2286                              <1> ; 计算像素地址和掩码
  2287                              <1> ; Input:
  2288                              <1> ;	CX - column
  2289                              <1> ;	DX - row
  2290                              <1> ; Output:
  2291                              <1> ;	SI - pixel address
  2292                              <1> ;	CH - pixel mask
  2293                              <1> ;	CL - pixel position in the byte
  2294                              <1> ;	ZF - mode
  2295                              <1> ;		0 = 320x200
  2296                              <1> ;		1 = 640x200
  2297                              <1> ;-------------------------------------------------------------------------
  2298                              <1> vid_pixel_address:
  2299 00007741 31F6                <1> 	xor	si,si			; SI = 0
  2300 00007743 D0EA                <1> 	shr	dl,1			; divide row by two
  2301 00007745 7303                <1> 	jnb	.even			; jump if on even row 
  2302 00007747 BE0020              <1> 	mov	si,2000h		; odd row - second video plane
  2303                              <1> 
  2304                              <1> .even:
  2305 0000774A B050                <1> 	mov	al,50h			; bytes in each row
  2306 0000774C F6E2                <1> 	mul	dl			; AX - address of the row
  2307                              <1> 
  2308 0000774E 01C6                <1> 	add	si,ax			; add row address to SI
  2309 00007750 89CA                <1> 	mov	dx,cx			; DX - column
  2310 00007752 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
  2311 00007755 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
  2312 0000775A 9C                  <1> 	pushf				; save ZF (and other flags
  2313 0000775B 7503                <1> 	jnz	.1			; skip if not 640x200
  2314 0000775D B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
  2315                              <1> 
  2316                              <1> .1:
  2317 00007760 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
  2318 00007762 D3EA                <1> 	shr	dx,cl			; DX = address of the column
  2319 00007764 01D6                <1> 	add	si,dx			; add column address to SI
  2320 00007766 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
  2321 00007768 9D                  <1> 	popf
  2322 00007769 C3                  <1> 	ret
  2323                              <1> 
  2324                              <1> ;=========================================================================
  2325                              <1> ; vid_current_offset - convert current cursor position to offset
  2326                              <1> ;		       relative to page starting address
  2327                              <1> ; 将当前光标位置转换为相对于页面起始地址的偏移量
  2328                              <1> ; Input:
  2329                              <1> ;	BL = page
  2330                              <1> ; Output:
  2331                              <1> ;	AX = offset
  2332                              <1> ;-------------------------------------------------------------------------
  2333                              <1> vid_current_offset:
  2334 0000776A B700                <1> 	mov	bh,0
  2335 0000776C D1E3                <1> 	shl	bx,1				; word index
  2336 0000776E 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
  2337                              <1> 
  2338                              <1> ; fall through to vid_position_to_offset
  2339                              <1> 
  2340                              <1> ;=========================================================================
  2341                              <1> ; vid_position_to_offset - convert position (row and column) to offset relative to page starting address
  2342                              <1> ; 将位置（行和列）转换为相对于页面起始地址的偏移量			   
  2343                              <1> ; Input:
  2344                              <1> ;	AH = row
  2345                              <1> ;	AL = column
  2346                              <1> ; Output:
  2347                              <1> ;	AX = offset
  2348                              <1> ;-------------------------------------------------------------------------
  2349                              <1> vid_position_to_offset:
  2350 00007771 53                  <1> 	push	bx
  2351 00007772 88C3                <1> 	mov	bl,al			; BL = column
  2352 00007774 88E0                <1> 	mov	al,ah			; AL = row
  2353 00007776 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  2354 0000777A B700                <1> 	mov	bh,0			;
  2355 0000777C 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
  2356 0000777E D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
  2357 00007780 5B                  <1> 	pop	bx
  2358 00007781 C3                  <1> 	ret
  2359                              <1> 
  2360                              <1> ;=========================================================================
  2361                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
  2362                              <1> ; 将位置（行和列）转换为偏移
  2363                              <1> ; Input:
  2364                              <1> ;	AH = row
  2365                              <1> ;	AL = column
  2366                              <1> ; Output:
  2367                              <1> ;	AX = offset
  2368                              <1> ;-------------------------------------------------------------------------
  2369                              <1> vid_gfx_pos_to_offset:
  2370 00007782 53                  <1> 	push	bx
  2371 00007783 88C3                <1> 	mov	bl,al			; BL = column
  2372 00007785 88E0                <1> 	mov	al,ah			; AL = row
  2373 00007787 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  2374 0000778B D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
  2375 0000778D D1E0                <1> 	shl	ax,1			;   four bytes in each plane
  2376 0000778F B700                <1> 	mov	bh,0
  2377 00007791 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
  2378 00007793 5B                  <1> 	pop	bx
  2379 00007794 C3                  <1> 	ret
   928                                  
   929                                  ;=========================================================================
   930                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
   931                                  ;-------------------------------------------------------------------------
   932                                  
   933                                  detect_rom_ext:
   934 00007795 B040                    	mov	al,e_ext_start	; ROM extension scan start
   935 00007797 E680                    	out	post_reg,al
   936                                  
   937 00007799 BA00C8                  	mov	dx,0C800h
   938 0000779C BB00F8                  	mov	bx,0F800h
   939                                  
   940                                  .ext_scan_loop:
   941 0000779F E8F400                  	call	extension_scan
   942 000077A2 833E670000              	cmp	word [67h],0
   943 000077A7 7429                    	jz	.ext_scan_done	; No ROM extension found
   944 000077A9 B041                    	mov	al,e_ext_detect	; ROM extension found
   945 000077AB E680                    	out	post_reg,al
   946 000077AD BE[3103]                	mov	si,msg_rom_found
   947 000077B0 E8FB9E                  	call	print
   948 000077B3 A16900                  	mov	ax,word [69h]	; ROM extension's segment
   949 000077B6 E8109F                  	call	print_hex
   950 000077B9 BE[4E03]                	mov	si,msg_rom_init
   951 000077BC E8EF9E                  	call	print
   952 000077BF 53                      	push	bx
   953 000077C0 52                      	push	dx
   954 000077C1 FF1E6700                	call	far [67h]
   955 000077C5 B84000                  	mov	ax,biosdseg	; DS = BIOS data area
   956 000077C8 8ED8                    	mov	ds,ax
   957 000077CA B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
   958 000077CC E680                    	out	post_reg,al
   959 000077CE 5A                      	pop	dx
   960 000077CF 5B                      	pop	bx
   961 000077D0 EBCD                    	jmp	.ext_scan_loop
   962                                  
   963                                  .ext_scan_done:
   964 000077D2 B043                    	mov	al,e_ext_complete	; ROM extension scan complete
   965 000077D4 E680                    	out	post_reg,al
   966                                  
   967 000077D6 C3                      	ret
   968                                  
   969                                  ;=========================================================================
   970                                  ; int_12 - Get memory size
   971                                  ; Input:
   972                                  ;	none
   973                                  ; Output:
   974                                  ;	AX = memory size
   975                                  ;-------------------------------------------------------------------------
   976 000077D7 FF<rep 6Ah>             	setloc	0F841h			; INT 12 Entry Point
   976          ******************       warning: Inserting 106 bytes [-w+user]
   977                                  int_12:
   978 00007841 FB                      	sti
   979 00007842 1E                      	push	ds
   980 00007843 B84000                  	mov	ax,biosdseg
   981 00007846 8ED8                    	mov	ds,ax
   982 00007848 A11300                  	mov	ax,word [memory_size]
   983 0000784B 1F                      	pop	ds
   984 0000784C CF                      	iret
   985                                  
   986                                  ;=========================================================================
   987                                  ; int_11 - Get equipment list
   988                                  ; Input:
   989                                  ;	none
   990                                  ; Output:
   991                                  ;	AX = equipment list
   992                                  ;-------------------------------------------------------------------------
   993                                  	setloc	0F84Dh			; INT 11 Entry Point
   994                                  int_11:
   995 0000784D FB                      	sti
   996 0000784E 1E                      	push	ds
   997 0000784F B84000                  	mov	ax,biosdseg
   998 00007852 8ED8                    	mov	ds,ax
   999 00007854 A11000                  	mov	ax,word [equipment_list]
  1000 00007857 1F                      	pop	ds
  1001 00007858 CF                      	iret
  1002                                  
  1003                                  ;=========================================================================
  1004                                  ; Includes with fixed entry points (for IBM compatibility)
  1005                                  ;-------------------------------------------------------------------------
  1006                                  
  1007                                  %include	"misc.inc"
  1008                              <1> ;=========================================================================
  1009                              <1> ; misc.inc - Miscellaneous BIOS Services
  1010                              <1> ;       INT 15h, functions:
  1011                              <1> ;       	4Fh	- OS hook keyboard intercept
  1012                              <1> ;		90h	- Device busy loop
  1013                              <1> ;		91h	- Interrupt completed
  1014                              <1> ;		0C0h	- Get system configruation
  1015                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
  1016                              <1> ;		
  1017                              <1> ;-------------------------------------------------------------------------
  1018                              <1> ;
  1019                              <1> ;=========================================================================
  1020                              <1> 
  1021                              <1> ;-------------------------------------------------------------------------
  1022                              <1> ; offsets for registers on stack
  1023                              <1> int_15_bp	equ	0
  1024                              <1> int_15_ip	equ	int_15_bp+2
  1025                              <1> int_15_cs	equ	int_15_ip+2
  1026                              <1> int_15_flags	equ	int_15_cs+2
  1027                              <1> 
  1028                              <1> ;=========================================================================
  1029                              <1> ; int_15 - Miscellaneous BIOS services
  1030                              <1> ; Input:
  1031                              <1> ;	AH = 4Fh - OS hook keyboard intercept
  1032                              <1> ;		- Does nothing
  1033                              <1> ;	AH = 0C2h - PS/2 mouse services
  1034                              <1> ;		- Implemented in ps2aux.inc
  1035                              <1> ;-------------------------------------------------------------------------
  1036                              <1> 	setloc	0F859h			; INT 15 Entry Point
  1037                              <1> int_15:
  1038 00007859 FB                  <1> 	sti
  1039 0000785A 80FC4F              <1> 	cmp	ah,4Fh
  1040 0000785D 742A                <1> 	je	int_15_exit		; continue with int 09h ISR
  1041 0000785F 80FCC0              <1> 	cmp	ah,0C0h
  1042 00007862 7426                <1> 	je	int_15_fnC0
  1043 00007864 3D0190              <1> 	cmp	ax,9001h
  1044 00007867 741E                <1> 	je	int_15_os_hook		; diskette - device busy hook
  1045 00007869 3DFD90              <1> 	cmp	ax,90FDh
  1046 0000786C 7419                <1> 	je	int_15_os_hook		; diskette - motor start hook
  1047 0000786E 3D0191              <1> 	cmp	ax,9101h
  1048 00007871 7414                <1> 	je	int_15_os_hook		; diskette - interrupt completed
  1049                              <1> 
  1050                              <1> %ifdef PS2_MOUSE
  1051                              <1> 	cmp	ah,0C2h
  1052                              <1> 	jne	.1
  1053                              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
  1054                              <1> .1:
  1055                              <1> %endif
  1056                              <1> 
  1057 00007873 B486                <1> 	mov	ah,86h			; no cassete present
  1058                              <1> 
  1059                              <1> int_15_err:
  1060 00007875 55                  <1> 	push	bp
  1061 00007876 89E5                <1> 	mov	bp,sp
  1062 00007878 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
  1063 0000787C 5D                  <1> 	pop	bp
  1064 0000787D CF                  <1> 	iret
  1065                              <1> 
  1066                              <1> int_15_ok:
  1067 0000787E 55                  <1> 	push	bp
  1068 0000787F 89E5                <1> 	mov	bp,sp
  1069 00007881 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
  1070 00007885 5D                  <1> 	pop	bp
  1071 00007886 CF                  <1> 	iret
  1072                              <1> 
  1073                              <1> int_15_os_hook:
  1074 00007887 B400                <1> 	mov	ah,00h
  1075                              <1> 
  1076                              <1> int_15_exit:
  1077 00007889 CF                  <1> 	iret
  1078                              <1> 
  1079                              <1> ;=========================================================================
  1080                              <1> ; int_15_fnC0 - Get configuration
  1081                              <1> ; Input:
  1082                              <1> ;	AH = 0C0h - get configuration
  1083                              <1> ; Output:
  1084                              <1> ;	AH = 00h - function supported
  1085                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
  1086                              <1> ;	CF = 0 (success)
  1087                              <1> ;-------------------------------------------------------------------------
  1088                              <1> int_15_fnC0:
  1089 0000788A B400                <1> 	mov	ah,00h
  1090 0000788C BB00F0              <1> 	mov	bx,bioscseg
  1091 0000788F 8EC3                <1> 	mov	es,bx
  1092 00007891 BB[F566]            <1> 	mov	bx,config_table
  1093 00007894 EBE8                <1> 	jmp	int_15_ok
  1008                                  
  1009                                  ;=========================================================================
  1010                                  ; extension_scan - scan for BIOS extensions
  1011                                  ; Input:
  1012                                  ;	DX - start segment
  1013                                  ;	BX - end segment
  1014                                  ; Returns:
  1015                                  ;	DX - address for the continuation of the scan
  1016                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  1017                                  ;-------------------------------------------------------------------------
  1018                                  extension_scan:
  1019 00007896 C70667000000            	mov	word [67h],0
  1020 0000789C C70669000000            	mov	word [69h],0
  1021                                  .scan:
  1022 000078A2 8EC2                    	mov	es,dx
  1023 000078A4 26813E000055AA              es	cmp	word [0],0AA55h	; check for signature
  1024 000078AB 7532                    	jnz	.next		; no signature, check next 2 KiB
  1025 000078AD 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  1026 000078B1 B400                    	mov	ah,0
  1027 000078B3 B105                    	mov	cl,5
  1028 000078B5 D3E0                    	shl	ax,cl		; convert size to paragraphs
  1029 000078B7 01C2                    	add	dx,ax
  1030 000078B9 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  1031 000078BC 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  1032 000078BF B104                    	mov	cl,4
  1033 000078C1 D3E0                    	shl	ax,cl		; convert size to bytes
  1034 000078C3 89C1                    	mov	cx,ax
  1035 000078C5 B000                    	mov	al,0
  1036 000078C7 31F6                    	xor	si,si
  1037                                  .checksum:
  1038 000078C9 260204                      es	add	al,byte [si]
  1039 000078CC 46                      	inc	si
  1040 000078CD E2FA                    	loop	.checksum
  1041 000078CF 08C0                    	or	al,al		; AL == 0?
  1042 000078D1 750C                    	jnz	.next		; AL not zero - bad checksum
  1043 000078D3 C70667000300            	mov	word [67h],3	; extension initialization offset
  1044 000078D9 8C066900                	mov	word [69h],es	; extension segment
  1045 000078DD EB08                    	jmp	.exit
  1046                                  .next:
  1047 000078DF 81C28000                	add	dx,80h		; add 2 KiB
  1048 000078E3 39DA                    	cmp	dx,bx
  1049 000078E5 72BB                    	jb	.scan
  1050                                  .exit:
  1051 000078E7 C3                      	ret
  1052                                  
  1053                                  ;=========================================================================
  1054                                  ; ipl - Initial Program Load - try to read and execute boot sector
  1055                                  ;-------------------------------------------------------------------------
  1056                                  ipl:
  1057 000078E8 FB                      	sti
  1058 000078E9 31C0                    	xor	ax,ax
  1059 000078EB 8ED8                    	mov	ds,ax
  1060 000078ED C7067800[C76F]          	mov	word [78h],int_1E	; set Floppy Parameters Table location
  1061 000078F3 8C0E7A00                	mov	word [7Ah],cs
  1062                                  
  1063                                  .boot_retry:
  1064 000078F7 B90400                  	mov	cx,4		; retry booting from floppy 4 times
  1065                                  
  1066                                  .fd_read_retry:
  1067 000078FA 51                      	push	cx
  1068 000078FB B400                    	mov	ah,00h		; reset disk system
  1069 000078FD B200                    	mov	dl,00h		; drive 0
  1070 000078FF CD13                    	int	13h
  1071 00007901 7220                    	jb	.fd_failed
  1072 00007903 B408                    	mov	ah,08h		; get drive parameters
  1073 00007905 B200                    	mov	dl,00h		; drive 0
  1074 00007907 CD13                    	int	13h
  1075 00007909 7218                    	jc	.fd_failed
  1076 0000790B 80FA00                  	cmp	dl,00h
  1077 0000790E 7416                    	jz	.try_hdd		; jump if zero drives
  1078 00007910 B80102                  	mov	ax,0201h		; read one sector
  1079 00007913 31D2                    	xor	dx,dx		; head 0, drive 0
  1080 00007915 8EC2                    	mov	es,dx		; to 0000:7C00
  1081 00007917 BB007C                  	mov	bx,7C00h
  1082 0000791A B90100                  	mov	cx,0001h		; track 0, sector 1
  1083 0000791D CD13                    	int	13h
  1084 0000791F 7202                    	jc	.fd_failed
  1085 00007921 EB1D                    	jmp	.check_signature	; read successful, check for boot sector
  1086                                  
  1087                                  .fd_failed:
  1088 00007923 59                      	pop	cx
  1089 00007924 E2D4                    	loop	.fd_read_retry
  1090                                  
  1091                                  ; try booting from HDD
  1092                                  .try_hdd:
  1093 00007926 B40D                    	mov	ah,0Dh		; reset hard disks
  1094 00007928 B280                    	mov	dl,80h		; drive 80h
  1095 0000792A CD13                    	int	13h
  1096 0000792C 7220                    	jc	.boot_failed
  1097 0000792E B80102                  	mov	ax,0201h		; read one sector
  1098 00007931 BA8000                  	mov	dx,0080h		; head 0, drive 80h
  1099 00007934 31C9                    	xor	cx,cx
  1100 00007936 8EC1                    	mov	es,cx
  1101 00007938 BB007C                  	mov	bx,7C00h		; to 0000:7C00
  1102 0000793B 41                      	inc	cx		; CX == 0001h; track 0, sector 1
  1103 0000793C CD13                    	int	13h
  1104 0000793E 720E                    	jc	.boot_failed
  1105                                  
  1106                                  .check_signature:
  1107 00007940 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  1108 00007947 7505                    	jnz	.boot_failed	; boot sector signature not found
  1109 00007949 EA007C0000              	jmp	0000h:7C00h	; jump to the boot sector
  1110                                  
  1111                                  .boot_failed:
  1112 0000794E BE[F502]                	mov	si,msg_boot_failed
  1113 00007951 E85A9D                  	call	print
  1114 00007954 B400                    	mov	ah,00h
  1115 00007956 CD16                    	int	16h
  1116 00007958 EB9D                    	jmp	.boot_retry
  1117                                  
  1118                                  ;=========================================================================
  1119                                  ; detect_ram - Determine the size of installed RAM and test it
  1120                                  ; Input:
  1121                                  ;	none
  1122                                  ; Output:
  1123                                  ;	AX = RAM size
  1124                                  ;	CX, SI - trashed
  1125                                  ;-------------------------------------------------------------------------
  1126                                  detect_ram:
  1127 0000795A B030                    	mov	al,e_ram_start		; RAM scan start
  1128 0000795C E680                    	out	post_reg,al
  1129                                  
  1130 0000795E 1E                      	push	ds
  1131 0000795F B106                    	mov	cl,6			; for SHL - converting KiB to segment
  1132 00007961 B82000                  	mov	ax,MIN_RAM_SIZE
  1133                                  
  1134                                  .fill_loop:
  1135 00007964 50                      	push	ax
  1136 00007965 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1137 00007967 8ED8                    	mov	ds,ax
  1138 00007969 A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  1139 0000796C 58                      	pop	ax
  1140 0000796D 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1141 00007970 3D8002                  	cmp	ax,MAX_RAM_SIZE
  1142 00007973 75EF                    	jne	.fill_loop
  1143 00007975 B82000                  	mov	ax,MIN_RAM_SIZE
  1144                                  
  1145                                  .size_loop:
  1146 00007978 50                      	push	ax
  1147 00007979 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1148 0000797B 8ED8                    	mov	ds,ax
  1149 0000797D 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  1150 00007981 750B                    	jne	.size_done
  1151 00007983 58                      	pop	ax
  1152 00007984 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1153 00007987 3D8002                  	cmp	ax,MAX_RAM_SIZE
  1154 0000798A 7303                    	jnb	.size_exit
  1155 0000798C EBEA                    	jmp	.size_loop
  1156                                  
  1157                                  .size_done:
  1158 0000798E 58                      	pop	ax
  1159                                  
  1160                                  .size_exit:
  1161 0000798F 1F                      	pop	ds
  1162 00007990 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  1163                                  
  1164                                  ; AX = detected memory size, now test the RAM
  1165                                  
  1166 00007993 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  1167 00007999 7474                    	je	.test_done
  1168                                  
  1169 0000799B BE[8E02]                	mov	si,msg_ram_testing
  1170 0000799E E80D9D                  	call	print
  1171 000079A1 B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  1172                                  
  1173                                  
  1174                                  
  1175                                  .test_loop:
  1176 000079A4 50                      	push	ax
  1177 000079A5 B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  1178 000079A7 B700                    	mov	bh,00h			; page 0
  1179 000079A9 CD10                    	int	10h			; position returned in DX
  1180 000079AB 58                      	pop	ax
  1181 000079AC E83C9D                  	call	print_dec
  1182 000079AF 50                      	push	ax
  1183 000079B0 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  1184 000079B2 B700                    	mov	bh,00h			; page 0
  1185 000079B4 CD10                    	int	10h
  1186 000079B6 B401                    	mov	ah,01h
  1187 000079B8 CD16                    	int	16h
  1188 000079BA 7412                    	jz	.test_no_key
  1189 000079BC B400                    	mov	ah,00h
  1190 000079BE CD16                    	int	16h			; read the keystroke
  1191 000079C0 3C1B                    	cmp	al,1Bh			; ESC?
  1192 000079C2 7421                    	je	.test_esc
  1193 000079C4 3D003B                  	cmp	ax,3B00h		; F1?
  1194 000079C7 7505                    	jne	.test_no_key
  1195 000079C9 800E120001              	or	byte [post_flags],post_setup
  1196                                  
  1197                                  .test_no_key:
  1198 000079CE 58                      	pop	ax
  1199 000079CF E83E00                  	call	ram_test_block
  1200 000079D2 721D                    	jc	.test_error			; error in last test
  1201 000079D4 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  1202 000079D7 3B061300                	cmp	ax,word [memory_size]
  1203 000079DB 72C7                    	jb	.test_loop
  1204                                  
  1205 000079DD 50                      	push	ax
  1206 000079DE B031                    	mov	al,e_ram_complete		; RAM scan complete
  1207 000079E0 E680                    	out	post_reg,al
  1208 000079E2 58                      	pop	ax
  1209                                  
  1210 000079E3 EB2A                    	jmp	.test_done
  1211                                  
  1212                                  .test_esc:
  1213 000079E5 58                      	pop	ax
  1214 000079E6 A11300                  	mov	ax,word [memory_size]
  1215                                  
  1216 000079E9 50                      	push	ax
  1217 000079EA B032                    	mov	al,e_ram_esc		; RAM scan canceled
  1218 000079EC E680                    	out	post_reg,al
  1219 000079EE 58                      	pop	ax
  1220                                  
  1221 000079EF EB1E                    	jmp	.test_done
  1222                                  
  1223                                  .test_error:
  1224 000079F1 A31300                  	mov	word [memory_size],ax	; store size of good memory
  1225 000079F4 BE[AD02]                	mov	si,msg_ram_error
  1226 000079F7 E8B49C                  	call	print
  1227 000079FA E8EE9C                  	call	print_dec
  1228 000079FD BE[EF02]                	mov	si,msg_kib
  1229 00007A00 E8AB9C                  	call	print
  1230 00007A03 BE[5000]                	mov	si,msg_crlf
  1231 00007A06 E8A59C                  	call	print
  1232                                  
  1233 00007A09 50                      	push	ax
  1234 00007A0A B055                    	mov	al,e_ram_fail		; RAM scan failed
  1235 00007A0C E680                    	out	post_reg,al
  1236 00007A0E 58                      	pop	ax
  1237                                  
  1238                                  .test_done:
  1239 00007A0F C3                      	ret
  1240                                  
  1241                                  ;=========================================================================
  1242                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  1243                                  ; Input:
  1244                                  ;	AX = address of the memory to test (in KiB)
  1245                                  ; Output:
  1246                                  ;	CF = status
  1247                                  ;		0 = passed
  1248                                  ;		1 = failed
  1249                                  ;-------------------------------------------------------------------------
  1250                                  ram_test_block:
  1251 00007A10 50                      	push	ax
  1252 00007A11 53                      	push	bx
  1253 00007A12 51                      	push	cx
  1254 00007A13 56                      	push	si
  1255 00007A14 57                      	push	di
  1256 00007A15 1E                      	push	ds
  1257 00007A16 06                      	push	es
  1258 00007A17 B106                    	mov	cl,6			; convert KiB to segment address
  1259 00007A19 D3E0                    	shl	ax,cl			; (multiply by 64)
  1260 00007A1B 8ED8                    	mov	ds,ax
  1261 00007A1D 8EC0                    	mov	es,ax
  1262 00007A1F 31F6                    	xor	si,si
  1263 00007A21 31FF                    	xor	di,di
  1264 00007A23 BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  1265 00007A26 B8AA55                  	mov	ax,55AAh			; first test pattern
  1266 00007A29 89D9                    	mov	cx,bx
  1267 00007A2B F3AB                        rep	stosw				; store test pattern
  1268 00007A2D 89D9                    	mov	cx,bx			; RAM test block size
  1269                                  .1:
  1270 00007A2F AD                      	lodsw
  1271 00007A30 3DAA55                  	cmp	ax,55AAh			; compare to the test pattern
  1272 00007A33 7522                    	jne	.fail
  1273 00007A35 E2F8                    	loop	.1
  1274 00007A37 31F6                    	xor	si,si
  1275 00007A39 31FF                    	xor	di,di
  1276 00007A3B B855AA                  	mov	ax,0AA55h		; second test pattern
  1277 00007A3E 89D9                    	mov	cx,bx			; RAM test block size
  1278 00007A40 F3AB                        rep stosw				; store test pattern
  1279 00007A42 89D9                    	mov	cx,bx			; RAM test block size
  1280                                  .2:
  1281 00007A44 AD                      	lodsw
  1282 00007A45 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  1283 00007A48 750D                    	jne	.fail
  1284 00007A4A E2F8                    	loop	.2
  1285 00007A4C 31FF                    	xor	di,di
  1286 00007A4E 31C0                    	xor	ax,ax			; zero
  1287 00007A50 89D9                    	mov	cx,bx			; RAM test block size
  1288 00007A52 F3AB                        rep stosw				; zero the memory
  1289 00007A54 F8                      	clc				; test passed, clear CF
  1290 00007A55 EB01                    	jmp	.exit
  1291                                  
  1292                                  .fail:
  1293 00007A57 F9                      	stc				; test failed, set CF
  1294                                  	
  1295                                  .exit:
  1296 00007A58 07                      	pop	es
  1297 00007A59 1F                      	pop	ds
  1298 00007A5A 5F                      	pop	di
  1299 00007A5B 5E                      	pop	si
  1300 00007A5C 59                      	pop	cx
  1301 00007A5D 5B                      	pop	bx
  1302 00007A5E 58                      	pop	ax
  1303 00007A5F C3                      	ret
  1304                                  
  1305                                  ;=========================================================================
  1306                                  ; Includes with fixed entry points (for IBM compatibility)
  1307                                  ;-------------------------------------------------------------------------
  1308                                  %include	"fnt00-7F.inc"
  1309                              <1> ;=========================================================================
  1310                              <1> ; fnt00-7F.inc - Font for graphics modes
  1311                              <1> ;       Characters from 00h to 7Fh
  1312                              <1> ;-------------------------------------------------------------------------
  1313                              <1> ;
  1314                              <1> ;=========================================================================
  1315 00007A60 FF<rep Eh>          <1> 	setloc	0FA6Eh			; IBM graphics char set entry
  1315          ******************  <1>  warning: Inserting 14 bytes [-w+user]
  1316                              <1> gfx_font:
  1317 00007A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
  1318 00007A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
  1319 00007A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
  1320 00007A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
  1321 00007A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
  1322 00007A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
  1323 00007A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
  1324 00007AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
  1325 00007AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
  1326 00007AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
  1327 00007ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
  1328 00007AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
  1329 00007ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
  1330 00007AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
  1331 00007ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
  1332 00007AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
  1333 00007AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
  1334 00007AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
  1335 00007AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
  1336 00007B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
  1337 00007B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
  1338 00007B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
  1339 00007B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
  1340 00007B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
  1341 00007B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
  1342 00007B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
  1343 00007B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
  1344 00007B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
  1345 00007B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
  1346 00007B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
  1347 00007B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
  1348 00007B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
  1349 00007B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
  1350 00007B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
  1351 00007B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
  1352 00007B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
  1353 00007B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
  1354 00007B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
  1355 00007B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
  1356 00007BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
  1357 00007BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
  1358 00007BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
  1359 00007BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
  1360 00007BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
  1361 00007BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
  1362 00007BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
  1363 00007BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
  1364 00007BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
  1365 00007BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
  1366 00007BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
  1367 00007BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
  1368 00007C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
  1369 00007C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
  1370 00007C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
  1371 00007C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
  1372 00007C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
  1373 00007C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
  1374 00007C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
  1375 00007C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
  1376 00007C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
  1377 00007C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
  1378 00007C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
  1379 00007C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
  1380 00007C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
  1381 00007C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
  1382 00007C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
  1383 00007C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
  1384 00007C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
  1385 00007C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
  1386 00007C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
  1387 00007C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
  1388 00007CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
  1389 00007CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
  1390 00007CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  1391 00007CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
  1392 00007CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
  1393 00007CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
  1394 00007CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
  1395 00007CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
  1396 00007CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
  1397 00007CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
  1398 00007CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
  1399 00007CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
  1400 00007D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
  1401 00007D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
  1402 00007D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
  1403 00007D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  1404 00007D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
  1405 00007D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
  1406 00007D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
  1407 00007D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
  1408 00007D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
  1409 00007D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
  1410 00007D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
  1411 00007D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
  1412 00007D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
  1413 00007D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
  1414 00007D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
  1415 00007D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
  1416 00007D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
  1417 00007D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
  1418 00007D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
  1419 00007D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
  1420 00007DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  1421 00007DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
  1422 00007DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
  1423 00007DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
  1424 00007DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
  1425 00007DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  1426 00007DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
  1427 00007DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
  1428 00007DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
  1429 00007DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
  1430 00007DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
  1431 00007DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
  1432 00007E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
  1433 00007E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
  1434 00007E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
  1435 00007E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  1436 00007E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
  1437 00007E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
  1438 00007E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  1439 00007E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
  1440 00007E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
  1441 00007E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
  1442 00007E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
  1443 00007E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
  1444 00007E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
  1309                                  %include	"time2.inc"
  1310                              <1> ;=========================================================================
  1311                              <1> ; time2.int - BIOS Time Services
  1312                              <1> ;       INT 1Ah - BIOS Time Serivces
  1313                              <1> ;		dispatcher
  1314                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
  1315                              <1> ;-------------------------------------------------------------------------
  1316                              <1> ;
  1317                              <1> ; Compiles with NASM 2.11.08, might work with other versions
  1318                              <1> ;
  1319                              <1> ; Copyright (C) 2010 - 2020 Sergey Kiselev.
  1320                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1321                              <1> ;
  1322                              <1> ; This program is free software: you can redistribute it and/or modify
  1323                              <1> ; it under the terms of the GNU General Public License as published by
  1324                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1325                              <1> ; (at your option) any later version.
  1326                              <1> ;
  1327                              <1> ; This program is distributed in the hope that it will be useful,
  1328                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1329                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1330                              <1> ; GNU General Public License for more details.
  1331                              <1> ;
  1332                              <1> ; You should have received a copy of the GNU General Public License
  1333                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1334                              <1> ;
  1335                              <1> ;=========================================================================
  1336                              <1> 
  1337                              <1> ;=========================================================================
  1338                              <1> ; int_1A - BIOS Time Services
  1339                              <1> ; Note: see time1.inc for functions implementation
  1340                              <1> ;-------------------------------------------------------------------------
  1341                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
  1342                              <1> int_1A:
  1343 00007E6E 53                  <1> 	push	bx
  1344 00007E6F 1E                  <1> 	push	ds
  1345 00007E70 BB4000              <1> 	mov	bx,biosdseg
  1346 00007E73 8EDB                <1> 	mov	ds,bx
  1347 00007E75 80FC02              <1> 	cmp	ah,.max/2
  1348 00007E78 730F                <1> 	jae	int_1A_exit
  1349 00007E7A B700                <1> 	mov	bh,0
  1350 00007E7C 88E3                <1> 	mov	bl,ah
  1351 00007E7E D1E3                <1> 	shl	bx,1
  1352 00007E80 2EFFA7[857E]        <1>     cs	jmp	near [.dispatch+bx]
  1353                              <1> .dispatch:
  1354 00007E85 [9007]              <1> 	dw	int_1A_fn00
  1355 00007E87 [A207]              <1> 	dw	int_1A_fn01
  1356                              <1> %ifdef AT_RTC
  1357                              <1> 	dw	int_1A_fn02
  1358                              <1> 	dw	int_1A_fn03
  1359                              <1> 	dw	int_1A_fn04
  1360                              <1> 	dw	int_1A_fn05
  1361                              <1> 	dw	int_1A_fn06
  1362                              <1> 	dw	int_1A_fn07
  1363                              <1> %endif ; AT_RTC
  1364                              <1> .max	equ	$-.dispatch
  1365                              <1> int_1A_exit:
  1366 00007E89 1F                  <1> 	pop	ds
  1367 00007E8A 5B                  <1> 	pop	bx
  1368 00007E8B CF                  <1> 	iret
  1369                              <1> int_1A_exitf:
  1370 00007E8C 1F                  <1> 	pop	ds
  1371 00007E8D 5B                  <1> 	pop	bx
  1372 00007E8E CA0200              <1> 	retf	2
  1373                              <1> 
  1374                              <1> ;=========================================================================
  1375                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
  1376                              <1> ;-------------------------------------------------------------------------
  1377 00007E91 FF<rep 14h>         <1> 	setloc	0FEA5h			; INT 08 Entry Point
  1377          ******************  <1>  warning: Inserting 20 bytes [-w+user]
  1378                              <1> int_08:
  1379 00007EA5 50                  <1> 	push	ax
  1380 00007EA6 1E                  <1> 	push	ds
  1381 00007EA7 B84000              <1> 	mov	ax,biosdseg
  1382 00007EAA 8ED8                <1> 	mov	ds,ax
  1383 00007EAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
  1384 00007EB1 7413                <1> 	jz	.1
  1385 00007EB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
  1386 00007EB7 750D                <1> 	jnz	.1
  1387 00007EB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
  1388 00007EBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
  1389 00007EC0 52                  <1> 	push	dx
  1390 00007EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
  1391 00007EC4 EE                  <1> 	out	dx,al
  1392 00007EC5 5A                  <1> 	pop	dx
  1393                              <1> .1:
  1394 00007EC6 FF066C00            <1> 	inc	word [ticks_lo]
  1395 00007ECA 7504                <1> 	jnz	.2
  1396 00007ECC FF066E00            <1> 	inc	word [ticks_hi]
  1397                              <1> .2:
  1398 00007ED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
  1399 00007ED5 7519                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
  1400 00007ED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
  1401 00007EDD 7511                <1> 	jnz	.3
  1402 00007EDF C7066E000000        <1> 	mov	word [ticks_hi],0
  1403 00007EE5 C7066C000000        <1> 	mov	word [ticks_lo],0
  1404 00007EEB C606700001          <1> 	mov	byte [new_day],1
  1405                              <1> .3:
  1406 00007EF0 CD1C                <1> 	int	1Ch			; User timer interrupt
  1407 00007EF2 B020                <1> 	mov	al,20h
  1408 00007EF4 E620                <1> 	out	pic1_reg0,al
  1409 00007EF6 1F                  <1> 	pop	ds
  1410 00007EF7 58                  <1> 	pop	ax
  1411 00007EF8 CF                  <1> 	iret
  1310                                  
  1311                                  ;=========================================================================
  1312                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
  1313                                  ;		如果硬件中断，则向PIC发送中断信号结束，返回
  1314                                  ;-------------------------------------------------------------------------
  1315 00007EF9 FF<rep 2Ah>             	setloc	0FF23h			; Spurious IRQ Handler Entry Point 虚假IRQ处理程序入口点
  1315          ******************       warning: Inserting 42 bytes [-w+user]
  1316                                  int_ignore:
  1317 00007F23 50                      	push	ax
  1318 00007F24 1E                      	push	ds
  1319 00007F25 B84000                  	mov	ax,biosdseg
  1320 00007F28 8ED8                    	mov	ds,ax
  1321 00007F2A B00B                    	mov	al,0Bh			;(0000 1011) PIC OCW3 - read in-service register
  1322 00007F2C E620                    	out	pic1_reg0,al
  1323 00007F2E 90                      	nop
  1324 00007F2F E420                    	in	al,pic1_reg0		; get IRQ number
  1325                                  ;	mov	al,09h			; get IRQ number
  1326 00007F31 88C4                    	mov	ah,al
  1327 00007F33 08C0                    	or	al,al
  1328 00007F35 7504                    	jnz	.1
  1329 00007F37 B4FF                    	mov	ah,0FFh
  1330 00007F39 EB0A                    	jmp	.2
  1331                                  .1:
  1332 00007F3B E421                    	in	al,pic1_reg1		; clear the interrupt
  1333 00007F3D 08E0                    	or	al,ah
  1334 00007F3F E621                    	out	pic1_reg1,al
  1335 00007F41 B020                    	mov	al,20h			; end of interrupt
  1336 00007F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
  1337                                  .2:
  1338 00007F45 88266B00                	mov	byte [last_irq],ah
  1339 00007F49 1F                      	pop	ds
  1340 00007F4A 58                      	pop	ax
  1341 00007F4B CF                      	iret
  1342                                  
  1343                                  ;=========================================================================
  1344                                  ; int_dummy - Dummy interrupt handler. Do nothing, return. 虚拟中断处理程序。什么也不做，返回。
  1345                                  ;-------------------------------------------------------------------------
  1346 00007F4C FF<rep 7h>              	setloc	0FF53h			; Dummy Interrupt Handler
  1346          ******************       warning: Inserting 7 bytes [-w+user]
  1347                                  int_dummy:
  1348 00007F53 CF                      	iret
  1349                                  
  1350                                  ;=========================================================================
  1351                                  ; int_05 - BIOS Print Screen
  1352                                  ;-------------------------------------------------------------------------
  1353                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
  1354                                  int_05:
  1355 00007F54 FB                      	sti
  1356 00007F55 50                      	push	ax
  1357 00007F56 53                      	push	bx
  1358 00007F57 51                      	push	cx
  1359 00007F58 52                      	push	dx
  1360 00007F59 1E                      	push	ds
  1361 00007F5A B84000                  	mov	ax,biosdseg
  1362 00007F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
  1363 00007F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
  1364 00007F64 746A                    	je	.exit			; print screen is already in progress
  1365 00007F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
  1366                                  					; signal that print screen is running
  1367                                  
  1368 00007F6B B40F                    	mov	ah,0Fh			; get video mode parameters
  1369 00007F6D CD10                    	int	10h			; returns number of columns in AH
  1370                                  					; and active display page in BH
  1371 00007F6F 88E1                    	mov	cl,ah			; store number columns
  1372                                  
  1373 00007F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
  1374 00007F75 08ED                    	or	ch,ch
  1375 00007F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
  1376                                  
  1377 00007F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
  1378 00007F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
  1379 00007F7E 7602                    	jbe	.get_cursor_pos
  1380                                  
  1381                                  .wrong_num_rows:
  1382 00007F80 B519                    	mov	ch,25			; assume 25 rows
  1383                                  
  1384                                  .get_cursor_pos:
  1385 00007F82 B403                    	mov	ah,03h			; get cursor position and size
  1386 00007F84 CD10                    	int	10h			; returns cursor position in DX
  1387 00007F86 52                      	push	dx			; save original position / DX in stack
  1388                                  
  1389                                  	
  1390 00007F87 B40D                    	mov	ah,0Dh			; move to the next line
  1391 00007F89 E85100                  	call	.print_char
  1392 00007F8C 7548                    	jnz	.error
  1393 00007F8E B40A                    	mov	ah,0Ah
  1394 00007F90 E84A00                  	call	.print_char
  1395 00007F93 7541                    	jnz	.error
  1396                                  
  1397 00007F95 B600                    	mov 	dh,0			; start from the first row (0)
  1398                                  
  1399                                  .row_loop:
  1400 00007F97 B200                    	mov 	dl,0			; start from the first column (0)
  1401                                  
  1402                                  .column_loop:
  1403 00007F99 B402                    	mov	ah,02h
  1404 00007F9B CD10                    	int	10h			; set cursor position (position in DX)
  1405                                  
  1406 00007F9D B408                    	mov	ah,08h
  1407 00007F9F CD10                    	int	10h			; read character at cursor position
  1408                                  
  1409 00007FA1 3C20                    	cmp	al,20h			; control character?
  1410 00007FA3 7302                    	jae	.continue		; no, print it
  1411 00007FA5 B020                    	mov	al,20h			; print space instead
  1412                                  
  1413                                  .continue:
  1414 00007FA7 E83300                  	call	.print_char
  1415 00007FAA 752A                    	jnz	.error
  1416 00007FAC FEC2                    	inc	dl
  1417 00007FAE 38CA                    	cmp	dl,cl			; on the last column?
  1418 00007FB0 72E7                    	jb	.column_loop		; print next column
  1419                                  
  1420 00007FB2 B40D                    	mov	ah,0Dh			; move to the next line
  1421 00007FB4 E82600                  	call	.print_char
  1422 00007FB7 751D                    	jnz	.error
  1423 00007FB9 B40A                    	mov	ah,0Ah
  1424 00007FBB E81F00                  	call	.print_char
  1425 00007FBE 7516                    	jnz	.error
  1426                                  
  1427 00007FC0 FEC6                    	inc	dh
  1428 00007FC2 38EE                    	cmp	dh,ch			; on the last row?
  1429 00007FC4 72D1                    	jb	.row_loop		; print next row
  1430                                  
  1431 00007FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
  1432                                  					; ready for the next call
  1433                                  
  1434                                  .restore_cursor:
  1435 00007FCB 5A                      	pop	dx			; DX = original cursor position
  1436 00007FCC B402                    	mov	ah,02h
  1437 00007FCE CD10                    	int	10h			; set cursor position (position in DX)
  1438                                  
  1439                                  .exit:
  1440 00007FD0 1F                      	pop	ds
  1441 00007FD1 5A                      	pop	dx
  1442 00007FD2 59                      	pop	cx
  1443 00007FD3 5B                      	pop	bx
  1444 00007FD4 58                      	pop	ax
  1445 00007FD5 CF                      	iret
  1446                                  
  1447                                  .error:
  1448 00007FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
  1449                                  					; signal failure
  1450 00007FDB EBEE                    	jmp	.restore_cursor
  1451                                  	
  1452                                  
  1453                                  .print_char:
  1454 00007FDD 52                      	push	dx
  1455 00007FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
  1456 00007FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
  1457 00007FE2 CD17                    	int	17h
  1458 00007FE4 5A                      	pop	dx
  1459 00007FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
  1460 00007FE8 C3                      	ret
  1461                                  
  1462                                  ;=========================================================================
  1463                                  ; start - at power up or reset execution starts here (F000:FFF0)
  1464                                  ;-------------------------------------------------------------------------
  1465 00007FE9 FF<rep 7h>                      setloc	0FFF0h			; Power-On Entry Point
  1465          ******************       warning: Inserting 7 bytes [-w+user]
  1466                                  start:
  1467 00007FF0 EA[5B60]00F0                    jmp     bioscseg:cold_start
  1468                                  
  1469                                  	setloc	0FFF5h			; ROM Date in ASCII
  1470 00007FF5 31322F32302F3232        	db	DATE			; BIOS release date MM/DD/YY
  1471 00007FFD 20                      	db	20h
  1472                                  
  1473                                  	setloc	0FFFEh			; System Model byte
  1474 00007FFE FC                      	db	MODEL_BYTE
  1475 00007FFF FF                      	db	0ffh
